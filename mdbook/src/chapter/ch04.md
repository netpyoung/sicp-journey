# 4장. 메타언어적 추상화

- Metalinguistic Abstraction
  - 4장은, Lisp로 Lisp 인터프리터를 작성하며, 언어의 문법과 의미를 스스로 설계하는 능력을 배운다.
  - MIT OpenCourseWare
    - [Lecture 7B: Metacircular Evaluator, Part 1](https://www.youtube.com/watch?v=aAlR3cezPJg&list=PLE18841CABEA24090)
    - [Lecture 7B: Metacircular Evaluator, Part 2](https://www.youtube.com/watch?v=QVEOq5k6Xi0&list=PLE18841CABEA24090)


![](../res/hand-write-hand.jpg)

우리는 당면한 문제에 특히 적합한 [용어]를 사용하여 문제를 다른 방식으로 설명하고 (따라서 사고할 수 있도록) 복잡한 문제를 처리하는 능력을 향상시킬 수 있습니다

"우리가 지금 사용하고 있는 언어(Scheme)를 사용해서, 또 다른 언어의 규칙과 의미를 정의하거나 해석하는 것"
프로그래밍 언어를 직접 정의하고 확장하는 추상화 기법이다.

---

## TODO


4.1 lisp로 lisp 인터프리터 만들기.
4.2 normal-order evaluation
  - 3장에서 상태를 덮어쓰기 때문에 생겨나는 여러 복잡한 문제를 피하기 위해 스트림 데이터(lazy sequence)를 사용.
  - Scheme(혹은 Racket)은 스트림 프로그램을 짜기에 번거로운 점이 있다
4.3 nondeterministic computing
4.4 logic-programming - prolog같은 논리형 프로그래밍


(list? '())
;;=> #t
(pair? '())
;;=> #f

## 인터프리터와 컴파일러

- 인터프리터: 표현식을 직접 실행
- 컴파일러: 고수준 표현식을 더 낮은 수준(예: 가상 머신 코드, 기계어)으로 변환하고 그것을 실행
  - 단순한 인터프리터 대비 컴파일은 중복 평가 제거, 공통 하위 표현식 최적화 등이 가능.

## Eval & Apply

4.1은 Eval과 Apply로 시작하게 된다.

코드가 길고 car/cdr/cadr/caddr ... 난리도 아니다.
다음을 정의하고 시작하자
(define first car)
(define rest  cdr)
(define second cadr)
(define third  caddr)



``` lisp

;; ============================================================================
;; EVAL
;; ============================================================================

(define (eval exp env)
  (cond ((self-evaluating? exp)
         exp)
        ((variable? exp)
         (lookup-variable-value exp env))
        ((quoted? exp)
         (text-of-quotation exp))
        ((assignment? exp)
         (eval-assignment exp env))
        ((definition? exp)
         (eval-definition exp env))
        ((if? exp)
         (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp) (lambda-body exp) env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp)
         (eval (cond->if exp) env) )
        ((application? exp)
         (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
        (else
         (error "Unknown expresslon type -- EVAL" exp))))

(define (self-evaluating? exp) nil)
(define (variable? exp) nil)
(define (quoted? exp) nil)
(define (assignment? exp) nil)
(define (definition? exp) nil)
(define (if? exp) nil)
(define (lambda? exp) nil)
(define (begin? exp) nil)
(define (cond? exp) nil)
(define (application? exp) nil)

(define (lookup-variable-value exp env)nil)
(define (text-of-quotation exp) nil)

(define (eval-assignment exp env) nil)
(define (eval-definition exp env) nil)
(define (eval-if exp env) nil)
(define (eval-sequence exps env) nil)

(define (make-procedure exp1 exp2 env) nil)
(define (lambda-parameters exp) nil)
(define (lambda-body exp) nil)
(define (begin-actions exp) nil)
(define (cond->if exp) nil)
(define (operator exp) nil)
(define (list-of-values exps env) nil)
(define (operands exp) nil)

;; ============================================================================
;; APPLY
;; ============================================================================

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (primitive-procedure? procedure) nil)
(define (compound-procedure? procedure) nil)
(define (apply-primitive-procedure procedure arguments) nil)
(define (procedure-body procedure) nil)
(define (extend-environment parameters arguments env) nil)
(define (procedure-parameters procedure) nil)
(define (procedure-environment procedure) nil)
```

## 4.1

(eval environment expression)
(apply function function-arguments)

1. 언어를 처리하는 기법

4.1 메타써큘러 실행기
4.1.1 언어 실행기의 알짜배기
eval / apply

4.1.2 식을 나타내는 방법
eval

(define (self-evaluating? exp) (or (number? exp) (string? exp)))
(define (variable?        exp) (symbol? exp))
(define (quoted?          exp) (tagged-list? exp 'quote))
(define (assignment?      exp) (tagged-list? exp 'set!))
(define (definition?      exp) (tagged-list? exp 'define))
(define (if?              exp) (tagged-list? exp 'if))
(define (lambda?          exp) (tagged-list? exp 'lambda))
(define (begin?           exp) (tagged-list? exp 'begin))
(define (cond?            exp) (tagged-list? exp 'cond))
(define (application?     exp) (pair? exp))


4.1.3 언어 실행기에서 쓰는 데이터 구조
평가기evaluator를 구현할 때는 프로그램의 외부 문법(external syntax)만 정의하는 것이 아니라
프로그램 실행 과정에서 평가기가 내부적으로 다루는 데이터 구조도 정의해야 함

참과 거짓
(define (true?  x) (eq? x true))
(define (false? x) (not (true? x)))

내장 함수 ( primitive-procedure // aka built-in-function )

  (apply-primitive-procedure
  (primitive-procedure?

환경(env)
  (lookup-variable-value
  (extend-environment
  (define-variable!
  (set-variable-value!

4.1.4 언어 실행기를 보통 프로그램처럼 돌려보기
4.1.5 프로그램도 데이터처럼
4.1.6 안쪽 정의(internal definition)
4.1.7 문법 분석과 실행 과정을 떼어놓기

4.2 Scheme 바꿔보기 - 제때 계산법
4.2.1 식의 값을 구하는 차례 - 정의대로 계산법과 인자 먼저 계산법
4.2.2 제때 계산법을 따르는 실행기
4.2.3 제때셈 리스트와 스트림

4.3 Scheme 바꿔보기 - 비결정적 계산
4.3.1 amb와 찾기
4.3.2 비결정적 프로그램 짜기
4.3.3 amb 실행기 구현

4.4 논리로 프로그램 짜기
4.4.1 연역식 정보 찾기
4.4.2 쿼리 시스템의 동작 방식
4.4.3 논리 프로그래밍은 수학 논리를 따르는가?
4.4.4 쿼리 시스템 만들기
4.4.4.1 드라이버 루프와 쿼리 값 찍어내기(instantiation)
4.4.4.2 실행기(evaluator)
4.4.4.3 패턴 매칭으로 참말 찾아내기
4.4.4.4 규칙과 동일화
4.4.4.5 데이터베이스의 관리
4.4.4.6 스트림 연산
4.4.4.7 쿼리의 문법을 처리하는 프로시저
4.4.4.8 일람표와 정의


