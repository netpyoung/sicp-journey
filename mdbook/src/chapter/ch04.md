# 4장. 메타언어적 추상화

- Metalinguistic Abstraction
  - 4장은, Lisp로 Lisp 인터프리터를 작성하며, 언어의 문법과 의미를 스스로 설계하는 능력을 배운다.
  - MIT OpenCourseWare
    - [Lecture 7B: Metacircular Evaluator, Part 1](https://www.youtube.com/watch?v=aAlR3cezPJg&list=PLE18841CABEA24090)
    - [Lecture 7B: Metacircular Evaluator, Part 2](https://www.youtube.com/watch?v=QVEOq5k6Xi0&list=PLE18841CABEA24090)



![](../res/hand-write-hand.jpg)

우리는 당면한 문제에 특히 적합한 [용어]를 사용하여 문제를 다른 방식으로 설명하고 (따라서 사고할 수 있도록) 복잡한 문제를 처리하는 능력을 향상시킬 수 있습니다

"우리가 지금 사용하고 있는 언어(Scheme)를 사용해서, 또 다른 언어의 규칙과 의미를 정의하거나 해석하는 것"
프로그래밍 언어를 직접 정의하고 확장하는 추상화 기법이다.

---

## TODO


4.1 lisp로 lisp 인터프리터 만들기.

저자가 작성한 eval / apply / env / frame 설명
연습문제로 let / let* / letrec 확장을 볼 수 있다.
halt problem

4.2 normal-order evaluation
  - 3장에서 상태를 덮어쓰기 때문에 생겨나는 여러 복잡한 문제를 피하기 위해 스트림 데이터(lazy sequence)를 사용.
  - Scheme(혹은 Racket)은 스트림 프로그램을 짜기에 번거로운 점이 있다
4.3 nondeterministic computing
4.4 logic-programming - prolog같은 논리형 프로그래밍


(list? '())
;;=> #t
(pair? '())
;;=> #f

## 인터프리터와 컴파일러

- 인터프리터: 표현식을 직접 실행
- 컴파일러: 고수준 표현식을 더 낮은 수준(예: 가상 머신 코드, 기계어)으로 변환하고 그것을 실행
  - 단순한 인터프리터 대비 컴파일은 중복 평가 제거, 공통 하위 표현식 최적화 등이 가능.

## Eval & Apply

4.1은 Eval과 Apply로 시작하게 된다.

코드가 길고 car/cdr/cadr/caddr ... 난리도 아니다.
다음을 정의하고 시작하자
(define first car)
(define rest  cdr)
(define second cadr)
(define third  caddr)



``` lisp

;; ============================================================================
;; EVAL
;; ============================================================================

(define (eval exp env)
  (cond ((self-evaluating? exp)
         exp)
        ((variable? exp)
         (lookup-variable-value exp env))
        ((quoted? exp)
         (text-of-quotation exp))
        ((assignment? exp)
         (eval-assignment exp env))
        ((definition? exp)
         (eval-definition exp env))
        ((if? exp)
         (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp) (lambda-body exp) env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp)
         (eval (cond->if exp) env) )
        ((application? exp)
         (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
        (else
         (error "Unknown expresslon type -- EVAL" exp))))

(define (self-evaluating? exp) nil)
(define (variable? exp) nil)
(define (quoted? exp) nil)
(define (assignment? exp) nil)
(define (definition? exp) nil)
(define (if? exp) nil)
(define (lambda? exp) nil)
(define (begin? exp) nil)
(define (cond? exp) nil)
(define (application? exp) nil)

(define (lookup-variable-value exp env)nil)
(define (text-of-quotation exp) nil)

(define (eval-assignment exp env) nil)
(define (eval-definition exp env) nil)
(define (eval-if exp env) nil)
(define (eval-sequence exps env) nil)

(define (make-procedure exp1 exp2 env) nil)
(define (lambda-parameters exp) nil)
(define (lambda-body exp) nil)
(define (begin-actions exp) nil)
(define (cond->if exp) nil)
(define (operator exp) nil)
(define (list-of-values exps env) nil)
(define (operands exp) nil)

;; ============================================================================
;; APPLY
;; ============================================================================

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (primitive-procedure? procedure) nil)
(define (compound-procedure? procedure) nil)
(define (apply-primitive-procedure procedure arguments) nil)
(define (procedure-body procedure) nil)
(define (extend-environment parameters arguments env) nil)
(define (procedure-parameters procedure) nil)
(define (procedure-environment procedure) nil)
```

## 4.1

(eval environment expression)
(apply function function-arguments)

1. 언어를 처리하는 기법

4.1 메타써큘러 실행기
4.1.1 언어 실행기의 알짜배기
eval / apply

4.1.2 식을 나타내는 방법
eval

(define (self-evaluating? exp) (or (number? exp) (string? exp)))
(define (variable?        exp) (symbol? exp))
(define (quoted?          exp) (tagged-list? exp 'quote))
(define (assignment?      exp) (tagged-list? exp 'set!))
(define (definition?      exp) (tagged-list? exp 'define))
(define (if?              exp) (tagged-list? exp 'if))
(define (lambda?          exp) (tagged-list? exp 'lambda))
(define (begin?           exp) (tagged-list? exp 'begin))
(define (cond?            exp) (tagged-list? exp 'cond))
(define (application?     exp) (pair? exp))


4.1.3 언어 실행기에서 쓰는 데이터 구조
평가기evaluator를 구현할 때는 프로그램의 외부 문법(external syntax)만 정의하는 것이 아니라
프로그램 실행 과정에서 평가기가 내부적으로 다루는 데이터 구조도 정의해야 함

참과 거짓
(define (true?  x) (eq? x true))
(define (false? x) (not (true? x)))

내장 함수 ( primitive-procedure // aka built-in-function )

  (apply-primitive-procedure
  (primitive-procedure?

환경(env)
  (lookup-variable-value
  (extend-environment
  (define-variable!
  (set-variable-value!


eval을 테스트하기 껄끄럽기에 연습문제 4.01 ~ 4.14는 4.1.4 Running the Evaluator as a Program 까지 읽고 풀기.

- 개념
  - frame
    - ((symbol-a symbol-b ...) value-a (primitive func-b) ...)
    - 변수/함수이름 리스트 + 변수/함수들...
    - 연습문제 4.11에서
      - '((변수/함수이름 변수/함수) ...) 식으로 바꿈
      - '((symbol-a value-a) (symbol-b (primitive func-b)) ...)
  - environment
    - (frame-a frame-b)
    - 프레임 리스트
    - (cons new-frame env)
    - (cons 'b '(a)) => (b a) 새로운 frame이 앞에오는 구조

4.1.4 언어 실행기를 보통 프로그램처럼 돌려보기

set-car!
set-cdr!

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))

연습 4.13 ** 문제 make-unbound! 함수를 만들어 env에서 지울 수 있도록 만들자. first-frame에서만 지우면 되는가?


4.1.5 Data as Programs 프로그램도 데이터처럼

6 => factorial => 720
The factorial program, viewed as an abstract machine.
6 => evaluator => 720
evaluator as a very special machine

evaluator is seen to be a universal machine.
  - A Universal Turing machine, often just called a universal machine, is an abstract computational device that can simulate other computational devices.
  - UTM https://en.wikipedia.org/wiki/Universal_Turing_machine


단순하고 자명한 것에서 복잡한것이 나오게 된다.

GEB( `G`ödel, `E`scher, `B`ach: an Eternal Golden Braid )
괴델, 에셔, 바흐: 영원한 황금 노끈
https://de.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach

recursion theory ( Computability theory ) "무엇이 계산 가능하고, 무엇이 절대 계산 불가능한가?"
https://en.wikipedia.org/wiki/Computability_theory

연습 4.15 ** Halting Problem

4.1.6 안쪽 정의(internal definition)

c언어의 전방선언과 비슷한 느낌.

선언과 할당을 동시에 할때 생기는 문제
let을 써서(frame 을 하나 더 써서) 풀어보고
선언 먼저 `'*unassigned*`로 공간을 만들어주고 그 다음 할당.

연습문제 4.17 - frame을 쓰지 않고 풀어보고

연습문제 4.19 ** Sequential Scope Simultaneous Scope lazy evaluation
연습문제 4.21 ** Z combinator - lambda calculus

4.1.7 문법 분석과 실행 과정을 떼어놓기


- eval시 analyze과정을 넣어 최적화


---

4.2 Scheme 바꿔보기 - 제때 계산법

lazy evaluation <=> eager evaluation

(define (try a b)
  (if (= a 0)
    1
    b))

(try 0 (/ 1 0))
;=> 1                   // lazy  evaluation
;!> /: division by zero // eager evaluation 



4.2.1 식의 값을 구하는 차례 - 정의대로 계산법과 인자 먼저 계산법
4.2.2 제때 계산법을 따르는 실행기
4.2.3 제때셈 리스트와 스트림

---

4.3 Scheme 바꿔보기 - 비결정적 계산
4.3.1 amb와 찾기
4.3.2 비결정적 프로그램 짜기
4.3.3 amb 실행기 구현

---

4.4 논리로 프로그램 짜기
4.4.1 연역식 정보 찾기
4.4.2 쿼리 시스템의 동작 방식
4.4.3 논리 프로그래밍은 수학 논리를 따르는가?
4.4.4 쿼리 시스템 만들기
4.4.4.1 드라이버 루프와 쿼리 값 찍어내기(instantiation)
4.4.4.2 실행기(evaluator)
4.4.4.3 패턴 매칭으로 참말 찾아내기
4.4.4.4 규칙과 동일화
4.4.4.5 데이터베이스의 관리
4.4.4.6 스트림 연산
4.4.4.7 쿼리의 문법을 처리하는 프로시저
4.4.4.8 일람표와 정의


4.01 cons left right
4.02 application? 위치
4.03 data-directed style
4.04 and? or? 추가
