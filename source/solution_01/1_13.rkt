#lang sicp
;; file: 1_13.rkt

(#%require (prefix racket: racket))
(#%require threading)
(#%require rackunit)

;; ==============================================================
;; - 특성방정식(Characteristic equation)
;;   - https://en.wikipedia.org/wiki/Characteristic_equation_(calculus)
;;   - 선형 점화식의 일반해를 구하기 위해 도입하는 보조적인 다항방정식
;;     - 즉, 쉽게 구할 수 있는걸로 바꿔 계산하자임.
;;   - 제약조건
;;     - 선형(linear)
;;       - 곱하기, 더하기만 있음.(항들 사이에 곱하거나 제곱하지 않음)
;;       - 안되는 경우: F(n)=F(n−1)*F(n−2) (항 들 사이에 곱했음)
;;     - 상수 계수(with constant coefficients)
;;       - 계수들이 모두 상수여야 함 (즉, n에 따라 변하면 안 됨)
;;       - 안되는 경우: F(n)=n*F(n−1)+F(n−2) (n에 따라 변함)
;;     - 동차(homogeneous)
;;       - 오른쪽에 독립적인 항이 없음
;;       - 안되는 경우: F(n)=F(n−1)+F(n−2)+1 (오른쪽에 상수, n, 2^n, +5 같은 추가적인 항이 붙어 있으면 비동차)
;; - 근의 공식(quadratic equation)
;;   - https://en.wikipedia.org/wiki/Quadratic_equation
;; - (1+√5)/2
;;   - 황금비(golden ratio): https://en.wikipedia.org/wiki/Golden_ratio
;; - 비넷공식(binet formula)
;;   - https://en.wikipedia.org/wiki/Fibonacci_sequence#Binet's_formula
;; - 귀납법(induction)
;;   - https://en.wikipedia.org/wiki/Mathematical_induction
;;   - 歸納(돌아갈 귀, 들일 납)
;;   - 개별적인 사실들로부터 일반적인 결론을 이끌어내는  
;;   - 기저 사례(Base Case): 증명하고자 하는 명제가 특정 초기 값에 대해 참임을 보이는 단계
;;   - 귀납 단계(Induction Step): 특정 수 n에 대해 명제가 참이라고 가정하고 (귀납 가설), 이를 이용하여 n+1에 대해서도 명제가 참임을 증명.


;; ==============================================================
;; 1. Fib(n)이 (φ^n)/√5에 가까운 정수임을 증명해라. (φ = (1+√5)/2, ψ = (1−√5)/2)
;;
;; # 1.1: 일반적인 접근법
;;
;; ## Fib는 특성방정식을 만족함.(선형/상수계수/동차를 만족함)
;; F(n) = F(n−1) + F(n−2)
;;
;; Fib(n) = x^n 이라 바꿔 계산하면.
;; x^n           = x^(n-1)         + x^(n-2)
;; x^n / x^(n-2) = x^(n-1)/x^(n-2) + x^(n-2)/x^(n-2)
;;
;; x^2         = x + 1
;; x^2 - x - 1 = 0
;;
;; 근의 공식으로 풀면
;; x = (1+√5)/2 = φ
;; x = (1-√5)/2 = ψ
;;
;;
;; ## Binet공식: F(n)= (φ^n - ψ^n)/√5
;; 앞서구한 해 φ와 ψ로 F(n)을 나타내면
;; F(n)     = Aφ^n + Bψ^n
;; F(0) = 0 = A + B       | 즉, A = -B
;; F(1) = 1 = Aφ + Bψ
;;          = Aφ - Aψ
;;          = A(φ - ψ)
;;
;; A =  1/(φ - ψ)
;; B = -1/(φ - ψ)
;;
;; φ - ψ = (1+√5)/2 - (1-√5)/2
;;       = 2√5/2
;;       = √5
;;
;; A =  1/√5
;; B = -1/√5
;;
;; F(n) = Aφ^n     + Bψ^n
;;      = 1/√5*φ^n - 1/√5*ψ^n
;;      = (φ^n - ψ^n)/√5
;;
;;
;; # 1.2: G(n)을 도입한 다른 접근법
;;
;; φ + ψ = 1
;; φ - ψ = √5
;; φ * ψ = -1
;; 
;; F(n+2)            = (φ+ψ)*F(n+1) - (φ*ψ)*F(n)
;; F(n+2) - φ*F(n+1) = ψ*(F(n+1) - φ*F(n))
;;
;;
;; ## G(n) 정의
;;
;; G(n  ) = F(n+1) - φ*F(n)
;; G(n+1) = ψ*G(n)
;; G(0)   = F(1)   - φ*F(0)
;;        = 1      - φ*0
;;        = 1
;;        = ψ^0
;; G(1)   = ψ*G(0)
;;        = ψ^1
;; G(n)   = ψ^n
;;        = F(n+1) - φ*F(n)
;;
;; ## 역전개하여 F(n+1) 유도
;; F(n+1) - φ*F(n) = ψ^n
;;
;; F(n+1) = φ*F(n)                             + ψ^n
;;        = φ(φ*F(n-1)             + ψ^(n-1))  + ψ^n
;;        = φ^2*F(n-1)                         + ψ^n + φ*ψ^(n-1)
;;        = φ^3*F(n-2)                         + ψ^n + φ*ψ^(n-1) + φ*ψ^(n-2)
;;        = ...
;;        = φ^(n+1)*F(0)                       + sum(k=0~n, φ^(n-k)*ψ^k)
;;        = φ^(n+1)*0                          + sum(k=0~n, φ^(n-k)*ψ^k)
;;        = sum(k=0~n, φ^(n-k)*ψ^k)
;;        = φ^n * sum(k=0~n, (ψ/φ)^k)                                |  sum(k=0~n, r^k) = (1-r^(n+1)) / (1-r)
;;        = φ^n * (1-(ψ/φ)^(n+1))            / (1-(ψ/φ))
;;        = φ^n * (1-(ψ/φ)^(n+1)) * φ^(n+1)  / (1-(ψ/φ)) * φ^(n+1)
;;        = φ^n * (φ^(n+1) - ψ^(n+1))        / (φ^(n+1) - (ψ * φ^n))
;;        = (φ^(n+1) - ψ^(n+1)) / (φ - ψ)
;;        = (φ^(n+1) - ψ^(n+1)) / √5
;;
;; 따라서
;; F(n)   = (φ^n - ψ^n) / √5
;;
;;
;; ## 1.3: Fib(n)이 (φ^n)/√5에 가까운 정수임을 증명.
;;
;; ψ = (1-√5)/2
;;   = −0.6180339887...
;; |ψ^0|/√5 = 0.447....  | 1/2 보다 작음.
;; |ψ^1|/√5 = 0.276....
;; ...
;; |ψ^n|/√5 = 0.000....  | 0으로 수렴
;; |ψ^n|/√5 = 1/2보다 작고 0으로 수렴.
;;
;; F(n)  = (φ^n     -  ψ^n)/√5
;;       = (φ^n)/√5 - (ψ^n)/√5
;;      ~= (φ^n)/√5            | (ψ^n)/√5 은 0으로 수렴함으로.
;;      ~= (φ^n)/√5            | 따라서 F(n)은 (φ^n)/√5에 가까운 정수.
;;
;; 더 나가자면 |ψ^n|/√5 는 항상 1/2보다 작고 0으로 수렴하므로,
;; 오차는 round 함수의 오차 허용 한계인 0.5보다 항상 작다.
;; 따라서
;;
;; F(n) = round((φ^n)/√5)
;;

;; ==============================================================
;; 2. Fib의 정의로 Fib(n) = (φ^n – ψ^n)/√5 임을 induction으로 밝혀라
;;
;; ## 기저 사례(Base case)
;;
;; n = 0 일때 성립
;; (φ^0 – ψ^0)/√5 = (1 - 1)/√5
;;                = 0
;;
;; n = 1 일때 성립
;; (φ^1 – ψ^1)/√5 = (φ – ψ)/√5
;;                = ((1+√5)/2) - (1-√5)/2) /√5
;;                = (√5/2 + √5/2)/√5
;;                = 1
;;
;; ## 귀납단계(Induction Step)
;;
;; Fib(n  ) = (φ^(n-0) – ψ^(n-0))/√5
;; Fib(n-1) = (φ^(n-1) – ψ^(n-1))/√5
;; Fib(n+1) = Fib(n)         + Fib(n-1)
;;          = (φ^n – ψ^n)/√5 + (φ^(n-1) – ψ^(n-1))/√5
;;          = (φ^n + φ^(n-1)) – (ψ^n + ψ^(n-1)) /√5
;;
;; φ   =  (1+√5)/2
;; φ^2 =  (1 + 2√5 + 5)/4
;;     =  (6 + 2√5)/4
;;     = 2(3 + √5)/4
;;     =  (3 + √5)/2
;;     = (1+√5)/2 + 1
;;     = φ + 1
;;
;; (φ^n + φ^(n-1)) = φ^(n-1) * (φ + 1)
;;                 = φ^(n-1) * φ^2
;;                 = φ^(n+1)
;; (ψ^n + ψ^(n-1)) = ψ^(n+1)
;;
;; 따라서 Fib(n+1) = (φ^(n+1) - ψ^(n+1)) /√5
;;
;; ## 결론.
;; 기저 사례와 귀납 단계를 통해 Fib(n) = (φ^n – ψ^n)/√5 이다.





(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

(define (fib-binet n)
  (let* ((root-5 (sqrt 5))
         (φ (/ (+ 1 root-5) 2))
         (ψ (/ (- 1 root-5) 2)))
    (~> (- (expt φ n) (expt ψ n))
        (/ root-5)
        (round-half-up))))

(define (round-half-up x)
  ;; racket:exact-floor는 IEEE-754 방식(일명 "round half to even" 또는 bankers' rounding)을 사용
  ;; Round half up은 0.5이상 일때 무조건 올림.
  (cond ((zero? x) 0)
        ((positive? x) (racket:exact-floor (+ x 0.5)))
        (else          (racket:exact-floor (- x 0.5)))))

(racket:for ([x (racket:in-inclusive-range 1 75)])
            ;; 부동소수점 정밀도의 한계로 에러가 발생.
            (check-eq? (fib x) (fib-binet x) (racket:~a x)))
