<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>연습문제 풀이 04 - SICP 여정</title>


        <!-- Custom HTML head -->

        <meta name="description" content="SICP 여정">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP 여정</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/netpyoung/sicp-journey" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/netpyoung/sicp-journey/edit/main/src/solution/solution_ch04.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="연습문제-풀이-04"><a class="header" href="#연습문제-풀이-04">연습문제 풀이 04</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_04">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_04</a></li>
</ul>
<h2 id="4_01"><a class="header" href="#4_01">4_01</a></h2>
<pre><code class="language-lisp">;; file: 4_01.rkt

;; 여기서의 cons는 left평가후 right를 평가한다.
(cons
 (begin (display "1") (newline) 1)
 (begin (display "2") (newline) 2))
;;&gt;&gt; 1
;;&gt;&gt; 2
;;=&gt; (1 . 2)

;; cons의 구현과 상관없이, 순서를 강제하려면 cons에서 left/right를 계산하는게 아닌,
;; 미리 left/right를 계산해버리면 된다.
(let* ((left  (begin (display "1") (newline) 1))
       (right (begin (display "2") (newline) 2)))
  (cons left right))
;;&gt;&gt; 1
;;&gt;&gt; 2
;;=&gt; (1 . 2)

(let* ((right (begin (display "2") (newline) 2))
       (left  (begin (display "1") (newline) 1)))
  (cons left right))
;;&gt;&gt; 2
;;&gt;&gt; 1
;;=&gt; (1 . 2)

;; list-of-values 를 다시 작성하면
;; before
#;(define (list-of-values exps env)
    (if (no-operands? exps)
        '()
        (cons (eval (first-operand exps) env)
              (list-of-values (rest-operand exps) env))))

;; after
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operand exps) env)))
        (cons left right))))
</code></pre>
<h2 id="4_02"><a class="header" href="#4_02">4_02</a></h2>
<pre><code class="language-lisp">;; file: 4_02.rkt

;; a) eval의 cond절에서
;;    assignment 혹은 definition보다
;;        ((assignment? exp) (eval-assignment exp env))
;;        ((definition? exp) (eval-definition exp env))
;;    application을
;;        ((application? exp) (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;    먼저 배치한다는 계획에서 잘못된 점은무엇인가?
;;   - (귀띔 : 저 생각대로 (define x 3) 식을 처리하면 어떻게 될까?)
;;
;;  이런식으로 함수 호출이 먼저 된다면?
;;
;;(define (eval exp env)
;;  (cond (
;;        ...
;;        ((variable? exp) ; symbol? 이면
;;         (lookup-variable-value exp env))
;;        ...
;;        ((application? exp) ; pair? 이면 함수 호출
;;         (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;        ...
;;        ((assignment? exp) ; set! 으로 시작
;;         (eval-assignment exp env))
;;       ((definition? exp) ; define 으로 시작
;;         (eval-definition exp env))
;;        ...
;;    )))
;;
;; - 간단히
;    - '(define x 3)가 pair?를 만족함으로 application(함수 콜)을 처리하는 로직에 떨어지게 됨.
;;   - 당연히 'define이라는 함수가 정의가 되지 않았으므로 에러 발생 예상.
;; - 자세히.
;;   - ((application? '(define x 3)) ; pair? 이면 함수 호출
;;   - (apply (eval 'define env) (list-of-values '(x 3) env)) 를 수행하게 되는데
;;     - (eval 'define env) 에서 'define은 심볼이므로
;;     - ((variable? 'define) (lookup-variable-value 'define env)) 로 떨어지게 됨
;;       - lookup-variable-value은 아직 구현이 나와있지 않으나 'define이 env에 정의되지 않았을 거임 그래서 에러가 발생할꺼.(에러가 발생안한다면 잘못된 구현)


;; b)언어 문법을 바꾸어서 프로시저 적용 식이 언제나 call로 시작되게 하자.
;;   - 보기를 들어， (factorial 3)은 (call factorial 3)으로， (+ 1 2)는 (call + 1 2)로 된다.
;;
;; eval함수에서 함수를 처리하는 부분은
;; ((application? exp) ; pair? 이면 함수 호출
;;   (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;
;; exp가 (factorial 3) 에서 (call factorial 3) 식으로 바뀌었으므로
;; application? /  operator / operands 부분을 고쳐야함.


;; 단순 pair?로 체크하는걸 'call로 시작하는 리스트를 확인하는걸로 바꾸고
;;(define (application? exp)
;;  (pair? exp))
(define (application? exp)
  (tagged-list? exp 'call))

;; rest로 첫번째 아이템('call)은 건너띄면 됨.
;;(define (operator exp)
;;  (first exp))
;;(define (operands exp)
;;  (rest exp))
(define (operator exp)
  (first (rest exp)))
 (define (operands exp)
  (rest (rest exp)))
</code></pre>
<h2 id="4_03"><a class="header" href="#4_03">4_03</a></h2>
<p>Exercise 2.73</p>
<pre><code class="language-lisp">;; file: 4_03.rkt

(#%require "../allcode/ch4-4.1.1-mceval.rkt")
(#%require "../allcode/ch3-3.3.3.rkt")
(#%require rackunit)

;; eval을 data-directed style 로 고쳐라
;; 그 후 Exercise 2.73 와 비교해보자
;;
;; 챕터 2.4.3에 data-directed style이 나온다.
;;
;; == basic style
;; (define (deriv exp var)
;;   (cond ((number? exp) ...)
;;         ((variable? exp)  ...)
;;         ((sum? exp) ...)
;;         ((product? exp) ...)
;;         (else  ...)
;;   ))
;; == data-directed style
;; (define (deriv exp var)
;;    (cond ((number? exp) ...)
;;          ((variable? exp)  ...)
;;          (else
;;            ((get 'deriv (operator exp)) (operands exp) var))
;;     ))
;;

;; eval에서 ***로 마크한 조건들이 data-directed style로 바뀌기 좋은 형태이다.
;;
;; (define (eval exp env)
;;   (cond ((self-evaluating? exp) ; 숫자? / 문자열?
;;         ((variable? exp)        ; symbol? 이면
;;     *** ((quoted? exp)          ; quote 로 시작
;;     *** ((assignment? exp)      ; set! 으로 시작
;;     *** ((definition? exp)      ; define 으로 시작
;;     *** ((if? exp)              ; if 로 시작
;;     *** ((lambda? exp)          ; lambda 로 시작
;;     *** ((begin? exp)           ; begin 으로 시작
;;     *** ((cond? exp)            ; cond 로 시작
;;         ((application? exp)     ; pair? 이면 함수 호출
;;         (else
;;   ))
;;
;;
;; (define (eval exp env)
;;   (cond ((self-evaluating? exp) ; 숫자? / 문자열?
;;         ((variable? exp)        ; symbol? 이면
;;     *** ((started-with-builtin-tag? exp)
;;     ***  ((get-tagged-func exp) exp env))
;;         ((application? exp)     ; pair? 이면 함수 호출
;;         (else
;;   ))
;;
;; 그리고 각 함수들에 대해 (tagged-func-name&gt; exp env) 이런 식으로 정규화를 시켜줘야 한다.

(define first car)
(define rest cdr)

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((started-with-builtin-tag? exp)
         ((get-tagged-func exp) exp env))   
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (started-with-builtin-tag? exp)
  (if (not (pair? exp))
      false
      (not (null? (get-tagged-func exp)))))

(define (get-tagged-func exp)
  (let ((tag (first exp)))
    (get tag 'built-in)))

(define (tagged-func-quote  exp env) (text-of-quotation exp))
(define (tagged-func-assign exp env) (eval-assignment exp env))
(define (tagged-func-define exp env) (eval-definition exp env))
(define (tagged-func-if     exp env) (eval-if exp env))
(define (tagged-func-lambda exp env) (make-procedure (lambda-parameters exp) (lambda-body exp) env))
(define (tagged-func-begin  exp env) (eval-sequence (begin-actions exp) env))
(define (tagged-func-cond   exp env) (eval (cond-&gt;if exp) env))

(put 'quote  'built-in tagged-func-quote)
(put 'assign 'built-in tagged-func-assign)
(put 'define 'built-in tagged-func-define)
(put 'if     'built-in tagged-func-if)
(put 'lambda 'built-in tagged-func-lambda)
(put 'begin  'built-in tagged-func-begin)
(put 'cond   'built-in tagged-func-cond)
</code></pre>
<h2 id="4_04"><a class="header" href="#4_04">4_04</a></h2>
<pre><code class="language-lisp">;; file: 4_04.rkt

(#%require (prefix racket/ racket))
(#%require "../allcode/ch4-4.1.1-mceval.rkt")
(#%require rackunit)

;; Install and and or as new special forms
;;
(define first car)
(define rest cdr)

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))

        ;; 여기에 and/or 를 넣어주자.
        ((and? exp) (builtin-and exp env))
        ((or?  exp) (builtin-or  exp env))
        
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define (and? exp) (tagged-list? exp 'and))
(define (or?  exp) (tagged-list? exp 'or))

(define (builtin-and exp env)
  (define (iter env fst rst)
    (if (false? (lookup-variable-value fst env))
        false
        (if (null? rst)
            true
            (iter env (first rst) (rest rst)))))
  (let ((args (rest exp))) ; '(and 1 2 3) =&gt; '(1 2 3)
    (iter env (first args) (rest args))))

(define (builtin-or  exp env)
  (define (iter env fst rst)
    (if (true? (lookup-variable-value fst env))
        true
        (if (null? rst)
            false
            (iter env (first rst) (rest rst)))))
  (let ((args (rest exp))) ; '(or 1 2 3) =&gt; '(1 2 3)
    (iter env (first args) (rest args))))


(check-eq? (eval '(and true true true) (setup-environment)) true)
(check-eq? (eval '(and false true true) (setup-environment)) false)
(check-eq? (eval '(and true false true) (setup-environment)) false)
(check-eq? (eval '(and true true false) (setup-environment)) false)

(check-eq? (eval '(or false false false) (setup-environment)) false)
(check-eq? (eval '(or true false false) (setup-environment)) true)
(check-eq? (eval '(or false true false) (setup-environment)) true)
(check-eq? (eval '(or false false true) (setup-environment)) true)

(define env1 (setup-environment))
(define-variable! 'a true env1)
(check-eq? (eval '(or false false a) env1) true)

;; Derived expressions.
;; 4.1.2Representing Expressions
;;  - Derived expressions
;; (cond ((&gt; x 0) x)
;;       ((= x 0) (display 'zero) 0)
;;       (else (- x)))
;;
;; (if (&gt; x 0)
;;     x
;;     (if (= x 0)
;;         (begin (display 'zero) 0)
;;         (- x)))
;;
;; - cond는 if로 변환하여 계산됨
;;   -cond는 if로부터 파생된(derived) 표현식임)
;;
;; and / or 역시 if 로 변환하여 계산할 수 있음.


(define (expand-and clauses)
  (if (null? clauses)
      'true
      (let ((fst (car clauses))
            (rst (cdr clauses)))
        (make-if fst
                 (expand-and rst)
                 'false))))

(define (expand-or clauses)
  (if (null? clauses)
      'false
      (let ((fst (car clauses))
            (rst (cdr clauses)))
        (make-if fst
                 'true
                 (expand-or rst)))))

(define (builtin-and-derived exp env) (eval (expand-and (rest exp)) env))
(define (builtin-or-derived  exp env) (eval (expand-or  (rest exp)) env))

(set! builtin-and builtin-and-derived)
(set! builtin-or  builtin-or-derived)

(check-equal? (expand-and '(1 2 3)) '(if 1 (if 2 (if 3 true false) false) false))
(check-equal? (expand-or  '(1 2 3)) '(if 1 true (if 2 true (if 3 true false))))

(check-eq? (eval '(and true true true) (setup-environment)) true)
(check-eq? (eval '(and false true true) (setup-environment)) false)
(check-eq? (eval '(and true false true) (setup-environment)) false)
(check-eq? (eval '(and true true false) (setup-environment)) false)

(check-eq? (eval '(or false false false) (setup-environment)) false)
(check-eq? (eval '(or true false false) (setup-environment)) true)
(check-eq? (eval '(or false true false) (setup-environment)) true)
(check-eq? (eval '(or false false true) (setup-environment)) true)

(define env2 (setup-environment))
(define-variable! 'a true env2)
(check-eq? (eval '(or false false a) env2) true)
</code></pre>
<h2 id="4_05"><a class="header" href="#4_05">4_05</a></h2>
<pre><code class="language-lisp">;; file: 4_05.rkt

(#%require (prefix racket/ racket))
(#%require "../allcode/ch4-4.1.1-mceval.rkt")
(#%require rackunit)

;; expand-clauses의 (sequence-&gt;exp (cond-actions first)) 부분을 수정하면 된다.

(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)

(define (cond-&gt;if exp)
  (expand-clauses (cond-clauses exp)))
 
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence-&gt;exp (cond-actions first))
                (error "ELSE clause isn't last -- COND-&gt;IF"
                       clauses))
            ;; Before:
            ;; (make-if (cond-predicate first)
            ;;             (sequence-&gt;exp (cond-actions first))
            ;;             (expand-clauses rest))
            ;; After:
            (if (=&gt;sequence? first)
                (make-if (cond-predicate first)
                         (expend=&gt;sequence first)
                         (expand-clauses rest))
                (make-if (cond-predicate first)
                         (sequence-&gt;exp (cond-actions first))
                         (expand-clauses rest)))))))


(define (=&gt;sequence? clause)
  (eq? (second clause) '=&gt;))

(define (expend=&gt;sequence clause)
  (list (third clause) (first clause)))

(check-equal? (expend=&gt;sequence '((assoc 'b '((a 1) (b 2))) =&gt; cadr))
              '(cadr (assoc 'b '((a 1) (b 2)))))

(check-equal? (cond-&gt;if '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                               (else false)))
              '(if (assoc 'b '((a 1) (b 2)))
                   (cadr (assoc 'b '((a 1) (b 2))))
                   false))



;;==== additional test
(check-equal? (cond-&gt;if '(cond ((= 1 1) true)
                               (else false)))
              '(if (= 1 1)
                   true
                   false))

(check-equal? (cond-&gt;if '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                               ((assoc 'b '((a 1) (b 2))) =&gt; cadr)))
              '(if (assoc 'b '((a 1) (b 2)))
                   (cadr (assoc 'b '((a 1) (b 2))))
                   (if (assoc 'b '((a 1) (b 2)))
                       (cadr (assoc 'b '((a 1) (b 2))))
                       false)))



;; eval test -----------------------

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! 'assoc (list 'primitive assoc) env2)
(define-variable! 'cadr (list 'primitive cadr) env2)

(check-equal? (eval '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                           (else false)) env2)
              2)
</code></pre>
<h2 id="4_06"><a class="header" href="#4_06">4_06</a></h2>
<pre><code class="language-lisp">;; file: 4_06.rkt
;; 4_07 / 4_08 / 4_09 / 4_16 / 4_17 / 4_18


(#%require (prefix racket/ racket))
(#%require rackunit)
(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))

(racket/provide
 let?
 let-&gt;combination)

(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)

;; let-&gt;combination 구현 ------------------------------
;; 중첩 let을 생각안하면 4_07에서 오류를 맞이할거임.

(define (let-&gt;combination let-clause)
  (let* ((bindings (second let-clause))
         (vars (map first bindings))
         (exps (map second bindings))
         (body (rest (rest let-clause))))
    (cons (make-lambda vars body)
          exps)))

(check-equal? (let-&gt;combination '(let ((a 1) (b 2)) (+ a b)))
              '((lambda (a b) (+ a b)) 1 2))

(check-equal? (let-&gt;combination '(let () 1))
              '((lambda () 1))
              "empty")


;; eval이 let구문을 처리할 수 있도록 수정 ---------------

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)
(define (let? exp) (tagged-list? exp 'let))


;; test -----------------------

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(check-equal? (eval '(let ((a 1) (b 2)) (+ a b)) env2) 3)

(override-eval! origin/eval)
</code></pre>
<h2 id="4_07"><a class="header" href="#4_07">4_07</a></h2>
<pre><code class="language-lisp">;; file: 4_07.rkt
;; 4_06 cont

(#%require rackunit)
(#%require (prefix racket/ racket))
(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))
(racket/provide
 make-let
 let*?
 let*-&gt;nested-lets)

;; 1-1. let*식이 여러개의 let식으로 변환될 수 있는지.
;;
;;  (let* ((x 3)
;;         (y (+ x 2))
;;         (z (+ x y 5)))
;;    (* x z)))
;;
;; (let ((x 3))
;;   (let ((y (+ x 2)))
;;     (let ((z (+ x y 5)))
;;       (* x z)))))
;;
;; 1-2. let*-&gt;nested-lets 를 작성해라.

(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)

(define (make-let binding body)
  ;; (make-let '((a 1)) '(1 2 3))
  ;; =&gt; (let ((a 1)) 1 2 3)
  (if (null? binding)
      (append (list 'let '()) body)
      (append (list 'let binding) body)))


(check-equal? (make-let '((b 1))
                        (list (make-let '((a 1))
                                        '((display) (display)))))
              '(let ((b 1))
                 (let ((a 1))
                   (display)
                   (display))))

(check-equal? (make-let '((b 1)) '('a 'b))
              '(let ((b 1)) 'a 'b))


(define (let*-&gt;nested-lets expr)
  (define (iter acc bs)
    (if (null? bs)
        acc
        (iter (make-let (list (first bs)) (list acc)) (rest bs))))
  (let* ((bindings (reverse (second expr)))
         (body (rest (rest expr))))
    (if (null? bindings)
        (make-let '() body)
        (iter (make-let (list (first bindings)) body) (rest bindings)))))

(define (let*? expr)
  (tagged-list? expr 'let*))

(check-equal? (let*-&gt;nested-lets
               '(let* ((x 3)
                       (y (+ x 2))
                       (z (+ x y 5)))
                  (* x z)))   
              '(let ((x 3))
                 (let ((y (+ x 2)))
                   (let ((z (+ x y 5)))
                     (* x z)))))

(check-equal? (let*-&gt;nested-lets
               '(let* () 1))
              '(let () 1))

(check-equal? (let*-&gt;nested-lets
               '(let* ((x 3)
                       (y x))
                  'a
                  'b))
              '(let ((x 3))
                 (let ((y x))
                   'a
                   'b)))

;; 2.1 eval에 (eval (let*-&gt;nested-lets exp) env)를 추가하면 동작할까?
;; 동작 한다.


(#%require "4_06.rkt")

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))

        ((let? exp) (eval (let-&gt;combination exp) env))   ; &lt;&lt;--- 저번 4_06에서 추가.
        ((let*? exp) (eval (let*-&gt;nested-lets exp) env)) ; &lt;&lt;--- 이번 4_07에서 추가.
        
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '* (list 'primitive *) env2)

(#%require (prefix  r5rs/ r5rs))
(define expression '(let* ((x 3)
                           (y (+ x 2))
                           (z (+ x y 5)))
                      (* x z)))

(#%require (prefix trace/ racket/trace))

(check-equal? (eval expression env2)
              (r5rs/eval expression (scheme-report-environment 5)))

(override-eval! origin/eval)
</code></pre>
<h2 id="4_08"><a class="header" href="#4_08">4_08</a></h2>
<pre><code class="language-lisp">
#;(#%require errortrace)
;; file: 4_08.rkt
;; 4_06 cont


;; 기존 let-&gt;combination
;; 
;; (let ((a 1) (b 2)) (+ a b)) =&gt; ((lambda (a b) (+ a b)) 1 2)
;;
;; (let &lt;var&gt; &lt;bindings&gt; &lt;body&gt;) 형태를 지원할 수 있도록 수정하해야함.
;;
;; 간단한 named-let expression이 다음과 같다고 하면,
;;
;; (let hello ((a 1) (b 2))
;;   (+ a b))
;;
;; a) lambda와 define사용.
;; ((lambda ()
;;    (define (hello a b)
;;      (+ a b))
;;    (hello 1 2)))
;;
(#%require (prefix racket/ racket))
(#%require (rename "4_06.rkt" let-&gt;combination-normal let-&gt;combination))
(#%require rackunit)
(racket/provide
 make-define
 let-&gt;combination)
(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)

(define (make-define func-name args body)
  (append (list 'define (append (list func-name) args)) body))

(check-equal? (make-define 'hello '(a b) '(1 2 3 4 5))
              '(define (hello a b) 1 2 3 4 5))

(define (let-named-&gt;combination let-clause)
  (let* ((bindings (third let-clause))
         (func-name (second let-clause))
         (vars (map first bindings))
         (exps (map second bindings))
         (body (rest (rest (rest let-clause)))))
    (list (make-lambda '()
                       (list (make-define func-name vars body)
                             (append (list func-name) exps))))))
    

(define (let-&gt;combination let-clause)
  (if (symbol? (second let-clause))
      (let-named-&gt;combination let-clause)      
      (let-&gt;combination-normal let-clause)))


(check-equal? (let-&gt;combination '(let ((a 1) (b 2)) (+ a b)))
              '((lambda (a b) (+ a b)) 1 2))

(check-equal? (let-&gt;combination '(let hello ((a 1) (b 2))
                                   (+ a b)))
              '((lambda ()
                  (define (hello a b)
                    (+ a b))
                  (hello 1 2))))

;; eval이 let구문을 처리할 수 있도록 수정 ---------------
(#%require "../allcode/ch4-4.1.1-mceval.rkt")

(define (let? exp) (tagged-list? exp 'let))
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '= (list 'primitive =) env2)

(check-equal? (eval '(let hello ((a 1) (b 2))
                       (+ a b))
                    env2)
              3)

(check-equal? (eval '(define (fib n)
                       (let fib-iter ((a 1)
                                      (b 0)
                                      (count n))
                         (if (= count 0)
                             b
                             (fib-iter (+ a b) 
                                       a 
                                       (- count 1)))))
                    env2)
              'ok)
(check-equal? (eval '(fib 10) env2) 55)
</code></pre>
<h2 id="4_09"><a class="header" href="#4_09">4_09</a></h2>
<pre><code class="language-lisp">;; file: 4_09.rkt
;; 4_06 4_07 cont

;;  do / for / while / until 를 derived expression으로 구현해라
;; ref:
;; guile - do - https://www.gnu.org/software/guile/manual/html_node/while-do.html
;; common lisp - do - https://www.lispworks.com/documentation/HyperSpec/Body/m_do_do.htm
;; ruby - do for while until - https://www.geeksforgeeks.org/ruby/ruby-loops-for-while-do-while-until/

;; Derived expressions.
;; 4.1.2Representing Expressions
;;  - Derived expressions
;; (cond ((&gt; x 0) x)
;;       ((= x 0) (display 'zero) 0)
;;       (else (- x)))
;;
;; (if (&gt; x 0)
;;     x
;;     (if (= x 0)
;;         (begin (display 'zero) 0)
;;         (- x)))
;;
;; - cond는 if로 변환하여 계산됨
;;   -cond는 if로부터 파생된(derived) 표현식임)

(#%require (prefix racket/ racket))
(#%require (prefix  r5rs/ r5rs))
(#%require rackunit)
(#%require threading)
(racket/provide
 do?
 while?
 until?
 do-&gt;expand
 while-&gt;do
 until-&gt;do)

(define first car)
(define rest cdr)
(define second cadr)
(define third caddr)

(define (second-or-nil expr)
  (let ((x  (rest expr)))
    (if (null? x)
        nil
        (first x))))
(define (third-or-nil expr)
  (let ((x (rest (rest expr))))
    (if (null? x)
        nil
        (first x))))

(define (make-define func-name args body)
  (append (list 'define (append (list func-name) args)) body))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (comp f g h)
  (lambda (x)
    (h (f (g x)))))

(define (make-do vars assigns step-or-nils test ret body)
  (list 'let* (map list vars assigns)
        (make-define 'loop '()
                     (list (list 'if test
                                 ret
                                 (append (list 'begin)
                                         body
                                         (~&gt;&gt; (map (lambda (v x) (if (null? x) nil (list 'set! v x))) vars step-or-nils)
                                              (filter (comp not null? identity) ))
                                         '((loop))))))
        '(loop)))

(define (do-&gt;expand expr)
  (let* ((snd (second expr))
         (trd (third expr))
         (vars (map first snd))
         (assigns (map second snd))
         (step-or-nils (map third-or-nil snd))
         (test (first trd))
         (ret (second-or-nil trd))
         (body (rest (rest (rest expr)))))
    (make-do vars assigns step-or-nils test ret body)))

(check-equal? (do ((i 10 (dec i))
                   (j '()))
                ((&lt; i 0) j)
                (set! j (cons i j)))
              '(0 1 2 3 4 5 6 7 8 9 10))

(check-equal? (do-&gt;expand '(do ((i 10 (dec i))
                                (j '()))
                             ((&lt; i 0) j)
                             (set! j (cons i j))))
              
              '(let* ((i 10)
                      (j '()))
                 (define (loop)
                   (if (&lt; i 0)
                       j
                       (begin
                         (set! j (cons i j))
                         (set! i (dec i))
                         (loop))))
                 (loop)))



(define (while-&gt;do expr)
  (let ((vars '())
        (assigns '())
        (step-or-nils '())
        (test (second expr))
        (ret (quote '()))
        (body (rest (rest expr))))
    (make-do vars assigns step-or-nils (list 'not test) ret body)))

(check-equal? (while-&gt;do '(while (&gt; i 0)
                                 (set! i (dec i))))
              '(let* ()
                 (define (loop)
                   (if (not (&gt; i 0))
                       '()
                       (begin
                         (set! i (dec i))
                         (loop))))
                 (loop)))

(define (until-&gt;do expr)
  (let ((vars '())
        (assigns '())
        (step-or-nils '())
        (test (second expr))
        (ret (quote '()))
        (body (rest (rest expr))))
    (make-do vars assigns step-or-nils test ret body)))

(check-equal? (until-&gt;do '(until (&gt; i 5)
                                 (set! i (inc i))))
              '(let* ()
                 (define (loop)
                   (if (&gt; i 5)
                       '()
                       (begin
                         (set! i (inc i))
                         (loop))))
                 (loop)))

;; eval이 let구문을 처리할 수 있도록 수정 ---------------
(#%require (all-except "../allcode/ch4-4.1.1-mceval.rkt" eval))
(#%require "4_06.rkt")
(#%require "4_07.rkt")

(define (do? exp) (tagged-list? exp 'do))
(define (while? exp) (tagged-list? exp 'while))
(define (until? exp) (tagged-list? exp 'until))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env))   ; &lt;&lt;--- 저번 4_06에서 추가.
        ((let*? exp) (eval (let*-&gt;nested-lets exp) env)) ; &lt;&lt;--- 저번 4_07에서 추가.
        ((do? exp) (eval (do-&gt;expand exp) env)) ;; &lt;&lt;--- 추가.
        ((while? exp) (eval (while-&gt;do exp) env))
        ((until? exp) (eval (until-&gt;do exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '= (list 'primitive =) env2)
(define-variable! '&lt; (list 'primitive &lt;) env2)
(define-variable! '&gt; (list 'primitive &gt;) env2)
(define-variable! 'inc (list 'primitive inc) env2)
(define-variable! 'dec (list 'primitive dec) env2)
(define-variable! 'not (list 'primitive not) env2)


(check-equal? (eval '(do ((i 10 (dec i))
                          (j '()))
                       ((&lt; i 0) j)
                       (set! j (cons i j)))
                    env2)
              '(0 1 2 3 4 5 6 7 8 9 10))

(check-equal? (eval '(let ((acc '())
                           (i 5))
                       (while (&gt; i 0)
                              (set! acc (cons i acc))
                              (set! i (dec i)))
                       acc)
                    env2)
              '(1 2 3 4 5))

(check-equal? (eval '(let ((acc '())
                           (i 1))
                       (until (&gt; i 5)
                              (set! acc (cons i acc))
                              (set! i (inc i)))
                       acc)
                    env2)
              '(5 4 3 2 1))
</code></pre>
<h2 id="4_10"><a class="header" href="#4_10">4_10</a></h2>
<pre><code class="language-lisp">;; file: 4_10.rkt

(#%require rackunit)
;; 기존 eval과 apply 코드는 그대로 두고 Scheme의 새로운 문법(syntax) 을 설계하고 구현하라.
;; define의 문법을 clojure 처럼 def / defn으로 변경.
;; -- scheme
;; (define x 10)
;; (define (foo a b c)
;;   (* a b c))
;;
;; -- clojure
;; (def x 10)
;; (defn foo [a b c]
;;   (* a b c))

(define rest cdr)
(define second cadr)
(define third caddr)

(define (definition? exp)
  (or 
   (tagged-list? exp 'def)
   (tagged-list? exp 'defn)))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(check-equal? (definition-variable '(define (foo a b c)
                                      (* a b c)))
              'foo)

(define (definition-variable2 exp)
  (if (tagged-list? exp 'def)
      (second exp)
      (second exp)))

(check-equal? (definition-variable '(defn foo [a b c]
                                      (* a b c)))
              'foo)

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))

(check-equal? (definition-value '(define (foo a b c)
                                   (* a b c)))
              '(lambda (a b c) (* a b c)))

(define (definition-value2 exp)
  (if (tagged-list? exp 'def)
      (caddr exp)
      (make-lambda (third exp)
                   (rest (rest (rest exp))))))

(check-equal? (definition-value2 '(defn foo [a b c]
                                    (* a b c)))
              '(lambda (a b c) (* a b c)))

(define (eval-definition exp env)
  (define-variable! (definition-variable2 exp)
    (eval (definition-value2 exp) env)
    env)
  'ok)

;; racket모듈 특성상 동일한 코드를 다시 override할 필요가 있음.
(#%require (all-except "../allcode/ch4-4.1.1-mceval.rkt" eval))
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)



(define env2 (setup-environment))
(define-variable! '* (list 'primitive *) env2)
(check-equal? (eval '(defn foo [a b c]
                       (* a b c))
                    env2)
              'ok)
(check-equal? (eval '(foo 2 3 4) env2)
              24)

(check-equal? (eval '(def x 10) env2)
              'ok)

(check-equal? (eval 'x env2)
              10)
</code></pre>
<h2 id="4_11"><a class="header" href="#4_11">4_11</a></h2>
<pre><code class="language-lisp">;; file: 4_11.rkt

(#%require rackunit)
(#%require threading)

;; - 현재 frame형태
;;   - '((symbol-a symbol-b ...) value-a (primitive func-b) ...)
;; - 바꾸고자 하는 frame형태
;;   - '((symbol-a value-a) (symbol-b (primitive func-b)) ...)
;;
;; frame관련 함수들
;; - make-frame
;; - add-binding-to-frame!
;; - frame-variables
;; - frame-values

(#%require (prefix old/ "../allcode/ch4-4.1.1-mceval.rkt"))
(define frame1 (old/make-frame '(a b) '(1 2)))
(check-equal? frame1
              '((a b) 1 2))
(old/add-binding-to-frame! 'c 3 frame1)
(check-equal? frame1
              '((c a b) 3 1 2))
(check-equal? (~&gt; (old/make-frame '(a b) '(1 2))
                  (old/frame-variables))
              '(a b))

(check-equal? (~&gt; (old/make-frame '(a b) '(1 2))
                  (old/frame-values))
              '(1 2))

(define first car)
(define rest cdr)
(define second cadr)
(define (make-frame variables values)
  (map list variables values))

(define (add-binding-to-frame! var val frame)
  (let ((rst (rest frame))
        (var-val (list var val)))
    (set-cdr! frame (append rst (list var-val)))))

(define (frame-variables frame)
  (map first frame))
(define (frame-values frame)
  (map second frame))

(define frame2 (make-frame '(a b) '(1 2)))
(check-equal? frame2
              '((a 1) (b 2)))
(add-binding-to-frame! 'c 3 frame2)
(check-equal? frame2
              '((a 1) (b 2) (c 3)))
(check-equal? (~&gt; (make-frame '(a b) '(1 2))
                  (frame-variables))
              '(a b))
(check-equal? (~&gt; (make-frame '(a b) '(1 2))
                  (frame-values))
              '(1 2))
</code></pre>
<h2 id="4_12"><a class="header" href="#4_12">4_12</a></h2>
<pre><code class="language-lisp">;; file: 4_12.rkt
;; 4_13

;; 주어진 함수들의 공통된 점을 묶어 추상화하고, 그 추상화를 이용하여 다시 정의하라.
;;
;; - define-variable!
;; - set-variable-value!
;; - lookup-variable-value 
;;
;; 3함수 모두 env를 돌며, variable의 찾음 여부에 따라 다른 동작들을 수행한다.
;; 종료조건은 var를 찾거나, env(frame list)를 모두 순회한 경우이다.
;; (단 define-variable!인 경우 첫번째 frame만 검사함. env(frame list)를 전부 순회하지 않음.
;;
;; 기타. env 는 [frame1 frame2 ..] 이다.

(#%require rackunit)
(#%require threading)
(#%require (prefix racket/ racket))

(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (define-variable! origin/define-variable!)
                                  (set-variable-value! origin/set-variable-value!)
                                  (lookup-variable-value origin/lookup-variable-value)))
(racket/provide
 lookup-variable-values)
;; =======================================
(define first car)

(define (lookup-variable-values var env)
  ;; 함수 모양이 맘에 안들지만, 일단 기존 코드 모양의 수정을 최소화하겠다.
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             vals)   ; &lt;&lt;------------ 찾으면 vals를 반환한다.
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        nil          ; &lt;&lt;------------ 못찾으면 nil을 반환한다.
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))


(define (lookup-variable-value var env)
  (let ((vals (lookup-variable-values var env)))
    (if (null? vals)
        (error "Unbound variable" var)
        (first vals))))

(define (set-variable-value! var val env)
  (let ((vals (lookup-variable-values var env)))
    (if (null? vals)
        (error "Unbound variable -- SET!" var)
        (set-car! vals val))))

(define (define-variable! var val env)
  (let* ((frame (first-frame env))
         (toplevel-env (extend-environment (frame-variables frame) (frame-values frame) the-empty-environment))
         (vals (lookup-variable-values var toplevel-env)))
    (if (null? vals)
        (add-binding-to-frame! var val frame)
        (set-car! vals val))))

;; testing =======================================
(define env1 (setup-environment))
(check-equal? (lookup-variable-value 'car env1)
              (list 'primitive car))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-exn #rx"Unbound variable -- SET! x"
           (lambda () (set-variable-value! 'x 1 env1)))
(define-variable! 'x 5 env1)
(check-equal? (lookup-variable-value 'x env1)
              5)
(set-variable-value! 'x 1 env1)
(check-equal? (lookup-variable-value 'x env1)
              1)
</code></pre>
<h2 id="4_13"><a class="header" href="#4_13">4_13</a></h2>
<pre><code class="language-lisp">;; file: 4_13.rkt
;; 4_12

;; scheme에서 define해서 정의한 변수를 지울 수 없음.
;;
;; 1-1. make-unbound! 함수를 만들어 env에서 지울 수 있도록 만들자.
;;
;; 1-2. first-frame에서만 지우면 되는가?
;;
;; - 현재 스코프(첫 프레임)내에서 선언 삭제가 됨으로, 직관적.
;; - 첫 번째 프레임만 뒤지면 되니 탐색이 빠르고 코드가 단순함.
;; - 상위 프레임에 중복된 이름은 살아있음.
;;
;; 앞선 define-variable!도 현재 스코프(첫 프레임)에서만 선언하고 있음.
;;
;; 초판 1985년: SICP
;; 초판 1991년: EOPL Essentials of Programming Languages by Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes.
;; 초판 1996년: PLP Programming Language Pragmatics by Michael L Scott - https://www.cs.rochester.edu/~scott/pragmatics/
;; 초판 2002년: TaPL Types and Programming Languages by Benjamin C. Pierce - https://www.cis.upenn.edu/~bcpierce/tapl/index.html
;;  etc. https://softwarefoundations.cis.upenn.edu/


(#%require rackunit)
(#%require (prefix racket/ racket))
(racket/require "../allcode/ch4-4.1.1-mceval.rkt")

(define first car)
(define second cadr)
(define rest cdr)

(define (lookup-variable-vars-vals var env)
  ;; 함수 모양이 맘에 안들지만, 일단 기존 코드 모양의 수정을 최소화하겠다.
  ;; values도 있으나, 그냥 list로 감싸겠다. - https://docs.racket-lang.org/reference/values.html
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (list vars vals))   ; &lt;&lt;------------ 찾으면 (vars vals)를 반환한다.
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (list nil nil)          ; &lt;&lt;------------ 못찾으면 (nil nil)을 반환한다.
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (make-unbound! env var is-toplevel-only)
  (define (which-env env is-toplevel-only)
    (if (not is-toplevel-only)
        env
        (let* ((frame (first-frame env))
               (search-env (extend-environment (frame-variables frame) (frame-values frame) the-empty-environment)))
          search-env)))
  (let* ((frame (first-frame env))
         (search-env (which-env env is-toplevel-only))
         (vars-vals (lookup-variable-vars-vals var search-env))
         (vars (first vars-vals))
         (vals (second vars-vals)))
    (if (null? vals)
        nil
        (begin
          (let ((rst (rest vars)))
            (set-car! vars (first rst))
            (set-cdr! vars (rest rst)))
          (let ((rst (rest vals)))
            (set-car! vals (first rst))
            (set-cdr! vals (rest rst)))))))

#;(define env1 (setup-environment))

#;(let ((frame (first-frame env1)))
    frame)
;; testing =======================================
(define env1 (setup-environment))
(check-equal? (lookup-variable-value 'car env1)
              (list 'primitive car))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-exn #rx"Unbound variable -- SET! x"
           (lambda () (set-variable-value! 'x 1 env1)))
(define-variable! 'x 5 env1)
(check-equal? (lookup-variable-value 'x env1)
              5)
(set-variable-value! 'x 1 env1)
(check-equal? (lookup-variable-value 'x env1)
              1)
(make-unbound! env1 'x #t)
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))

(check-equal? env1 (setup-environment))
</code></pre>
<h2 id="4_14"><a class="header" href="#4_14">4_14</a></h2>
<pre><code class="language-lisp">;; file: 4_14.rkt

(#%require rackunit)
(#%require threading)
(#%require (prefix racket/ racket))
(#%require (prefix  r5rs/ r5rs))

(racket/require "../allcode/ch4-4.1.1-mceval.rkt")
;;
;; 1. Eva Lu Ator은 map의 정의를 직접 입력해서 평가하는 방식.
;; 2. Louis Reasoner는 map을 primitive-procedures에 넣어 버리는 방식.
;; Eva Lu Ator는 잘 동작하는데, Louis Reasoner는 동작하지 않는 이유는?
;;
;; env는
;; 1에서의 map은 (procedure (proc items) ((if (null? items) '() ...) 형태로 저장
;; 2에서의 map은 (primitive #&lt;procedure:mcar&gt;) 형태로 저장.
;; 작성한 eval&amp;apply과정에서 사용하는 데이터가 r5rs에서의 과정과 사용하는 데이터가 맞지않음.

;; 1. Eva Lu Ator (aka, Evaluator) 방식
;;

(define env1 (setup-environment))
(check-equal? (eval '(define (map proc items)
                       (if (null? items)
                           '()
                           (cons (proc (car items))
                                 (map proc (cdr items)))))
                    env1)
              'ok)
(check-equal? (eval '(map car '((a 1) (b 2) (c 3))) env1)
              '(a b c))

;; 2. Louis Reasoner (akka, loose reasoner)
;;
(define env2 (setup-environment))
(define-variable! 'map (list 'primitive map) env2) ; 아니면 primitive-procedures를 직접 수정.

(check-exn
 racket/exn:fail?
 (lambda ()
   ;; (r5rs/apply map (list (list 'primitive car) '((a 1) (b 2) (c 3)))) 와 같음.
   ;; application: not a procedure;
   ;;  expected a procedure that can be applied to arguments
   ;;   given: (primitive #&lt;procedure:mcar&gt;)
   (eval '(map car '((a 1) (b 2) (c 3))) env2)))

</code></pre>
<h2 id="4_15"><a class="header" href="#4_15">4_15</a></h2>
<pre><code class="language-lisp">;; file: 4_15.rkt

;;
;; 정지 문제:
;; - Halting Problem: https://en.wikipedia.org/wiki/Halting_problem
;; - SCOOPING THE LOOP SNOOPER -  http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html
;;

;; 가정:
;; 함수 p와 오브젝트 a가 있을시, (p a)를 호출하면 값을 반환하거나, 에러를 뱉거나, 끊임없이 동작한다고 가정하자.
;;
;; 문제:
;; 함수 p와 입력값 a에 대해, (p a)시 멈추는지 아닌지 판별하는 halts?라는 함수를 작성하는게 불가능 하다.
;; 이를 증명해보아라.
;;
;; 증명:
;; 귀류법: 해결방법이 있다라는 가정에서 모순이 발생한다는 것을 보임으로써 증명한다.
;;
;; 만일 halts?라는게 있다면 다음코드를 작성할 수 있을 것이며,
;; 
;; (define (run-forever)
;;   (run-forever))
;; 
;; (define (try p)
;;   (if (halts? p p)
;;       (run-forever)
;;       'halted))
;;
;; 그런 다음, (try try)를 호출하면 결과가 어떻든(값을 반환하거나, 에러를 뱉거나, 끊임없이 동작),
;; halts?의 정의에 어긋남을 밝히면 된다.
;;
;; (halts? p a)는 (p a)시 멈춘다면 true반환할 것이다.
;; (try try)
;;  =&gt; (halts? try try) - 만약 참이라면 (try try)시 멈춘다는 말이다. 하지만,
;;   =&gt; 조건문을 만족시키면서 (run-forever)로 돌면서 (try try)는 멈추지 않고 끊임없이 동작할 것이다.
;;  =&gt;(halts? try try) - 만약 것짓이라면, (try try)시 멈추지 않는다는 말이다. 하지만,
;;   =&gt; 조건문을 만족시키지 못하면서 'halted를 반환하면서 (try try)는 멈추게 된다.:
;; 이 모순된 상황은 halts?의 정의와는 맞지않다.
</code></pre>
<h2 id="4_16"><a class="header" href="#4_16">4_16</a></h2>
<pre><code class="language-lisp">;; file: 4_16.rkt
;; 4_06 / 4_18 cont

(#%require rackunit)

(#%require (prefix racket/ racket))
(#%require (prefix trace/ racket/trace))

(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_lookup-variable-value origin/lookup-variable-value)
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))
(racket/provide
 lookup-variable-value
 scan-out-defines)
;;
;; 1. lookup-variable-value 함수를 고쳐서 변수의 값이 심볼 *unassigned* 면 오류를 내도록 한다.
;;

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             ;; - before
             ;; (car vals)
             ;;
             ;; - after
             (let ((found (car vals)))
               (if (eq? found '*unassigned*)
                   (error "Unssigned variable" var)
                   found)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(override-lookup-variable-value! lookup-variable-value)


(define env1 (setup-environment))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-equal? (eval '(define x '*unassigned*) env1)
              'ok)
(check-exn #rx"Unssigned variable x"
           (lambda () (lookup-variable-value 'x env1)))

;;
;; 2. procedure body를 받아(lambda로 시작하는) 앞에 본것처럼 내부에 define이 없도록 변환과정을 거쳐 반환하는 scan-out-defines를 작성해라.
;;
;; - before
;; (lambda &lt;vars&gt;
;;  (define u &lt;e1&gt;)
;;  (define v &lt;e2&gt;)
;;  &lt;e3&gt;)
;;
;; - after
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (set! u &lt;e1&gt;)
;;    (set! v &lt;e2&gt;)
;;    &lt;e3&gt;)))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (complement f)
  (lambda (x)
    (not (f x))))

(define (make-let bindings body)
  ;; (make-let '((a 1)) '((+ a 2)))
  ;; =&gt; (let ((a 1)) (+ a 2))
  (append (list 'let bindings) body))

(define first car)
(define rest cdr)

(define (scan-out-defines body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((body-without-defs (filter (complement definition?) body))
               (vars (map definition-variable defs))
               (vals (map definition-value defs))
               (bindings (map (lambda (x) (list x ''*unassigned*)) vars))
               (assigns (map (lambda (x y) (list 'set! x y)) vars vals)))
          (list (make-let bindings
                          (append assigns body-without-defs)))))))


(check-equal? (scan-out-defines (lambda-body '(lambda (x)
                                                (define u 1)
                                                (define v 2)
                                                (+ u v x))))
              '((let ((u '*unassigned*)
                      (v '*unassigned*))
                  (set! u 1)
                  (set! v 2)
                  (+ u v x))))

;;
;; 3. scan-out-defines 을 인터프리터안에 넣는데,
;;    - make-procedure 쪽이 좋을까 procedure-body 쪽이 좋을까?
;;       make-procedure 쪽
;;    - 그리고 그 이유는?
;;       eval타임인가 apply타임인가 문제인데,
;;      인터프리터 구현체가 eval타임에서 구문을 확장하고 apply를 돌며 실제 scheme쪽 apply를 호출.
;;      eval타임에서 구문을 확장해 나갈때 같이 확장해 놓는게 좋다.

;; === make-procedure
;; (define (make-procedure parameters body env)
;;   (list 'procedure parameters body env))
;; 
;; (define (eval exp env)
;;   (cond (
;;          ...
;;          ((lambda? exp)
;;           (make-procedure (lambda-parameters exp) ; &lt;-----------------------
;;                           (lambda-body exp)
;;                           env))
;;          ...
;;          )))
;; 
;; === procedure-body
;; (define (procedure-body p) (caddr p)) ;; third
;; 
;; (define (apply procedure arguments)
;;    (cond ((primitive-procedure? procedure)
;;          (apply-primitive-procedure procedure arguments))
;;         ((compound-procedure? procedure)
;;          (eval-sequence
;;           (procedure-body procedure) ; &lt;-----------------------
;;           (extend-environment
;;            (procedure-parameters procedure)
;;            arguments
;;            (procedure-environment procedure))))
;;         (else
;;          (error
;;           "Unknown procedure type -- APPLY" procedure))))

;; 수정한다면,
(racket/require (racket/prefix-in ex4_06/ "4_06.rkt"))
(define third caddr)
(define env2 (setup-environment))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '+ (list 'primitive +) env3)

(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env2)
                          'ok)

            ;; hello body의 define이 lambda로 풀어진 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env2))
                          '(((lambda (u v)
                               (set! u 1)
                               (set! v 2)
                               (+ u v x))
                             '*unassigned*
                             '*unassigned*)))
            (check-equal? (eval '(hello 3) env2)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))

(around
 (begin
   (define (procedure-body p)
     (scan-out-defines (third p)))
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! procedure-body))
 
 (test-case "procedure-body"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env3)
                          'ok)

            ;; hello body의 define이 lambda로 풀어지지 않은 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env3))
                          '((define u 1)
                            (define v 2)
                            (+ u v x)))
            
            ;; application평가시에 scan-out-defines이 일어남
            (check-equal? (eval '(hello 3) env3)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))


(override-lookup-variable-value! origin/lookup-variable-value)
</code></pre>
<h2 id="4_17"><a class="header" href="#4_17">4_17</a></h2>
<pre><code class="language-lisp">;; file: 4_17.rkt
;; 4_06 cont

;; 본문에 나온 &lt;e3&gt;을 평가할때의 environment를 다이어그램으로 그려라
;;
;; 첫번째 방식
;; (lambda (x)
;;   (define u 1)    ; 실행 시, 현재 프레임에 u를 만들고 값 1 할당
;;   (define v 2)    ; 실행 시, 현재 프레임에 v를 만들고 값 2 할당
;;   (+ u v x))
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +------------------+
;;              | Frame F1         |   (procedure call frame)
;;              +------------------+
;;              | x = ARG          |
;;              | u = 1            |
;;              | v = 2            |
;;              +------------------+
;;                   |
;;       e3: (+ u v x)  ; lookup all in F1


;;
;; 두번째 방식(변환된 방식)
;; (lambda (x)
;;   (let ((u '*unassigned*)
;;         (v '*unassigned*))
;;     (set! u 1)
;;     (set! v 2)
;;     (+ u v x)))
;; 
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: let ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +----------------+
;;              | Frame F1       |   (procedure call frame)
;;              +----------------+
;;              | x = ARG        |
;;              +----------------+
;;                   |
;;                   v
;;              +------------------+
;;              | Frame F2         |   (let frame)
;;              +------------------+
;;              | u = *unassigned* |
;;              | v = *unassigned* |
;;              +------------------+
;;       set! u 1
;;       set! v 2
;;       e3: (+ u v x)  ; u,v in F2, x in F1
;;

;;
;; 변환된 프로그램에서 왜 추가 프레임(extra frame)이 생기는가?
;; =&gt; let이 lambda로 변환되면서 frame이 생성

;; 왜 이 차이가 동작에 영향을 주지 않는가?
;; =&gt; 값을 참조하는 시점에는 이미 초기화 되어있음.

;; 추가 프레임을 만들지 않고, 내부 정의에 대해 "동시(simultaneous)" 스코프 규칙을 인터프리터가 구현하도록 하는 방법을 설계하라.
;; simultaneous 발음
;; 미국식 ˌsaɪ.məlˈteɪ.niəs / 사이멀테이니어스
;; 영국식 ˌsɪm.əlˈteɪ.ni.əs / 시멀테이니어스
;;
;; simultaneous 방식( 두번째와 비슷하지만 추가 프레임 생성 안함.)
;; (lambda (x)
;;   (define u '*unassigned*)
;;   (define v '*unassigned*)
;;   (set! u (+ v 1))
;;   (set! v 2)
;;   (+ u v x))
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +------------------+
;;              | Frame F1         |   (procedure call frame)
;;              +------------------+
;;              | x = ARG          |
;;              | u = *unassigned* |
;;              | v = *unassigned* |
;;              +------------------+
;;                   |
;;       set! u 1
;;       set! v 2
;;       e3: (+ u v x)  ; lookup all in F1
;;

(#%require rackunit)
(#%require (prefix racket/ racket))
(#%require (prefix trace/ racket/trace))
(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (complement f)
  (lambda (x)
    (not (f x))))

(define (scan-out-defines-simultaneous body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((vars (map definition-variable defs))
               (vals (map definition-value defs))
               (unassigns-defs (map (lambda (var) (list 'define var ''*unassigned*)) vars))
               (assigns (map (lambda (x y) (list 'set! x y)) vars vals))
               (body-without-defs (filter (complement definition?) body)))
          ;; 현재 프레임에 바인딩 추가만 하고 let은 안 씀
          (append
           unassigns-defs
           assigns
           body-without-defs)))))

(check-equal? (scan-out-defines-simultaneous (lambda-body '(lambda (x)
                                                             (define u (+ v 1))
                                                             (define v 2)
                                                             (+ u v x))))
              '((define u '*unassigned*)
                (define v '*unassigned*)
                (set! u (+ v 1))
                (set! v 2)
                (+ u v x)))


(racket/require (racket/prefix-in ex4_06/ "4_06.rkt"))
(define third caddr)
(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)


(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines-simultaneous body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env2)
                          'ok)

            ;; hello body의 define이 lambda로 풀어진 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env2))
                          '((define u '*unassigned*)
                            (define v '*unassigned*)
                            (set! u 1)
                            (set! v 2)
                            (+ u v x)))
            (check-equal? (eval '(hello 3) env2)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))
</code></pre>
<h2 id="4_18"><a class="header" href="#4_18">4_18</a></h2>
<pre><code class="language-lisp">;; file: 4_18.rkt
;; 4_06 / 4_16 / 4_20 cont

(#%require rackunit)

(#%require (prefix racket/ racket))
(#%require (prefix trace/ racket/trace))

(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))

;; - before
;; (lambda &lt;vars&gt;
;;  (define u &lt;e1&gt;)
;;  (define v &lt;e2&gt;)
;;  &lt;e3&gt;)
;;
;; - 본문방식
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (set! u &lt;e1&gt;)
;;    (set! v &lt;e2&gt;)
;;    &lt;e3&gt;)))
;;
;; - 이번 문제 방식
;;   - 여기서 a와 b는 인터프리터가 새로 생성한 변수명으로, 사용자의 원래 프로그램에는 등장하지 않는다.
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (let ((a &lt;e1&gt;)
;;          (b &lt;e2&gt;))
;;      (set! u a)
;;      (set! v b))
;;    &lt;e3&gt;))
;;
;; 3.5.4의 solve는
;; (define (solve f y0 dt)
;;  (define y (integral (delay dy) y0 dt))
;;  (define dy (stream-map f y))
;;  y)
;;
;; - 본문방식이면
;; (let ((y '*unassigned*)
;;       (dy '*unassigned*))
;;   (set! y (integral (delay dy) y0 dt))
;;   (set! dy (stream-map f y))          ; &lt;---- dy에 제대로 된 값이 저장된다.
;;   (+ u v x)))
;;
;; - 이번 문제 방식에서는 이렇게 변환된다.
;; (let ((y '*unassigned*)
;;       (dy '*unassigned*))
;;   (let ((a (integral (delay dy) y0 dt))
;;         (b (stream-map f y)))         ; &lt;---- b에 (stream-map f '*unassigned*)라는 올바르지 않은 값이 저장되고, 4_16을 구현했으면 y를 가져다 쓰는 순간 에러.
;;     (set! y a)
;;     (set! dy b))                      ; &lt;---- 최종적으로 dy에 제대로 되지않은 b값이 저장된다.
;;   (+ u v x)))


(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (take n lst)
  (define (iter n lst acc)
    (cond
      ((or (&lt;= n 0) (null? lst))
       (reverse acc))
      (else
       (iter (- n 1) (cdr lst) (cons (car lst) acc)))))
  (iter n lst '()))


(define (complement f)
  (lambda (x)
    (not (f x))))

(define (make-let bindings body)
  ;; (make-let '((a 1)) '((+ a 2)))
  ;; =&gt; (let ((a 1)) (+ a 2))
  (append (list 'let bindings) body))

(define first car)
(define rest cdr)

(define (scan-out-defines-4_18 body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((body-without-defs (filter (complement definition?) body))
               (vars (map definition-variable defs))
               (vals (map definition-value defs))
               (len (length vars))
               (var2 (take len '(a b c d e f g)))
               (bindings (map (lambda (x) (list x ''*unassigned*)) vars))
               (bindings2 (map (lambda (x y) (list x y)) var2 vals))
               (assigns (map (lambda (x y) (list 'set! x y)) vars var2)))
          (list (make-let bindings
                          (append (list (make-let bindings2
                                                  assigns))
                                  body-without-defs)))))))


(check-equal? (scan-out-defines-4_18 (lambda-body '(lambda (x)
                                                     (define u 1)
                                                     (define v (+ 2 u))
                                                     (+ u v x))))
              '((let ((u '*unassigned*)
                      (v '*unassigned*))
                  (let ((a 1)
                        (b (+ 2 u)))
                    (set! u a)
                    (set! v b))
                  (+ u v x))))



(racket/require (racket/prefix-in ex4_06/ "4_06.rkt"))
(racket/require (racket/prefix-in ex4_16/ "4_16.rkt"))
(define third caddr)
(define env2 (setup-environment))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '+ (list 'primitive +) env3)

(override-lookup-variable-value! ex4_16/lookup-variable-value)

(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines-4_18 body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines-4_18 body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v (+ 2 u))
                                   (+ u v x))
                                env2)
                          'ok)

            (check-exn #rx"Unssigned variable u"
                       (lambda ()
                         (eval '(hello 3) env2)))
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))
</code></pre>
<h2 id="4_19"><a class="header" href="#4_19">4_19</a></h2>
<pre><code class="language-lisp">;; file: 4_19.rkt


;; (let ((a 1))
;;   (define (f x)
;;     (define b (+ a x))
;;     (define a 5)
;;     (+ a b))
;;   (f 10))

;; Ben Bitdiddle 의견
;; 순차적 규칙(sequential rule) - c / python ...
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = 11 (+ a x)
;; a = 5
;; 
;; (+ a b) =&gt; 16

;; Alyssa P. Hacker 의견
;; 동시 범위(simultaneous scope) 규칙 - scheme
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = *unassigned*
;; a = *unassigned*
;; b = 에러발생 (+ *unassigned* x)

;; Eva Lu Ator 의견
;; Layzy Evaluation - haskell / OCaml ...
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = lazy(+ a x)
;; a = 5
;; 
;; (+ a b) = 5 + lazy(+ a x)
;;         = 5 + (+ 5 10)
;;         = 20


;; 1. 세 가지 관점 중 어느 것(또는 어느 것도 아닌 것)을 지지하는가?
;; 살짝 정적 분석같은 기믹도 가미된 Alyssa P.
;;
;; 2. Eva Lu Ator 의견에 따라 동작하도록 구현할 수 있는가?
;; 정의부를 lambda식으로 감싸 실제 필요할때 평가도록 하면 될꺼같은데...


</code></pre>
<h2 id="4_20"><a class="header" href="#4_20">4_20</a></h2>
<pre><code class="language-lisp">;; file: 4_20.rkt
;; 4_17 / 4_18 / 4_21

(#%require rackunit)
(#%require (prefix racket/ racket))
(racket/require (racket/rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))


;; | 구문       | 바인딩 생성 방식                  | 앞 변수 참조 | 상호/자기 참조 |
;; | -------- | ----------------------------------- | ------------ | -------------- |
;; | `let`    | 모든 값 먼저 계산 후 한 번에 바인딩 | ❌          | ❌            |
;; | `let*`   | 순차적으로 바인딩 생성              | ⭕          | ❌            |
;; | `letrec` | 이름만 먼저 바인딩 후 값 설정       | ⭕          | ⭕            |

;; letrec: let recursive

;;
;; a. letrec을 derived expression로 처리. 연습문제 4.18 처럼 변수는 let으로 생성, set!으로 설정하라.
;;
(#%require (only "4_06.rkt" let? let-&gt;combination))
(#%require (only "4_07.rkt" make-let ))


(define first car)
(define second cadr)
(define rest cdr)

(define (letrec-&gt;let expr)
  (let* ((bindings (second expr))
         (body (rest (rest expr)))
         (vars (map first bindings))
         (new-bindings (map (lambda (x) (list x ''*unassigned*)) vars))
         (vals (map second bindings))
         (setter (map (lambda (x y) (list 'set! x y)) vars vals)))
    (make-let new-bindings (append setter body))))

(check-equal? (letrec-&gt;let
               '(letrec ((x 1))
                  (+ x 2)))
              '(let ((x '*unassigned*))
                 (set! x 1)
                 (+ x 2)))

(check-equal? (letrec-&gt;let
               '(letrec ((fact
                          (lambda (n)
                            (if (= n 1)
                                1
                                (* n (fact (- n 1)))))))
                  (fact 10)))
              '(let ((fact '*unassigned*))
                 (set! fact
                       (lambda (n)
                         (if (= n 1)
                             1
                             (* n (fact (- n 1))))))
                 (fact 10)))

(define (letrec? exp) (tagged-list? exp 'letrec))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env))
        ((letrec? exp) (eval (letrec-&gt;let exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(override-eval! eval)
(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '* (list 'primitive *) env2)
(define-variable! '= (list 'primitive =) env2)

(check-equal? (eval '(letrec ((x 1))
                       (+ x 2))
                    env2)
              3)

(check-eq? (eval '(letrec ((fact
                            (lambda (n)
                              (if (= n 1)
                                  1
                                  (* n (fact (- n 1)))))))
                    (fact 10))
                 env2)
           3628800)

(check-eq? (letrec ((fact
                     (lambda (n)
                       (if (= n 1)
                           1
                           (* n (fact (- n 1)))))))
             (fact 10))
           3628800)
;; 
;; b. (f 5)를 평가하는 동안 &lt;rest of body of f&gt;가 평가되는 환경(environment)을 나타내는
;; letrec버전 let버전에 대한  environment diagram을 그려라.
;; (odd?/even?은 이미 정의되어 있어, 오류를 확인하기 위해 odd?/even?을 new-odd?/new-even?으로 변경.)

;; let 버전
(define expr-v-let
  '(define (f x)
     ;; (f 5)
     ;; f 호출 환경 (x = 5)
     ;; ┌─────────────────────────────┐
     ;; │ f-frame                      │
     ;; │ x → 5                        │
     ;; └─────────────────────────────┘
     ;; 
     ;; let-frame
     ;; ┌─────────────────────────────┐
     ;; │ new-even? → &lt;lambda&gt;        │ &lt;&lt; lambda를 정의시 new-odd?를 찾아보는데 정의가 되지않아 오류가 나타난다.
     ;; │ new-odd?                    |
     ;; └─────────────────────────────┘
     (let ((new-even?
            (lambda (n)
              (if (= n 0)
                  true
                  (new-odd? (- n 1))))) ; new-odd?: unbound identifier in: new-odd?
           (new-odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (new-even? (- n 1))))))
       "&lt;rest of body of f&gt;"
       (new-even? x))))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env3)
(define-variable! '- (list 'primitive -) env3)
(define-variable! '* (list 'primitive *) env3)
(define-variable! '= (list 'primitive =) env3)
(check-equal? (eval expr-v-let
                    env3)
              'ok)
(check-exn #rx"Unbound variable new-odd?"
           (lambda ()
             (eval '(f 5) env3)))


;; letrec 버전
(define expr-v-letrec
  '(define (f x)
     ;; (f 5)
     ;; f 호출 환경 (x = 5)
     ;; ┌─────────────────────────────┐
     ;; │ f-frame                      │
     ;; │ x → 5                        │
     ;; └─────────────────────────────┘
     ;; 
     ;; letrec-frame
     ;; ┌─────────────────────────────┐
     ;; │ new-even? → &lt;unassigned&gt;    │
     ;; │ new-odd?  → &lt;unassigned&gt;    │
     ;; └─────────────────────────────┘
     ;; set! new-even? &lt;lambda&gt;
     ;; set! new-odd?  &lt;lambda&gt;
     (letrec ((new-even?
               (lambda (n)
                 (if (= n 0)
                     true
                     (new-odd? (- n 1)))))
              (new-odd?
               (lambda (n)
                 (if (= n 0)
                     false
                     (new-even? (- n 1))))))
       "&lt;rest of body of f&gt;"
       (new-even? x))))

(define env4 (setup-environment))
(define-variable! '+ (list 'primitive +) env4)
(define-variable! '- (list 'primitive -) env4)
(define-variable! '* (list 'primitive *) env4)
(define-variable! '= (list 'primitive =) env4)
(check-equal? (eval expr-v-letrec
                    env4)
              'ok)
(check-eq? (eval '(f 5) env4)
           false)


(override-eval! origin/eval)
</code></pre>
<h2 id="4_21"><a class="header" href="#4_21">4_21</a></h2>
<pre><code class="language-lisp">;; file: 4_21.rkt
</code></pre>
<h2 id="4_22"><a class="header" href="#4_22">4_22</a></h2>
<pre><code class="language-lisp">;; file: 4_22.rkt
</code></pre>
<h2 id="4_23"><a class="header" href="#4_23">4_23</a></h2>
<pre><code class="language-lisp">;; file: 4_23.rkt
</code></pre>
<h2 id="4_24"><a class="header" href="#4_24">4_24</a></h2>
<pre><code class="language-lisp">;; file: 4_24.rkt
</code></pre>
<h2 id="4_25"><a class="header" href="#4_25">4_25</a></h2>
<pre><code class="language-lisp">;; file: 4_25.rkt
</code></pre>
<h2 id="4_26"><a class="header" href="#4_26">4_26</a></h2>
<pre><code class="language-lisp">;; file: 4_26.rkt
</code></pre>
<h2 id="4_27"><a class="header" href="#4_27">4_27</a></h2>
<pre><code class="language-lisp">;; file: 4_27.rkt
</code></pre>
<h2 id="4_28"><a class="header" href="#4_28">4_28</a></h2>
<pre><code class="language-lisp">;; file: 4_28.rkt
</code></pre>
<h2 id="4_29"><a class="header" href="#4_29">4_29</a></h2>
<pre><code class="language-lisp">;; file: 4_29.rkt
</code></pre>
<h2 id="4_30"><a class="header" href="#4_30">4_30</a></h2>
<pre><code class="language-lisp">;; file: 4_30.rkt
</code></pre>
<h2 id="4_31"><a class="header" href="#4_31">4_31</a></h2>
<pre><code class="language-lisp">;; file: 4_31.rkt
</code></pre>
<h2 id="4_32"><a class="header" href="#4_32">4_32</a></h2>
<pre><code class="language-lisp">;; file: 4_32.rkt
</code></pre>
<h2 id="4_33"><a class="header" href="#4_33">4_33</a></h2>
<pre><code class="language-lisp">;; file: 4_33.rkt
</code></pre>
<h2 id="4_34"><a class="header" href="#4_34">4_34</a></h2>
<pre><code class="language-lisp">;; file: 4_34.rkt
</code></pre>
<h2 id="4_35"><a class="header" href="#4_35">4_35</a></h2>
<pre><code class="language-lisp">;; file: 4_35.rkt
</code></pre>
<h2 id="4_36"><a class="header" href="#4_36">4_36</a></h2>
<pre><code class="language-lisp">;; file: 4_36.rkt
</code></pre>
<h2 id="4_37"><a class="header" href="#4_37">4_37</a></h2>
<pre><code class="language-lisp">;; file: 4_37.rkt
</code></pre>
<h2 id="4_38"><a class="header" href="#4_38">4_38</a></h2>
<pre><code class="language-lisp">;; file: 4_38.rkt
</code></pre>
<h2 id="4_39"><a class="header" href="#4_39">4_39</a></h2>
<pre><code class="language-lisp">;; file: 4_39.rkt
</code></pre>
<h2 id="4_40"><a class="header" href="#4_40">4_40</a></h2>
<pre><code class="language-lisp">;; file: 4_40.rkt
</code></pre>
<h2 id="4_41"><a class="header" href="#4_41">4_41</a></h2>
<pre><code class="language-lisp">;; file: 4_41.rkt
</code></pre>
<h2 id="4_42"><a class="header" href="#4_42">4_42</a></h2>
<pre><code class="language-lisp">;; file: 4_42.rkt
</code></pre>
<h2 id="4_43"><a class="header" href="#4_43">4_43</a></h2>
<pre><code class="language-lisp">;; file: 4_43.rkt
</code></pre>
<h2 id="4_44"><a class="header" href="#4_44">4_44</a></h2>
<pre><code class="language-lisp">;; file: 4_44.rkt
</code></pre>
<h2 id="4_45"><a class="header" href="#4_45">4_45</a></h2>
<pre><code class="language-lisp">;; file: 4_45.rkt
</code></pre>
<h2 id="4_46"><a class="header" href="#4_46">4_46</a></h2>
<pre><code class="language-lisp">;; file: 4_46.rkt
</code></pre>
<h2 id="4_47"><a class="header" href="#4_47">4_47</a></h2>
<pre><code class="language-lisp">;; file: 4_47.rkt
</code></pre>
<h2 id="4_48"><a class="header" href="#4_48">4_48</a></h2>
<pre><code class="language-lisp">;; file: 4_48.rkt
</code></pre>
<h2 id="4_49"><a class="header" href="#4_49">4_49</a></h2>
<pre><code class="language-lisp">;; file: 4_49.rkt
</code></pre>
<h2 id="4_50"><a class="header" href="#4_50">4_50</a></h2>
<pre><code class="language-lisp">;; file: 4_50.rkt
</code></pre>
<h2 id="4_51"><a class="header" href="#4_51">4_51</a></h2>
<pre><code class="language-lisp">;; file: 4_51.rkt
</code></pre>
<h2 id="4_52"><a class="header" href="#4_52">4_52</a></h2>
<pre><code class="language-lisp">;; file: 4_52.rkt
</code></pre>
<h2 id="4_53"><a class="header" href="#4_53">4_53</a></h2>
<pre><code class="language-lisp">;; file: 4_53.rkt
</code></pre>
<h2 id="4_54"><a class="header" href="#4_54">4_54</a></h2>
<pre><code class="language-lisp">;; file: 4_54.rkt
</code></pre>
<h2 id="4_55"><a class="header" href="#4_55">4_55</a></h2>
<pre><code class="language-lisp">;; file: 4_55.rkt
</code></pre>
<h2 id="4_56"><a class="header" href="#4_56">4_56</a></h2>
<pre><code class="language-lisp">;; file: 4_56.rkt
</code></pre>
<h2 id="4_57"><a class="header" href="#4_57">4_57</a></h2>
<pre><code class="language-lisp">;; file: 4_57.rkt
</code></pre>
<h2 id="4_58"><a class="header" href="#4_58">4_58</a></h2>
<pre><code class="language-lisp">;; file: 4_58.rkt
</code></pre>
<h2 id="4_59"><a class="header" href="#4_59">4_59</a></h2>
<pre><code class="language-lisp">;; file: 4_59.rkt
</code></pre>
<h2 id="4_60"><a class="header" href="#4_60">4_60</a></h2>
<pre><code class="language-lisp">;; file: 4_60.rkt
</code></pre>
<h2 id="4_61"><a class="header" href="#4_61">4_61</a></h2>
<pre><code class="language-lisp">;; file: 4_61.rkt
</code></pre>
<h2 id="4_62"><a class="header" href="#4_62">4_62</a></h2>
<pre><code class="language-lisp">;; file: 4_62.rkt
</code></pre>
<h2 id="4_63"><a class="header" href="#4_63">4_63</a></h2>
<pre><code class="language-lisp">;; file: 4_63.rkt
</code></pre>
<h2 id="4_64"><a class="header" href="#4_64">4_64</a></h2>
<pre><code class="language-lisp">;; file: 4_64.rkt
</code></pre>
<h2 id="4_65"><a class="header" href="#4_65">4_65</a></h2>
<pre><code class="language-lisp">;; file: 4_65.rkt
</code></pre>
<h2 id="4_66"><a class="header" href="#4_66">4_66</a></h2>
<pre><code class="language-lisp">;; file: 4_66.rkt
</code></pre>
<h2 id="4_67"><a class="header" href="#4_67">4_67</a></h2>
<pre><code class="language-lisp">;; file: 4_67.rkt
</code></pre>
<h2 id="4_68"><a class="header" href="#4_68">4_68</a></h2>
<pre><code class="language-lisp">;; file: 4_68.rkt
</code></pre>
<h2 id="4_69"><a class="header" href="#4_69">4_69</a></h2>
<pre><code class="language-lisp">;; file: 4_69.rkt
</code></pre>
<h2 id="4_70"><a class="header" href="#4_70">4_70</a></h2>
<pre><code class="language-lisp">;; file: 4_70.rkt
</code></pre>
<h2 id="4_71"><a class="header" href="#4_71">4_71</a></h2>
<pre><code class="language-lisp">;; file: 4_71.rkt
</code></pre>
<h2 id="4_72"><a class="header" href="#4_72">4_72</a></h2>
<pre><code class="language-lisp">;; file: 4_72.rkt
</code></pre>
<h2 id="4_73"><a class="header" href="#4_73">4_73</a></h2>
<pre><code class="language-lisp">;; file: 4_73.rkt
</code></pre>
<h2 id="4_74"><a class="header" href="#4_74">4_74</a></h2>
<pre><code class="language-lisp">;; file: 4_74.rkt
</code></pre>
<h2 id="4_75"><a class="header" href="#4_75">4_75</a></h2>
<pre><code class="language-lisp">;; file: 4_75.rkt
</code></pre>
<h2 id="4_76"><a class="header" href="#4_76">4_76</a></h2>
<pre><code class="language-lisp">;; file: 4_76.rkt
</code></pre>
<h2 id="4_77"><a class="header" href="#4_77">4_77</a></h2>
<pre><code class="language-lisp">;; file: 4_77.rkt
</code></pre>
<h2 id="4_78"><a class="header" href="#4_78">4_78</a></h2>
<pre><code class="language-lisp">;; file: 4_78.rkt
</code></pre>
<h2 id="4_79"><a class="header" href="#4_79">4_79</a></h2>
<pre><code class="language-lisp">;; file: 4_79.rkt
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../solution/solution_ch03.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../solution/solution_ch05.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../solution/solution_ch03.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../solution/solution_ch05.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
