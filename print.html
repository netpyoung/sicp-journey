<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SICP 여정</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="SICP 여정">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SICP 여정</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/netpyoung/sicp-journey" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sicpstructure-and-interpretation-of-computer-programs"><a class="header" href="#sicpstructure-and-interpretation-of-computer-programs">SICP(<code>S</code>tructure and <code>I</code>nterpretation of <code>C</code>omputer <code>P</code>rograms)</a></h1>
<ul>
<li><code>S</code>tructures and <code>I</code>nterpretation of <code>C</code>omputer <code>P</code>rogram
<ul>
<li>컴퓨터 프로그램의 구조와 해석은 MIT 대학 교수인 <code>Harold Abelson</code>과 <code>Gerald Jay Sussman</code>이 <code>Julie Sussman</code>과 함께 쓴 컴퓨터 과학 교과서입니다. 해커 문화에서는 "마법사 책"으로 알려져 있습니다.</li>
</ul>
</li>
<li><a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">wikipedia</a></li>
</ul>
<h2 id="요구조건"><a class="header" href="#요구조건">요구조건</a></h2>
<ul>
<li>엄청난 시간.
<ul>
<li>연습문제는 깊이있는 이해를 도와주지만, 손을 대는 순간 타임머신이므로, 탐독할 시간이 적으신 분은 욕심을 내려놓으셔야 합니다.</li>
</ul>
</li>
<li>영어.
<ul>
<li>번역서가 있기는 하나, 번역하신 분께는 죄송하나, 원문의 내용을 오해하게 만들거나, 어색하거나 이해하기 어려운 번역이 있어 뭔가 이상하면 원서를 봐야합니다.</li>
<li>Ai(chatgpt/deepl)나, 번역서비스(google/naver)를 이용 권장. 어쨋든 번역서 만으로 이해하는데 에로사항이 많음.</li>
</ul>
</li>
</ul>
<h2 id="책"><a class="header" href="#책">책</a></h2>
<ul>
<li><a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html">ver. mitp-content)</a>
<ul>
<li><a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/code/index.html">code</a></li>
</ul>
</li>
<li><a href="https://web.mit.edu/6.001/6.037/sicp.pdf">ver. pdf</a></li>
<li>ver. sarabander
<ul>
<li>추천</li>
<li><a href="https://sarabander.github.io/sicp/html/">online</a></li>
<li><a href="https://github.com/sarabander/sicp-pdf/raw/master/sicp.pdf">pdf</a>
<ul>
<li><a href="https://www.sumatrapdfreader.org/free-pdf-reader">pdf reader - Sumatra PDF</a></li>
</ul>
</li>
<li><a href="https://github.com/sarabander/sicp-epub/blob/master/sicp.epub?raw=true">epub</a>
<ul>
<li><a href="https://readest.com/">epub reader - readest</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://product.kyobobook.co.kr/detail/S000001033024">한글판: 컴퓨터 프로그램의 구조와 해석</a>
<ul>
<li>번역) 김재우,안윤호,김수정,김정민, 감수) 이광근</li>
<li>비추천
<ul>
<li><a href="https://kizoo.blogspot.com/2007/03/sicp.html">https://kizoo.blogspot.com/2007/03/sicp.html</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="비디오"><a class="header" href="#비디오">비디오</a></h2>
<ul>
<li>MIT 6.001 Structure and Interpretation, 1986
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLE18841CABEA24090">youtube</a></li>
<li><a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video_galleries/video-lectures/">opencourseware</a></li>
<li><a href="https://nebhrajani-a.org/sicp/video_notes/">notes by Aditya</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PL7BcsI5ueSNFPCEisbaoQ0kXIDX9rR5FF">by Eric Grimson in 2004</a></li>
<li><a href="https://ropas.snu.ac.kr/~kwang/4190.210/13/">by 이광근 Kwangkeun Yi 교수님</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLVFrD1dmDdvdvWFK8brOVNL7bKHpE-9w0">by code_report</a></li>
</ul>
<h2 id="솔루션"><a class="header" href="#솔루션">솔루션</a></h2>
<ul>
<li><a href="https://wizardbook.wordpress.com/solutions-index/">SICP exercises - Is this a cdadr which I see before me? </a>
<ul>
<li><a href="https://gitlab.com/barry.allison/wizard-book-solutions">source</a></li>
</ul>
</li>
<li><a href="https://mk12.github.io/sicp/exercise/index.html">SICP Study</a>
<ul>
<li><a href="https://github.com/mk12/sicp">source</a></li>
</ul>
</li>
<li>by <a href="https://zv.github.io/about.html">Zetavolt</a>
<ul>
<li><a href="https://github.com/zv/SICP-guile/tree/master">source</a></li>
<li>챕터 <a href="https://zv.github.io/sicp-chapter-1">1</a> / <a href="https://zv.github.io/sicp-chapter-2">2</a> / <a href="https://zv.github.o/sicp-chapter-3">3</a> / <a href="https://zv.github.io/sicp-chapter-4">4</a></li>
</ul>
</li>
<li><a href="https://sicp-solutions.net/">https://sicp-solutions.net/</a>
<ul>
<li>2장 초반부까지만</li>
</ul>
</li>
<li>by lisp-korea
<ul>
<li><a href="https://github.com/lisp-korea/sicp">source 1</a></li>
<li><a href="https://github.com/lisp-korea/sicp2014">source 2</a></li>
</ul>
</li>
<li>by 아꿈사 스터디(아키텍트를 꿈꾸는 사람들, andstudy)
<ul>
<li><a href="https://github.com/andstudy/forge/wiki/sicp">https://github.com/andstudy/forge/wiki/sicp</a></li>
<li><a href="https://github.com/andstudy/afternoon/wiki/2014_SICP">https://github.com/andstudy/afternoon/wiki/2014_SICP</a></li>
</ul>
</li>
<li><a href="https://www.inchmeal.io/sicp/index.html">https://www.inchmeal.io/sicp/index.html</a></li>
<li><a href="https://github.com/hjcapple/reading-sicp">https://github.com/hjcapple/reading-sicp</a></li>
<li><a href="https://github.com/ivanjovanovic/sicp">https://github.com/ivanjovanovic/sicp</a></li>
<li><a href="https://eli.thegreenplace.net/tag/sicp">https://eli.thegreenplace.net/tag/sicp</a></li>
<li><a href="https://github.com/l0stman/sicp">https://github.com/l0stman/sicp</a></li>
</ul>
<h2 id="기타"><a class="header" href="#기타">기타</a></h2>
<ul>
<li><a href="https://corecursive.com/039-hal-abelson-sicp/">Language Oriented Design - Discussing SICP with Hal Abelson</a></li>
<li><a href="https://www.amazon.com/Instructors-Structure-Interpretation-Computer-Programs/dp/0262692201/">Instructor's Manual t/a Structure and Interpretation of Computer Programs</a></li>
<li><a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/9579/sicm_edition_2.zip/book.html">Structure and Interpretation of Classical Mechanics (SICM) </a></li>
<li><a href="https://www.amazon.com/Software-Design-Flexibility-Programming-Yourself/dp/0262045494">Software Design for Flexibility</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="들어가며"><a class="header" href="#들어가며">들어가며</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drracket"><a class="header" href="#drracket">DrRacket</a></h1>
<p>The Racket Programming Environment</p>
<ul>
<li><a href="https://download.racket-lang.org/">다운로드</a>
<ul>
<li><a href="https://kkalkkalparrot.tistory.com/31">깔깔앵무의 정리노트 - [프로그래밍언어] Racket 설치 및 SICP 모듈 설정(1)</a></li>
<li><a href="https://kkalkkalparrot.tistory.com/32">깔깔앵무의 정리노트 - [프로그래밍언어] Racket 설치 및 SICP 모듈 설정(2)</a></li>
</ul>
</li>
</ul>
<h2 id="왜-drracket"><a class="header" href="#왜-drracket">왜 DrRacket</a></h2>
<ul>
<li>ref: <a href="https://github.com/zv/SICP-guile?tab=readme-ov-file#language">https://github.com/zv/SICP-guile?tab=readme-ov-file#language</a>
<ul>
<li>Zetavolt이란 분은 GNU Guile을 추천함.</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th>PL</th><th>r5rs</th><th>함수 재정의</th><th>GUI IDE</th></tr></thead><tbody>
<tr><td>DrRacket</td><td>Racket</td><td>O</td><td>X</td><td>DrRacket</td></tr>
<tr><td>MITScheme</td><td>Scheme</td><td>O</td><td>O</td><td>X</td></tr>
<tr><td>GNU Guile</td><td>Scheme</td><td>O</td><td>O</td><td>X</td></tr>
<tr><td>CHICKEN Scheme</td><td>Scheme</td><td>O</td><td>O</td><td>X</td></tr>
<tr><td>SBCL</td><td>Common Lisp</td><td>X</td><td>O</td><td>Slt Plugin for JetBrains IDEs</td></tr>
<tr><td>LispWorks</td><td>Common Lisp</td><td>X</td><td>O</td><td>LispWorks</td></tr>
</tbody></table>
</div>
<ul>
<li>Common Lisp로 하는건 일단 배제하고,</li>
<li><strong>Emacs 사용이 자유로운 사람</strong>이라면, 함수를 계속 덮어쓰므로 Scheme구현체 중 하나를 선택하면 좋다.</li>
<li><strong>단점!</strong> 물론 불러온 함수 재정의가 안되는 치명적인 단점과 필요에 따라 추가적인 racket문법을 익혀야 한다는 단점이 있다.</li>
<li><strong>장점!</strong> 설치도 간편. IDE를 지원하는게 DrRacket이 유일. 디버거도 그럭저럭 쓸만하고, racket 패키지들도 유용하고 문서화가 잘 되어 있다.</li>
<li>단점도 엄청 치명적이긴 한데 IDE지원이라는 장점이 진입장벽을 낮춤으로써 단점보다 조금 더 낫다고 생각했다.</li>
</ul>
<h2 id="흔히-쓰게될-단축키"><a class="header" href="#흔히-쓰게될-단축키">흔히 쓰게될 단축키</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>단축키</th><th></th><th></th></tr></thead><tbody>
<tr><td>파일 실행</td><td>Ctrl + R  / F5</td><td></td><td></td></tr>
<tr><td>코드 포맷</td><td>Ctrl + I</td><td></td><td></td></tr>
<tr><td>코드 &lt;=&gt; Repl 전환</td><td>Ctrl + F6</td><td>shift-focus</td><td></td></tr>
<tr><td>λ 문자 삽입</td><td>Ctrl + \</td><td>insert λ</td><td>#lang racket에선 lambda대신 λ도 가능</td></tr>
<tr><td>자동완성</td><td>Ctrl + /</td><td>Complete Word</td><td></td></tr>
<tr><td>파일 버퍼 되돌리기</td><td>Ctrl + Shift + E</td><td>Revert</td><td>외부 에디터에서 파일을 수정해도 자동으로 버퍼를 갱신하지 않으니 외부에서 파일 수정시 버퍼 초기화 용도</td></tr>
<tr><td>인덴트 가이드</td><td>Ctrl + Shift + I</td><td>Show Indent Guides</td><td></td></tr>
</tbody></table>
</div>
<ul>
<li>정의로 가기는 단축키가 없다
<ul>
<li>함수 이름 우클릭 &gt; Jump to definition of {blabla}? 클릭</li>
</ul>
</li>
</ul>
<h2 id="tip"><a class="header" href="#tip">Tip</a></h2>
<h3 id="sicp가-설치가-안되어-있다면"><a class="header" href="#sicp가-설치가-안되어-있다면">SICP가 설치가 안되어 있다면</a></h3>
<ul>
<li>File &gt; Package Manager... 쪽에서 sicp를 찾아보면 된다
<ul>
<li><a href="https://docs.racket-lang.org/sicp-manual/SICP_Language.html">https://docs.racket-lang.org/sicp-manual/SICP_Language.html</a></li>
<li><a href="https://github.com/sicp-lang/sicp/tree/master">https://github.com/sicp-lang/sicp/tree/master</a></li>
</ul>
</li>
</ul>
<h3 id="코드-색깔-바꾸기"><a class="header" href="#코드-색깔-바꾸기">코드 색깔 바꾸기</a></h3>
<ul>
<li>
<p>define이라도 색깔이 다르면 좀 더 코드가 보기 편해진다.</p>
</li>
<li>
<p>다음 사이트에서 원하는 테마를 고르고</p>
<ul>
<li><a href="https://github.com/tuirgin/base16-drracket">https://github.com/tuirgin/base16-drracket</a></li>
<li><a href="https://github.com/catppuccin/drracket">https://github.com/catppuccin/drracket</a></li>
</ul>
</li>
<li>
<p>File &gt; Package Manager... 쪽에서</p>
<ul>
<li><code>https://github.com/tuirgin/base16-drracket</code> 를 붙여넣어서 설치 하거나</li>
<li><code>https://github.com/catppuccin/drracket</code> 를 붙여넣어서 설치</li>
</ul>
</li>
</ul>
<h3 id="코드-포맷"><a class="header" href="#코드-포맷">코드 포맷</a></h3>
<ul>
<li>메뉴&gt; Racket &gt; Reindent All</li>
<li>혹은 단축키 Ctrl + I</li>
<li>혹은 전체 선택(Ctrl + A) 후 Tab</li>
</ul>
<h3 id="백업파일bak-생성-안되게"><a class="header" href="#백업파일bak-생성-안되게">백업파일(.bak) 생성 안되게</a></h3>
<ul>
<li>메뉴&gt; Edit &gt; Preferences...
<ul>
<li>General 탭
<ul>
<li>Make backups for unsaved files 체크 해제</li>
<li>Create first-change files 체크 해제</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="emacs-키-바인딩이-그립다면"><a class="header" href="#emacs-키-바인딩이-그립다면">Emacs 키 바인딩이 그립다면</a></h3>
<ul>
<li>
<p>메뉴&gt; Edit &gt; Preferences...</p>
<ul>
<li>Editing 탭
<ul>
<li>General Editing탭
<ul>
<li>Enable keybindings in menus (overrides Emacs keybindings) 체크 해제</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ref</p>
<ul>
<li><a href="https://docs.racket-lang.org/drracket/Keyboard_Shortcuts.html">https://docs.racket-lang.org/drracket/Keyboard_Shortcuts.html</a></li>
<li><a href="https://blog.racket-lang.org/2009/03/the-drscheme-repl-isnt-the-one-in-emacs.html">https://blog.racket-lang.org/2009/03/the-drscheme-repl-isnt-the-one-in-emacs.html</a></li>
<li><a href="https://stackoverflow.com/questions/56916606/drracket-custom-keybindings">https://stackoverflow.com/questions/56916606/drracket-custom-keybindings</a></li>
</ul>
</li>
<li>
<p>emacs</p>
<ul>
<li><a href="https://docs.racket-lang.org/guide/Emacs.html">https://docs.racket-lang.org/guide/Emacs.html</a>
<ul>
<li><a href="https://www.nongnu.org/geiser/">https://www.nongnu.org/geiser/</a></li>
<li><a href="https://github.com/emacsmirror/geiser?tab=readme-ov-file">https://github.com/emacsmirror/geiser?tab=readme-ov-file</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="쓰레딩-매크로----를-사용하고-싶다면"><a class="header" href="#쓰레딩-매크로----를-사용하고-싶다면">쓰레딩 매크로( ~&gt; / ~&gt;&gt; )를 사용하고 싶다면</a></h3>
<ul>
<li><a href="https://github.com/lexi-lambda/threading">threading</a>
<ul>
<li>clojure -&gt; / -&gt;&gt; 와는 다르게 ~&gt; / ~&gt;&gt; 이다</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">#lang sicp
(#%require threading)

(~&gt; 2 (/ 5))
;;=&gt; 2/5

(~&gt;&gt; 2 (/ 5))
;;=&gt; 5/2
</code></pre>
<h3 id="유닛테스트를-하고-싶다면"><a class="header" href="#유닛테스트를-하고-싶다면">유닛테스트를 하고 싶다면?</a></h3>
<ul>
<li><a href="https://docs.racket-lang.org/rackunit/">rackunit</a></li>
</ul>
<pre><code class="language-lisp">#lang sicp

(#%require rackunit)

(check-equal? (+ 1 2) 3)
;; (check-equal? &lt;expected&gt; &lt;actual&gt; &lt;message&gt;)
</code></pre>
<h3 id="drracket-디버거-사용이-힘들어-그냥-쉽게-출력해서-보고-싶다면"><a class="header" href="#drracket-디버거-사용이-힘들어-그냥-쉽게-출력해서-보고-싶다면">DrRacket 디버거 사용이 힘들어 그냥 쉽게 출력해서 보고 싶다면</a></h3>
<ul>
<li><a href="https://docs.racket-lang.org/debug/index.html">https://docs.racket-lang.org/debug/index.html</a></li>
</ul>
<pre><code class="language-lisp">#lang debug sicp
(+ 1 2 #R(* 3 4))
;;&gt;&gt; {* 3 4} = 12
;;=&gt; 15
</code></pre>
<h3 id="함수-수행을-따라가-보고-싶다면"><a class="header" href="#함수-수행을-따라가-보고-싶다면">함수 수행을 따라가 보고 싶다면</a></h3>
<ul>
<li><a href="https://docs.racket-lang.org/reference/debugging.html">https://docs.racket-lang.org/reference/debugging.html</a></li>
</ul>
<pre><code>#lang sicp

(define (f x)
  (if (zero? x) 0
      (add1 (f (sub1 x)))))

(#%require (prefix trace: racket/trace))
(trace:trace f)
</code></pre>
<h3 id="todo-errortrace"><a class="header" href="#todo-errortrace">todo errortrace</a></h3>
<p>"C:\Program Files\Racket\Racket.exe" -l errortrace -t 4_08.rkt</p>
<ul>
<li>https://docs.racket-lang.org/errortrace/using-errortrace.html</li>
</ul>
<h3 id="todo-pretty-print"><a class="header" href="#todo-pretty-print">todo pretty print</a></h3>
<ul>
<li>https://docs.racket-lang.org/reference/pretty-print.html</li>
</ul>
<h3 id="todo-sandbox"><a class="header" href="#todo-sandbox">TODO sandbox</a></h3>
<ul>
<li>https://docs.racket-lang.org/reference/Sandboxed_Evaluation.html</li>
</ul>
<h3 id="기타-문법"><a class="header" href="#기타-문법">기타 문법</a></h3>
<pre><code class="language-lisp">
;; 블록 코맨트( #; )
#;(error "wtf")


;; TODO 설명 필요

(#%require (prefix racket: racket))
(racket:provide (racket:all-defined-out))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1장-함수로-추상화-쌓기"><a class="header" href="#1장-함수로-추상화-쌓기">1장. 함수로 추상화 쌓기</a></h1>
<ul>
<li>
<p>Building Abstractions with Procedures</p>
<ul>
<li>1장은, 추상화를 쌓아 올리기 위한 함수 기법을 설명한다.</li>
</ul>
</li>
<li>
<p>프로그래밍에서 추상화(abstraction)는 복잡한 것에서 불필요한 세부를 숨기고, 꼭 필요한 핵심만 간추려 내는 것을 말한다.</p>
</li>
<li>
<p>책에서는 함수(function)를 수학적인 개념이라하고, 프로씨저(procedure)를 계산 절차라 구분지었는데,</p>
<ul>
<li>함수를 짠다는 말이 더 익숙하기에 그냥 이 둘을 합쳐서 함수로 퉁치자.</li>
</ul>
</li>
<li>
<p>복잡한 것을 단순한 것에서부터 쌓아 올려 일반화(여러 상황에서 쓸 수 있도록)한다.</p>
<ul>
<li>세부 구현을 숨기면, 복잡한 로직도 하나의 <strong>도구</strong>처럼 취급 가능</li>
</ul>
</li>
<li>
<p>함수를 이름 붙여 재사용하고, 세부 구현을 감춘다.</p>
</li>
<li>
<p>동작 자체를 데이터처럼 다루는 능력</p>
<ul>
<li>함수를 인자로 받아 사용하거나 함수를 반환하는 함수.</li>
</ul>
</li>
</ul>
<h2 id="기본"><a class="header" href="#기본">기본</a></h2>
<h3 id="문법"><a class="header" href="#문법">문법</a></h3>
<pre><code class="language-lisp">;; ================
;; 변수 정의
(define SIZE 2)

;; ================
;; 영역 변수
(let ((x 1)
      (y 2))
  (+ x y))

(let* ((x 1)
       (y (+ x 2)))
  (+ x y))

;; ================
;; 함수 정의
(define (Square x)
  (* x x))

;; ================
;; 익명함수
((lambda (x) (+ x 4)) 5)
   
;; ================
;; 조건문 cond / if
(define (Abs-1 x)
  (cond ((= x 0) 0)
        ((&gt; x 0) x)
        ((&lt; x 0) (- x))))

(define (Abs-2 x)
  (cond ((&lt; x 0) (- x))
        (else x)))

(define (Abs-3 x)
  (if (&lt; x 0)
      (- x)
      x))

;; =============
;; 참(true , #t) / 거짓 (false , #f)
true
;;=&gt; #t
#t
;;=&gt; #t
false
;;=&gt; #f
#f
;;=&gt; #f

;; ================
;; 시퀀스의 각 요소에 함수를 적용.
(map (lambda (x) (* x x)) '(1 2 3 4))
;;=&gt; (1 4 9 16)
</code></pre>
<h3 id="기타-내장-함수"><a class="header" href="#기타-내장-함수">기타 내장 함수</a></h3>
<pre><code class="language-lisp">(display "Hello World")       ; 출력
;;&gt;&gt; Hello World

(newline)                     ; 빈 라인 출력
;;&gt;&gt; 
;;=&gt; 

(error "this is error!" 1 2 3) ; 에러 출력 및 중단
;;=&gt; this is error! 1 2 3

(inc 1)                        ; 1 증가
;;=&gt; 2

(dec 1)                        ; 1 감소
;;=&gt; 0
</code></pre>
<h2 id="function--procedure--process"><a class="header" href="#function--procedure--process">Function / Procedure / Process</a></h2>
<ul>
<li>책에서는 함수와 프로시져를 구분해왔으나, 여기 개념설명 이후, 그냥 함수( function + procedure )로 퉁 치겠다.</li>
</ul>
<h3 id="함수function--수학적-개념"><a class="header" href="#함수function--수학적-개념">함수(Function) = 수학적 개념</a></h3>
<pre><code class="language-txt">Factorial(N) = N!
</code></pre>
<h3 id="프로시저procedure---프로그래머가-작성한-계산-절차알고리즘"><a class="header" href="#프로시저procedure---프로그래머가-작성한-계산-절차알고리즘">프로시저(Procedure) =  프로그래머가 작성한 계산 절차(알고리즘)</a></h3>
<pre><code class="language-lisp">(define (Factorial n)
  (if (= n 1)
      1
      (* n (Factorial (dec n)))))
</code></pre>
<h3 id="프로세스process--프로시저를-실행할-때-전개되는-계산의-단계적-진행상황"><a class="header" href="#프로세스process--프로시저를-실행할-때-전개되는-계산의-단계적-진행상황">프로세스(Process) = 프로시저를 실행할 때, 전개되는 계산의 단계적 진행상황</a></h3>
<pre><code class="language-txt">(Factorial 3)
→ 3 * (Factorial 2)
→ 3 * (2 * (Factorial 1))
→ 3 * (2 * (1 * (Factorial 0)))
→ 3 * (2 * (1 * 1))
→ 6
</code></pre>
<h2 id="일반-재귀-non-tail-recursion와-꼬리-재귀-tail-recursion"><a class="header" href="#일반-재귀-non-tail-recursion와-꼬리-재귀-tail-recursion">일반 재귀 (non-tail recursion)와 꼬리 재귀 (tail recursion)</a></h2>
<ul>
<li>procedure와 process의 차이를 보여주며, procedure가 만들어내는 process를 상상해 낼 수 있는 능력을 강조.
<ul>
<li>procedure
<ul>
<li>함수 정의, 계산을 수행하기 위한 명령어 집합 혹은 알고리즘의 규칙</li>
</ul>
</li>
<li>process
<ul>
<li>메모리, 시간, 호출 스택 등과 관련된 실행의 구체적인 양상</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="일반-재귀-non-tail-recursion-linear-recursive-process"><a class="header" href="#일반-재귀-non-tail-recursion-linear-recursive-process">일반 재귀 (non-tail recursion) linear recursive process</a></h3>
<ul>
<li>내부의 곱셈을 계산하기 위해 함수의 Call 스택이 쌓인다.
<ul>
<li>단계가 늘어나면 스택이 넘치게 된다( Stack overflow )</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(define (Factorial-recur n)
  (if (= n 1)
      1
      (* n (Factorial-recur (dec n)))))

;; (Factorial-recur 3)
;; → 3 * (Factorial-recur 2)
;; → 3 * (2 * (Factorial-recur 1))
;; → 3 * (2 * (1 * (Factorial-recur 0)))
;; → 3 * (2 * (1 * 1))
;; → 6
</code></pre>
<h3 id="꼬리-재귀-tail-recursion-linear-iterative-process"><a class="header" href="#꼬리-재귀-tail-recursion-linear-iterative-process">꼬리 재귀 (tail recursion) linear iterative process</a></h3>
<ul>
<li>스택 프레임 생성 자체를 억제시켜 함수의 Call 스택이지 않는다.
<ul>
<li><a href="https://en.wikipedia.org/wiki/Tail_call">tail-call optimization (TCO)</a></li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(define (Factorial-iter n)
  (if (&lt; n 0)
      (error "n must be greater than or equal to 0. n =" n ))
  (define (iter acc x)
    (if (= x 0)
        acc
        (iter (* acc x) (dec x))))
  (iter 1 n))

;; (Factorial-iter 3)
;; → (iter 1 3)
;; → (iter (* 1 3) 2)
;; → (iter (* 3 2) 1)
;; → (iter (* 6 1) 0)
;; → 6
</code></pre>
<h2 id="고차-함수-higher-order-function"><a class="header" href="#고차-함수-higher-order-function">고차 함수 (higher-order function)</a></h2>
<ul>
<li>함수를 데이터처럼 사용하는 함수
<ul>
<li>ex)
<ul>
<li>C 에서의 <a href="https://en.wikipedia.org/wiki/Function_pointer">함수포인터</a></li>
<li>C# 에서의 delegate 혹은 Func/Action/Predicate타입</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">(define (compose f g)
  (lambda (x)
    (f (g x))))

(define (square x)
  (* x x))

((compose square inc) 6)
;=&gt; (square (inc 6))
;=&gt; (square 7)
;=&gt; 49
</code></pre>
<h2 id="평가전략evaluation-strategy"><a class="header" href="#평가전략evaluation-strategy">평가전략(evaluation strategy)</a></h2>
<ul>
<li>Applicative-Order Evaluation</li>
<li>다른 이름: Call-by-Value, Eager Evaluation</li>
<li>인자를 먼저 평가하고 그 결과 값을 프로시저에 대입</li>
<li>Normal-Order Evaluation</li>
<li>다른 이름: Call-by-Name</li>
<li>인자를 평가하지 않고 그대로 본문에 대입 (문자 그대로 펼침)</li>
<li>Lazy Evaluation</li>
<li>다른 이름: Call-by-Need</li>
<li>Normal-Order와 비슷하지만 한 번 계산한 결과를 저장해서 다시 계산하는것을 방지(메모이제이션)</li>
</ul>
<h2 id="뉴턴-랩슨-방법으로-제곱근-찾기"><a class="header" href="#뉴턴-랩슨-방법으로-제곱근-찾기">뉴턴-랩슨 방법으로 제곱근 찾기</a></h2>
<ul>
<li>뉴턴-랩슨 방법( Newton-Raphson method )
<ul>
<li><a href="https://en.wikipedia.org/wiki/Newton%27s_method">https://en.wikipedia.org/wiki/Newton%27s_method</a></li>
<li>미분가능한 함수 f(a, b) → R에 대해 x에 대한 방정식 f(x)=0의 근의 근삿값을 구하는 알고리즘.</li>
<li>뉴턴: 1669년 무렵, 비선형 방정식을 푸는 반복법을 고안. 주로 기하학적 직관과 미분 개념을 활용.</li>
<li>랩슨: 1690년에 뉴턴 방법을 기하학 설명 없이 순수 대수 형태로 단순화해서 발표. 이 버전이 계산에 더 쓰기 좋아짐.</li>
</ul>
</li>
<li>뉴턴-랩슨 공식</li>
</ul>
<p>$$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} $$</p>
<h3 id="제곱근-구하기"><a class="header" href="#제곱근-구하기">제곱근 구하기</a></h3>
<p>$$ y {&gt;=} 0; 이고; y^2=x; 일때; \sqrt{x}는; y다.$$</p>
<p>$$ y \ge 0, \quad y^2 = S$$</p>
<ul>
<li>
<p>함수 정의
$$ f(x) = x^2 - S $$</p>
</li>
<li>
<p>미분
$$ f'(x) = 2x $$</p>
</li>
<li>
<p>공식에 대입
$$ x_{n+1} = x_n - \frac{x_n^2 - S}{2x_n} $$</p>
</li>
</ul>
<p>$$ x_{n+1} = \frac{2x_n^2 - x_n^2 + S}{2x_n} $$</p>
<p>$$ x_{n+1} = \frac{x_n^2 + S}{2x_n} $$</p>
<ul>
<li>최종 식
$$ x_{n+1} = \frac{1}{2} \left( x_n + \frac{S}{x_n} \right) $$</li>
</ul>
<pre><code class="language-lisp">;; 1.1.7 연습: 뉴튼 법으로 제곱근 찾기
;; 연습문제: 1_06, 1_07

(define (square x)
  (* x x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (~&gt; (+ x y) 
      (/ 2)))

(define (good-enough? guess x)
  (~&gt; (square guess)
      (- x)
      (abs)
      (&lt; 0.001)))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(sqrt 9)
;;=&gt; 3.00009155413138
</code></pre>
<hr />
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<p>ex 1.5 Applicative-Order Evaluation / lazy</p>
<p>1.17 뉴튼법 제곱근
ex 1.6 뉴튼 cont if 스페셜폼
ex 1.7 ** 뉴튼 cont good-enough 최적화
ex 1.8 뉴튼 cont 세제곱근(cube root) - ** 식이 나와있는데 원레 3제곱에서 유도하는법
1.3.4 - 뉴튼법 cont</p>
<p>1.2.1 재귀</p>
<ul>
<li>non-tail recursion / tail recursion</li>
<li>Primitive Recursive Function / or not
ex 1.9  일반 재귀 (non-tail recursion)와 꼬리 재귀 (tail recursion)
ex 1.10 에커만 함수 Primitive Recursive Function가 아닌  리커시브함수
ex 1.11 ** 꼬리 재귀 (tail recursion) 연습 심화
ex 1.12 파스칼 삼각형 recursion
ex 1.13 *** 증명  ;; φ = (1+√5)/2 // Fib(n) = (φ^n)/√5 피보나치 수열. 특성방정식. 황금비. Binet 공식. 귀납법(induction)</li>
</ul>
<p>expt 거듭제곱
GDC 유클리드
소수찾기 페르마 검사
연습문제
피보나치
하노이의 탑</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2장-데이터로-추상화-쌓기"><a class="header" href="#2장-데이터로-추상화-쌓기">2장. 데이터로 추상화 쌓기</a></h1>
<ul>
<li>
<p>Building Abstractions with Data</p>
<ul>
<li>2장은, 1장에서의 함수 뿐만 아니라 데이터도 추상화가 필요함을 설명한다.</li>
</ul>
</li>
<li>
<p>데이터 은닉 + 인터페이스 노출</p>
<ul>
<li>sicp: 클로저와 인터페이스 함수로 캡슐화 구현</li>
<li>OOP: 클래스와 접근 제한자로 캡슐화 구현</li>
</ul>
</li>
<li>
<p>데이터 저장 방식이 달라도 영향이 없음.</p>
<ul>
<li>어느 위치 한 점을
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8_%EC%A2%8C%ED%91%9C%EA%B3%84">데카르트 좌표계</a>로 저장하거나</li>
<li><a href="https://ko.wikipedia.org/wiki/%EA%B7%B9%EC%A2%8C%ED%91%9C%EA%B3%84">극 좌표계</a>로 저장.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="기본-1"><a class="header" href="#기본-1">기본</a></h2>
<h3 id="문법-1"><a class="header" href="#문법-1">문법</a></h3>
<pre><code class="language-lisp">;; ================
;; Cons Cell
(cons 1 2)
;;=&gt; (1 . 2)

(car '(1 . 2))          ; cons cell의 첫번째
;;=&gt; 1

(cdr '(1 . 2))          ; cons cell의 두번째
;;=&gt; 2

(pair? '(1 . 2))       ; cons cell로 구성되어 있는가?
;;=&gt; #t


;; ================
;; 리스트
(list 1 2 3)            ; '(1 . (2 . (3 . ())))
;;=&gt; (1 2 3)

(car '(1 2 3))
;;=&gt; 1

(cdr '(1 2 3))
;;=&gt; (2 3)

(cadr '(1 2 3))        ; cdr 이후 car
;;=&gt; 2

(pair? '(1 2 3))       ; list 역시 cons cell.
;;=&gt; #t

(length '(1 2))        ; 길이
;;=&gt; 2

(append '(1 2) '(3 4)) ; 덧붙이기
;;=&gt; (1 2 3 4)

(memq 'c '(a b c d))   ; 포함하는 맴버인지 확인
;;=&gt; (c d)
(memq 'c '(a b (c) d))
;;=&gt; #f


;; ================
;; 널
(null? nil)            ; nil은 null이다.
;;=&gt; #t
(null? '())            ; '() 빈것도 null이다.
;;=&gt; #t


;; ================
;; quote 평가 지연
(quote '(1 2 3))       ; 입력받은 표현식을 평가하지 않고 반환.
;;=&gt; '(1 2 3)


;; ================
;; 음수? / 0? / 양수?
(negative? -1)         ; 음수?
;;=&gt; #t

(zero? 0)              ; 0?
;;=&gt; #t

(positive? 1)          ; 양수?
;;=&gt; #t


;; ================
;; 동일한지 체크
(eq? nil '())          ; 같은 객체인가?
;;=&gt; #t
(eq? '(1 2) '(1 2))
;;=&gt; #f

(equal? '(1 2) '(1 2)) ; 구조가 같은가?
;;=&gt; #t

;; ================
;; association list(연관 리스트, alist)
(define a-alist '((apple . 100) (banana . 200))) ; '((key-a . value-a) (key-b . value-b) ... )
(assoc 'apple a-list)
;;=&gt;(apple . 100)                                ; (key-a . value-a)
</code></pre>
<h2 id="data-abstraction데이터-추상화"><a class="header" href="#data-abstraction데이터-추상화">Data Abstraction(데이터 추상화)</a></h2>
<ul>
<li>
<p>데이터를 <strong>어떻게 사용할지</strong> 만을 드러내는 기법.</p>
<ul>
<li><strong>어떻게 표현할지</strong>는 드러나지 않음.</li>
</ul>
</li>
<li>
<p>Constructor : 생성자</p>
<ul>
<li>데이터 객체를 만드는 함수.</li>
<li>ex) vector2</li>
</ul>
</li>
<li>
<p>Selector : 흔히 말하는 getter</p>
<ul>
<li>만들어진 데이터 객체에서 필드를 꺼내는 함수.</li>
<li>ex) vector2-x, vector2-y</li>
</ul>
</li>
</ul>
<h3 id="예제"><a class="header" href="#예제">예제</a></h3>
<ul>
<li>vector2 / vector2-x / vector2-y
<ul>
<li>데이터를 사용하는 방식은 유지한체</li>
<li>데이터를 표현하는 방식은 바뀔 수 있다.</li>
</ul>
</li>
</ul>
<pre><code class="language-lisp">;; v1 - cons cell을 이용한 방식

(define (vector2 x y)
  (cons x y))
(define (vector2-x p)
  (cons-item1 p))
(define (vector2-y p)
  (cons-item2 p))
  
(vector2 1 2)
;;=&gt; (1 . 2)
(vector2-x (vector2 1 2))
;;=&gt; 1
(vector2-y (vector2 1 2))
;;=&gt; 2
</code></pre>
<pre><code class="language-lisp">;; v2 - 리스트를 이용한 방식

(define (vector2 x y)
  (list x y))
(define (vector2-x p)
  (first p))
(define (vector2-y p)
  (second p))

(vector2 1 2)
;;=&gt; (1 2)
(vector2-x (vector2 1 2))
;;=&gt; 1
(vector2-y (vector2 1 2))
;;=&gt; 2
</code></pre>
<pre><code class="language-lisp">(cons (list 1 2) (list 3 4))
;;
;; (
;;   (1 . (2 . ())) . (3 . (4 . ()))
;; )
;; 
;; +---+---+   +---+---+    +---+---+
;; | ● | ●---&gt; | 3 | ●---&gt;  | 4 | ()|
;; +-|-+---+   +---+---+    +---+---+
;;   |             
;;   v             
;; +---+---+    +---+---+
;; | 1 | ●---&gt;  | 2 | ()|
;; +---+---+    +---+---+

</code></pre>
<hr />
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<p>복소수</p>
<p>연습문제 2.42 에잇퀸 퍼즐</p>
<p>2.2.4 연습 : 그림 언어
https://docs.racket-lang.org/sicp-manual/SICP_Picture_Language.html</p>
<pre><code class="language-lisp">#lang sicp
(#%require sicp-pict)
(paint einstein)
</code></pre>
<p>2.3.4 연습 : 허프만 인코딩 나무</p>
<p>2.4 요약된 데이터의 표현 방식이 여러 가지일 때
복소수를 직각좌표로도 극좌표로도 구현
2.4.1 복소수 표현
2.4.2 타입을 표시한 데이터
2.4.3 데이터 중심 프로그래밍과 덧붙임 성질</p>
<p>2.5 일반화된 연산 시스템
2.5.1 일반화된 산술 연산
2.5.2 타입이 다른 데이터를 엮어 쓰는 방법
2.5.3 연습 : 기호 식 대수</p>
<p>분수</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3장-모듈-객체-상태"><a class="header" href="#3장-모듈-객체-상태">3장. 모듈, 객체, 상태</a></h1>
<ul>
<li>
<p>Modularity, Objects, and State</p>
<ul>
<li>3장은, 상태를 도입하면 프로그램이 더 많은 것을 표현할 수 있지만, 그만큼 이해와 예측이 어려워지는 것을 설명.</li>
</ul>
</li>
<li>
<p>변하는 데이터와 시간의 흐름을 다룸.</p>
<ul>
<li>상태가 있는 시스템에서 시간과 동시성 문제는 필연적으로 등장.</li>
<li>상태를 안전하게 다루는 데에 있어 모듈성과 캡슐화는 필수.</li>
<li>지연 평가를 활용하면 무한 리스트나 신호 처리처럼 강력한 모델을 만들 수 있음.</li>
</ul>
</li>
</ul>
<h2 id="기본-2"><a class="header" href="#기본-2">기본</a></h2>
<h3 id="문법-2"><a class="header" href="#문법-2">문법</a></h3>
<pre><code class="language-lisp">;; ================
;; 셋팅

(set! a 10)
;;!&gt; set!: assignment disallowed;
;;!&gt; cannot set variable before its definition
;;!&gt;  variable: a

(define a 10)
(set! a 20)
a
;;=&gt; 20


(define a-cons (cons 1 2))
a-cons
;;=&gt; (1 . 2)
(set-car! a-cons 10)
(set-cdr! a-cons 20)
a-cons
;;=&gt; (10 . 20)


;; ================
;; begin 블록
(begin                 ; 블록 구문. 맨 마지막 표현식이 반환값.
  (display "Hello, ")
  (display "world!")
  (newline)
  42)
;;&gt;&gt; Hello, world!
;;=&gt; 42



cons-stream - (cons a (delay b))
delay - (delay exp)는 구문적 설탕입니다 .(lambda () exp)
force
</code></pre>
<h2 id="closure"><a class="header" href="#closure">Closure</a></h2>
<ul>
<li>함수가 정의될 때, 해당 함수가 속한 어휘적 환경(lexical environment) 에 대한 접근 권한을 유지하는 함수.</li>
</ul>
<pre><code class="language-lisp">(define (new-counter initial-value)
  (let ((curr (dec initial-value)))                        ; local state variable
    (lambda ()
      (set! curr (inc curr))
      curr)))

(define counter (new-counter 1))
counterx)
;;=&gt; 1
(counter)
;;=&gt; 2
(counter)
;;=&gt; 3

curr                                                        ; count-factory함수 밖에서는 curr접근 불가.
;;!&gt; . . curr: undefined;
 ;;!&gt; cannot reference an identifier before its definition
</code></pre>
<hr />
<h2 id="todo-2"><a class="header" href="#todo-2">TODO</a></h2>
<ul>
<li><a href="https://corecursive.com/039-hal-abelson-sicp/">Language Oriented Design - Discussing SICP with Hal Abelson</a>
<ul>
<li>클래스 같은 추상화나 다양한 객체를 클래스로 어떻게 구성하는지, 그리고 그 전체적인 구조는 어떻게 되는지에 대해서는 전혀 언급하지 않았습니다</li>
</ul>
</li>
</ul>
<p>3.3 변형 가능한 데이터로 프로그래밍하기
3.3.1 변형 가능한 리스트
3.3.2 큐
queue/deque
dictionary
memoization - fibonacci</p>
<ul>
<li>https://clojuredocs.org/clojure.core/memoize</li>
</ul>
<p>3.3.3 표
3.3.4 디지털 회로 시뮬레이터
3.3.5 관계 알리기(constraint propagation)</p>
<p>3.4 병행성竝行性 : 시간은 중요하다
은행의 출금을 예로들어
serializer</p>
<ul>
<li>자원을 공유하는 함수들 끼리 그룹을 묶어, 그 구룹내에 있는 함수들은 동시에 실행이 안되게 막음.</li>
<li>job queue같은걸 만들어 큐에 쌓고 순차적으로 실행.</li>
</ul>
<p>parallel-execute - https://stackoverflow.com/questions/13467753/implement-parallel-execute-in-scheme</p>
<ul>
<li>mutex(Mutual Exclusion Lock)락을 이용해서 재화를 건드리는 함수들에 락을 걸어버림.
<ul>
<li>하나의 쓰레드만 자원 접근 가능</li>
</ul>
</li>
</ul>
<p>3.5 스트림</p>
<ul>
<li>stream == lazy sequence
<ul>
<li>지연 평가(lazy evaluation)를 통해 필요할 때만 다음 요소를 계산하는 시퀀스를 뜻합니다.</li>
</ul>
</li>
<li>ref
<ul>
<li>https://clojuredocs.org/clojure.core/lazy-seq</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4장-메타언어적-추상화"><a class="header" href="#4장-메타언어적-추상화">4장. 메타언어적 추상화</a></h1>
<ul>
<li>Metalinguistic Abstraction
<ul>
<li>4장은, Lisp로 Lisp 인터프리터를 작성하며, 언어의 문법과 의미를 스스로 설계하는 능력을 배운다.</li>
<li>MIT OpenCourseWare
<ul>
<li><a href="https://www.youtube.com/watch?v=aAlR3cezPJg&amp;list=PLE18841CABEA24090">Lecture 7B: Metacircular Evaluator, Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=QVEOq5k6Xi0&amp;list=PLE18841CABEA24090">Lecture 7B: Metacircular Evaluator, Part 2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="chapter/../res/hand-write-hand.jpg" alt="" /></p>
<p>우리는 당면한 문제에 특히 적합한 [용어]를 사용하여 문제를 다른 방식으로 설명하고 (따라서 사고할 수 있도록) 복잡한 문제를 처리하는 능력을 향상시킬 수 있습니다</p>
<p>"우리가 지금 사용하고 있는 언어(Scheme)를 사용해서, 또 다른 언어의 규칙과 의미를 정의하거나 해석하는 것"
프로그래밍 언어를 직접 정의하고 확장하는 추상화 기법이다.</p>
<hr />
<h2 id="todo-3"><a class="header" href="#todo-3">TODO</a></h2>
<p>4.1 lisp로 lisp 인터프리터 만들기.</p>
<p>저자가 작성한 eval / apply / env / frame 설명
연습문제로 let / let* / letrec 확장을 볼 수 있다.
halt problem</p>
<p>4.2 normal-order evaluation</p>
<ul>
<li>3장에서 상태를 덮어쓰기 때문에 생겨나는 여러 복잡한 문제를 피하기 위해 스트림 데이터(lazy sequence)를 사용.</li>
<li>Scheme(혹은 Racket)은 스트림 프로그램을 짜기에 번거로운 점이 있다
4.3 nondeterministic computing
4.4 logic-programming - prolog같은 논리형 프로그래밍</li>
</ul>
<p>(list? '())
;;=&gt; #t
(pair? '())
;;=&gt; #f</p>
<h2 id="인터프리터와-컴파일러"><a class="header" href="#인터프리터와-컴파일러">인터프리터와 컴파일러</a></h2>
<ul>
<li>인터프리터: 표현식을 직접 실행</li>
<li>컴파일러: 고수준 표현식을 더 낮은 수준(예: 가상 머신 코드, 기계어)으로 변환하고 그것을 실행
<ul>
<li>단순한 인터프리터 대비 컴파일은 중복 평가 제거, 공통 하위 표현식 최적화 등이 가능.</li>
</ul>
</li>
</ul>
<h2 id="eval--apply"><a class="header" href="#eval--apply">Eval &amp; Apply</a></h2>
<p>4.1은 Eval과 Apply로 시작하게 된다.</p>
<p>코드가 길고 car/cdr/cadr/caddr ... 난리도 아니다.
다음을 정의하고 시작하자
(define first car)
(define rest  cdr)
(define second cadr)
(define third  caddr)</p>
<pre><code class="language-lisp">
;; ============================================================================
;; EVAL
;; ============================================================================

(define (eval exp env)
  (cond ((self-evaluating? exp)
         exp)
        ((variable? exp)
         (lookup-variable-value exp env))
        ((quoted? exp)
         (text-of-quotation exp))
        ((assignment? exp)
         (eval-assignment exp env))
        ((definition? exp)
         (eval-definition exp env))
        ((if? exp)
         (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp) (lambda-body exp) env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp)
         (eval (cond-&gt;if exp) env) )
        ((application? exp)
         (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
        (else
         (error "Unknown expresslon type -- EVAL" exp))))

(define (self-evaluating? exp) nil)
(define (variable? exp) nil)
(define (quoted? exp) nil)
(define (assignment? exp) nil)
(define (definition? exp) nil)
(define (if? exp) nil)
(define (lambda? exp) nil)
(define (begin? exp) nil)
(define (cond? exp) nil)
(define (application? exp) nil)

(define (lookup-variable-value exp env)nil)
(define (text-of-quotation exp) nil)

(define (eval-assignment exp env) nil)
(define (eval-definition exp env) nil)
(define (eval-if exp env) nil)
(define (eval-sequence exps env) nil)

(define (make-procedure exp1 exp2 env) nil)
(define (lambda-parameters exp) nil)
(define (lambda-body exp) nil)
(define (begin-actions exp) nil)
(define (cond-&gt;if exp) nil)
(define (operator exp) nil)
(define (list-of-values exps env) nil)
(define (operands exp) nil)

;; ============================================================================
;; APPLY
;; ============================================================================

(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- APPLY" procedure))))

(define (primitive-procedure? procedure) nil)
(define (compound-procedure? procedure) nil)
(define (apply-primitive-procedure procedure arguments) nil)
(define (procedure-body procedure) nil)
(define (extend-environment parameters arguments env) nil)
(define (procedure-parameters procedure) nil)
(define (procedure-environment procedure) nil)
</code></pre>
<h2 id="41"><a class="header" href="#41">4.1</a></h2>
<p>(eval environment expression)
(apply function function-arguments)</p>
<ol>
<li>언어를 처리하는 기법</li>
</ol>
<p>4.1 메타써큘러 실행기
4.1.1 언어 실행기의 알짜배기
eval / apply</p>
<p>4.1.2 식을 나타내는 방법
eval</p>
<p>(define (self-evaluating? exp) (or (number? exp) (string? exp)))
(define (variable?        exp) (symbol? exp))
(define (quoted?          exp) (tagged-list? exp 'quote))
(define (assignment?      exp) (tagged-list? exp 'set!))
(define (definition?      exp) (tagged-list? exp 'define))
(define (if?              exp) (tagged-list? exp 'if))
(define (lambda?          exp) (tagged-list? exp 'lambda))
(define (begin?           exp) (tagged-list? exp 'begin))
(define (cond?            exp) (tagged-list? exp 'cond))
(define (application?     exp) (pair? exp))</p>
<p>4.1.3 언어 실행기에서 쓰는 데이터 구조
평가기evaluator를 구현할 때는 프로그램의 외부 문법(external syntax)만 정의하는 것이 아니라
프로그램 실행 과정에서 평가기가 내부적으로 다루는 데이터 구조도 정의해야 함</p>
<p>참과 거짓
(define (true?  x) (eq? x true))
(define (false? x) (not (true? x)))</p>
<p>내장 함수 ( primitive-procedure // aka built-in-function )</p>
<p>(apply-primitive-procedure
(primitive-procedure?</p>
<p>환경(env)
(lookup-variable-value
(extend-environment
(define-variable!
(set-variable-value!</p>
<p>eval을 테스트하기 껄끄럽기에 연습문제 4.01 ~ 4.14는 4.1.4 Running the Evaluator as a Program 까지 읽고 풀기.</p>
<ul>
<li>개념
<ul>
<li>frame
<ul>
<li>((symbol-a symbol-b ...) value-a (primitive func-b) ...)</li>
<li>변수/함수이름 리스트 + 변수/함수들...</li>
<li>연습문제 4.11에서
<ul>
<li>'((변수/함수이름 변수/함수) ...) 식으로 바꿈</li>
<li>'((symbol-a value-a) (symbol-b (primitive func-b)) ...)</li>
</ul>
</li>
</ul>
</li>
<li>environment
<ul>
<li>(frame-a frame-b)</li>
<li>프레임 리스트</li>
<li>(cons new-frame env)</li>
<li>(cons 'b '(a)) =&gt; (b a) 새로운 frame이 앞에오는 구조</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4.1.4 언어 실행기를 보통 프로그램처럼 돌려보기</p>
<p>set-car!
set-cdr!</p>
<p>(define (setup-environment)
(let ((initial-env
(extend-environment (primitive-procedure-names)
(primitive-procedure-objects)
the-empty-environment)))
(define-variable! 'true true initial-env)
(define-variable! 'false false initial-env)
initial-env))</p>
<p>연습 4.13 ** 문제 make-unbound! 함수를 만들어 env에서 지울 수 있도록 만들자. first-frame에서만 지우면 되는가?</p>
<p>4.1.5 Data as Programs 프로그램도 데이터처럼</p>
<p>6 =&gt; factorial =&gt; 720
The factorial program, viewed as an abstract machine.
6 =&gt; evaluator =&gt; 720
evaluator as a very special machine</p>
<p>evaluator is seen to be a universal machine.</p>
<ul>
<li>A Universal Turing machine, often just called a universal machine, is an abstract computational device that can simulate other computational devices.</li>
<li>UTM https://en.wikipedia.org/wiki/Universal_Turing_machine</li>
</ul>
<p>단순하고 자명한 것에서 복잡한것이 나오게 된다.</p>
<p>GEB( <code>G</code>ödel, <code>E</code>scher, <code>B</code>ach: an Eternal Golden Braid )
괴델, 에셔, 바흐: 영원한 황금 노끈
https://de.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach</p>
<p>recursion theory ( Computability theory ) "무엇이 계산 가능하고, 무엇이 절대 계산 불가능한가?"
https://en.wikipedia.org/wiki/Computability_theory</p>
<p>연습 4.15 ** Halting Problem</p>
<p>4.1.6 안쪽 정의(internal definition)</p>
<p>c언어의 전방선언과 비슷한 느낌.</p>
<p>선언과 할당을 동시에 할때 생기는 문제
let을 써서(frame 을 하나 더 써서) 풀어보고
선언 먼저 <code>'*unassigned*</code>로 공간을 만들어주고 그 다음 할당.</p>
<p>연습문제 4.17 - frame을 쓰지 않고 풀어보고</p>
<p>연습문제 4.19 ** Sequential Scope Simultaneous Scope lazy evaluation
연습문제 4.21 ** Z combinator - lambda calculus</p>
<p>4.1.7 문법 분석과 실행 과정을 떼어놓기</p>
<ul>
<li>eval시 analyze과정을 넣어 최적화</li>
</ul>
<hr />
<p>4.2 Scheme 바꿔보기 - 제때 계산법</p>
<p>lazy evaluation &lt;=&gt; eager evaluation</p>
<p>(define (try a b)
(if (= a 0)
1
b))</p>
<p>(try 0 (/ 1 0))
;=&gt; 1                   // lazy  evaluation
;!&gt; /: division by zero // eager evaluation</p>
<p>4.2.1 식의 값을 구하는 차례 - 정의대로 계산법과 인자 먼저 계산법
4.2.2 제때 계산법을 따르는 실행기
4.2.3 제때셈 리스트와 스트림</p>
<hr />
<p>4.3 Scheme 바꿔보기 - 비결정적 계산
4.3.1 amb와 찾기
4.3.2 비결정적 프로그램 짜기
4.3.3 amb 실행기 구현</p>
<hr />
<p>4.4 논리로 프로그램 짜기
4.4.1 연역식 정보 찾기
4.4.2 쿼리 시스템의 동작 방식
4.4.3 논리 프로그래밍은 수학 논리를 따르는가?
4.4.4 쿼리 시스템 만들기
4.4.4.1 드라이버 루프와 쿼리 값 찍어내기(instantiation)
4.4.4.2 실행기(evaluator)
4.4.4.3 패턴 매칭으로 참말 찾아내기
4.4.4.4 규칙과 동일화
4.4.4.5 데이터베이스의 관리
4.4.4.6 스트림 연산
4.4.4.7 쿼리의 문법을 처리하는 프로시저
4.4.4.8 일람표와 정의</p>
<p>4.01 cons left right
4.02 application? 위치
4.03 data-directed style
4.04 and? or? 추가</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5장-레지스터-머신으로-계산"><a class="header" href="#5장-레지스터-머신으로-계산">5장. 레지스터 머신으로 계산</a></h1>
<hr />
<h2 id="todo-4"><a class="header" href="#todo-4">TODO</a></h2>
<ul>
<li>Computing with Register Machines
<ul>
<li>5장은, 레지스터 머신과 가비지 컬렉터 그리고 컴파일러를 구현한다.</li>
</ul>
</li>
</ul>
<ol>
<li>레지스터 기계로 계산하기</li>
</ol>
<p>5.1 레지스터 기계 설계하기
5.1.1 레지스터 기계를 묘사하는 언어
5.1.2 기계 디자인에서의 속 내용 감추기(abstraction)
5.1.3 서브루틴
5.1.4 스택(stack)을 이용해 되돌기(recursion) 구현하기
5.1.5 명령어 정리</p>
<p>5.2 레지스터 기계 시뮬레이터
5.2.1 기계 모형
5.2.2 어셈블러
5.2.3 명령에 해당하는 실행 프로시저 만들기
5.2.4 기계 성능 지켜보기</p>
<p>5.3 메모리 할당(memory allocation)과 재활용(garbage collection)
5.3.1 벡터로 나타낸 메모리
5.3.2 무한히 많은 메모리인 양 보이기</p>
<p>5.4 제어가 다 보이는 실행기
5.4.1 제어가 다 보이는 실행기의 핵심부
5.4.2 시퀀스 계산과 꼬리 되돌기(tail recursion)
5.4.3 조건 식, 덮어쓰기(assignment), 정의
5.4.4 실행기 돌리기</p>
<p>5.5 번역(compilation)
5.5.1 번역기의 구조
5.5.2 프로그램 식의 번역
5.5.3 조합 식 번역하기
5.5.4 명령줄 한데 합치기
5.5.5 번역된 코드의 예
5.5.6 텍스트에서 변수의 정의를 파악하기(lexical addressing)
5.5.7 번역된 코드를 실행기에 연결하기</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="풀이"><a class="header" href="#풀이">풀이</a></h1>
<h2 id="chapter-1---building-abstractions-with-procedures"><a class="header" href="#chapter-1---building-abstractions-with-procedures">Chapter 1 - Building Abstractions with Procedures</a></h2>
<h3 id="11--the-elements-of-programming"><a class="header" href="#11--the-elements-of-programming">1.1 – The Elements of Programming</a></h3>
<p>1.01	1.02	1.03	1.04	1.05	1.06	1.07	1.08	–	–</p>
<h3 id="12--procedures-and-the-processes-they-generate"><a class="header" href="#12--procedures-and-the-processes-they-generate">1.2 – Procedures and the Processes They Generate</a></h3>
<p>1.09	1.10	1.11	1.12	1.13	1.14	1.15	1.16	1.17	1.18
1.19	1.20	1.21	1.22	1.23	1.24	1.25	1.26	1.27	1.28</p>
<h3 id="13--formulating-abstractions-with-higher-order-procedures"><a class="header" href="#13--formulating-abstractions-with-higher-order-procedures">1.3 – Formulating Abstractions with Higher-Order Procedures</a></h3>
<p>1.29	1.30	1.31	1.32	1.33	1.34	1.35	1.36	1.37	1.38
1.39	1.40	1.41	1.42	1.43	1.44	1.45	1.46	–	–</p>
<h2 id="chapter-2---building-abstractions-with-data"><a class="header" href="#chapter-2---building-abstractions-with-data">Chapter 2 - Building Abstractions with Data</a></h2>
<h3 id="21--introduction-to-data-abstraction"><a class="header" href="#21--introduction-to-data-abstraction">2.1 – Introduction to Data Abstraction</a></h3>
<p>2.01	2.02	2.03	2.04	2.05	2.06	2.07	2.08	2.09	2.10
2.11	2.12	2.13	2.14	2.15	2.16	–	–	–	–</p>
<h3 id="22--hierarchical-data-and-the-closure-property"><a class="header" href="#22--hierarchical-data-and-the-closure-property">2.2 – Hierarchical Data and the Closure Property</a></h3>
<p>2.17	2.18	2.19	2.20	2.21	2.22	2.23	2.24	2.25	2.26
2.27	2.28	2.29	2.30	2.31	2.32	2.33	2.34	2.35	2.36
2.37	2.38	2.39	2.40	2.41	2.42	2.43	2.44	2.45	2.46
2.47	2.48	2.49	2.50	2.51	2.52	–	–	–	–</p>
<h3 id="23--symbolic-data"><a class="header" href="#23--symbolic-data">2.3 – Symbolic Data</a></h3>
<p>2.53	2.54	2.55	2.56	2.57	2.58	2.59	2.60	2.61	2.62
2.63	2.64	2.65	2.66	2.67	2.68	2.69	2.70	2.71	2.72</p>
<h3 id="24--multiple-representations-for-abstract-data"><a class="header" href="#24--multiple-representations-for-abstract-data">2.4 – Multiple Representations for Abstract Data</a></h3>
<p>2.73	2.74	2.75	2.76	–	–	–	–	–	–</p>
<h3 id="25--systems-with-generic-operations"><a class="header" href="#25--systems-with-generic-operations">2.5 – Systems with Generic Operations</a></h3>
<p>2.77	2.78	2.79	2.80	2.81	2.82	2.83	2.84	2.85	2.86
2.87	2.88	2.89	2.90	2.91	2.92	2.93	2.94	2.95	2.96
2.97	–	–	–	–	–	–	–	–	–</p>
<h2 id="chapter-3---modularity-objects-and-state"><a class="header" href="#chapter-3---modularity-objects-and-state">Chapter 3 - Modularity, Objects, and State</a></h2>
<h3 id="31--assignment-and-local-state"><a class="header" href="#31--assignment-and-local-state">3.1 – Assignment and Local State</a></h3>
<p>3.01	3.02	3.03	3.04	3.05	3.06	3.07	3.08	–	–</p>
<h3 id="32--the-environment-model-of-evaluation"><a class="header" href="#32--the-environment-model-of-evaluation">3.2 – The Environment Model of Evaluation</a></h3>
<p>3.09	3.10	3.11	–	–	–	–	–	–	–</p>
<h3 id="33--modeling-with-mutable-data"><a class="header" href="#33--modeling-with-mutable-data">3.3 – Modeling with Mutable Data</a></h3>
<p>3.12	3.13	3.14	3.15	3.16	3.17	3.18	3.19	3.20	3.21
3.22	3.23	3.24	3.25	3.26	3.27	3.28	3.29	3.30	3.31
3.32	3.33	3.34	3.35	3.36	3.37	–	–	–	–</p>
<h3 id="34--concurrency-time-is-of-the-essence"><a class="header" href="#34--concurrency-time-is-of-the-essence">3.4 – Concurrency: Time Is of the Essence</a></h3>
<p>3.38	3.39	3.40	3.41	3.42	3.43	3.44	3.45	3.46	3.47
3.48	3.49	–	–	–	–	–	–	–	–</p>
<h3 id="35--streams"><a class="header" href="#35--streams">3.5 – Streams</a></h3>
<p>3.50	3.51	3.52	3.53	3.54	3.55	3.56	3.57	3.58	3.59
3.60	3.61	3.62	3.63	3.64	3.65	3.66	3.67	3.68	3.69
3.70	3.71	3.72	3.73	3.74	3.75	3.76	3.77	3.78	3.79
3.80	3.81	3.82	–	–	–	–	–	–	–</p>
<h2 id="chapter-4---metalinguistic-abstraction"><a class="header" href="#chapter-4---metalinguistic-abstraction">Chapter 4 - Metalinguistic Abstraction</a></h2>
<h3 id="41--the-metacircular-evaluator"><a class="header" href="#41--the-metacircular-evaluator">4.1 – The Metacircular Evaluator</a></h3>
<p>4.01	4.02	4.03	4.04	4.05	4.06	4.07	4.08	4.09	4.10
4.11	4.12	4.13	4.14	4.15	4.16	4.17	4.18	4.19	4.20
4.21	4.22	4.23	4.24	–	–	–	–	–	–</p>
<h3 id="42--variations-on-a-scheme--lazy-evaluation"><a class="header" href="#42--variations-on-a-scheme--lazy-evaluation">4.2 – Variations on a Scheme – Lazy Evaluation</a></h3>
<p>4.25	4.26	4.27	4.28	4.29	4.30	4.31	4.32	4.33	4.34</p>
<h3 id="43--variations-on-a-scheme--nondeterministic-computing"><a class="header" href="#43--variations-on-a-scheme--nondeterministic-computing">4.3 – Variations on a Scheme – Nondeterministic Computing</a></h3>
<p>4.35	4.36	4.37	4.38	4.39	4.40	4.41	4.42	4.43	4.44
4.45	4.46	4.47	4.48	4.49	4.50	4.51	4.52	4.53	4.54</p>
<h3 id="44--logic-programming"><a class="header" href="#44--logic-programming">4.4 – Logic Programming</a></h3>
<p>4.55	4.56	4.57	4.58	4.59	4.60	4.61	4.62	4.63	4.64
4.65	4.66	4.67	4.68	4.69	4.70	4.71	4.72	4.73	4.74
4.75	4.76	4.77	4.78	4.79	–	–	–	–	–</p>
<h2 id="chapter-5---computing-with-register-machines"><a class="header" href="#chapter-5---computing-with-register-machines">Chapter 5 - Computing with Register Machines</a></h2>
<h3 id="51--designing-register-machines"><a class="header" href="#51--designing-register-machines">5.1 – Designing Register Machines</a></h3>
<p>5.01	5.02	5.03	5.04	5.05	5.06	–	–	–	–</p>
<h3 id="52--a-register-machine-simulator"><a class="header" href="#52--a-register-machine-simulator">5.2 – A Register-Machine Simulator</a></h3>
<p>5.07	5.08	5.09	5.10	5.11	5.12	5.13	5.14	5.15	5.16
5.17	5.18	5.19	–	–	–	–	–	–	–</p>
<h3 id="53--storage-allocation-and-garbage-collection"><a class="header" href="#53--storage-allocation-and-garbage-collection">5.3 – Storage Allocation and Garbage Collection</a></h3>
<p>5.20	5.21	5.22	–	–	–	–	–	–	–</p>
<h3 id="54--the-explicit-control-evaluator"><a class="header" href="#54--the-explicit-control-evaluator">5.4 – The Explicit-Control Evaluator</a></h3>
<p>5.23	5.24	5.25	5.26	5.27	5.28	5.29	5.30	–	–</p>
<h3 id="55--compilation"><a class="header" href="#55--compilation">5.5 – Compilation</a></h3>
<p>5.31	5.32	5.33	5.34	5.35	5.36	5.37	5.38	5.39	5.40
5.41	5.42	5.43	5.44	5.45	5.46	5.47	5.48	5.49	5.50
5.51	5.52	–	–	–	–	–	–</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="연습문제-풀이-01"><a class="header" href="#연습문제-풀이-01">연습문제 풀이 01</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_01">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_01</a></li>
</ul>
<h2 id="1_01"><a class="header" href="#1_01">1_01</a></h2>
<pre><code class="language-lisp">;; file: 1_01.rkt

10
;;=&gt; 10
 
(+ 5 3 4)
;;=&gt; 12
 
(- 9 1)
;;=&gt; 8
 
(/ 6 2)
;;=&gt; 3
 
(+ (* 2 4) (- 4 6))
;;=&gt; 6


;; ===========================================

(define a 3)
(define b (+ a 1))

(+ a b (* a b))
;;=&gt; 19
 
(= a b)
;;=&gt; #f
 
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
;;=&gt; 4
 

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
;;=&gt; 16

(+ 2 (if (&gt; b a)
         b
         a))
;;=&gt; 6

(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
;;=&gt; 16
</code></pre>
<h2 id="1_02"><a class="header" href="#1_02">1_02</a></h2>
<p>$$\frac{5 + 4 + (2 - (3 - (6 + 4/5)))}{3(6 - 2)(2 - 7)}$$</p>
<pre><code class="language-lisp">;; file: 1_02.rkt

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
;;=&gt; -37/150
</code></pre>
<h2 id="1_03"><a class="header" href="#1_03">1_03</a></h2>
<pre><code class="language-lisp">;; file: 1_03.rkt

(#%require rackunit)
(#%require threading)
(#%require "../allcode/helper/my-util.rkt")

;; a, b, c 를 인자로 받고 가장 큰 두 수의 제곱의 합
;; 1.1.4에 나온 sum-of-squares 사용.

(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (ex1-03 a b c)
  (cond ((and (&lt; a b) (&lt; a c))
         (sum-of-squares b c))
        ((&lt; b c)
         (sum-of-squares a c))
        (else
         (sum-of-squares a b))))
  
(check-equal? (ex1-03 2 10 3) 109)


;; ======================================================================================
;; 번외. sequcne(list)와 고차함수를(filter/sort/take)  이용한 방법.

(define (filter pred? sequence)
  (cond ((null? sequence) '())
        ((pred? (first sequence))
         (cons (first sequence) (filter pred? (rest sequence))))
        (else
         (filter pred? (rest sequence)))))

(define (sort less-than? lst)
  (if (or (null? lst) (null? (rest lst)))
      lst
      (let* ((pivot (first lst))
             (rest (rest lst))
             (smaller (filter (lambda (x) (less-than? x pivot)) rest))
             (greater-equal (filter (lambda (x) (not (less-than? x pivot))) rest)))
        (append (sort less-than? smaller)
                (cons pivot (sort less-than? greater-equal))))))

(define (take n sequence)
  (cond ((&lt;= n 0) '())
        ((null? sequence) '())
        (else (cons (first sequence)
                    (take (- n 1) (rest sequence))))))

(define (largest-squares n xs)
  (~&gt;&gt; xs
       (sort &gt;)
       (take n)
       (map (lambda (x) (* x x)))
       (apply +)))


(check-equal? (largest-squares 2 '(2 10 3)) 109)
</code></pre>
<h2 id="1_04"><a class="header" href="#1_04">1_04</a></h2>
<pre><code class="language-lisp">;; file: 1_04.rkt

(define (a-plus-abs-b a b)
  ((if (&gt; b 0)
       +
       -)
   a b))


(a-plus-abs-b 2 7)
;;=&gt; 9

(a-plus-abs-b 2 -7)
;;=&gt; 9


(a-plus-abs-b -2 7)
;;=&gt; 5

(a-plus-abs-b -2 -7)
;;=&gt; 5
</code></pre>
<h2 id="1_05"><a class="header" href="#1_05">1_05</a></h2>
<pre><code class="language-lisp">;; file: 1_05.rkt

(define (p)
  (p))
(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))
;;=&gt; 0

;; #lang sicp 라면 y로 들어온 (p)가 무한히 호출됨.
;; #lang lazy 라면 y를 평가하지 않아 0이 반환.
;; #lang lazy는 엄밀히 말하면 Lazy Evaluation인데 normal-order evaluation에 캐쉬를 단거라 생각하면됨.

</code></pre>
<h2 id="1_06"><a class="header" href="#1_06">1_06</a></h2>
<pre><code class="language-lisp">;; file: 1_06.rkt
(#%require threading)

;; 1.1.7 연습: 뉴튼 법으로 제곱근 찾기

(define (square x)
  (* x x))

#;(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (~&gt; (+ x y) 
      (/ 2)))

(define (good-enough? guess x)
  (~&gt; (square guess)
      (- x)
      (abs)
      (&lt; 0.001)))

(define (sqrt x)
  (sqrt-iter 1.0 x))

;; ref: https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29
;;
;; (if test-expr
;;     then-expr
;;     else-expr)
;; 
;; if는 Special form으로 predicate를 수행후 then이나 else를 수행한다.
;;
;; 하지만 new-if는 함수인데, Applicative-Order evaluation에서의 함수는 인자를 다 평가시켜버려서,
;; (sqrt-iter (improve guess x) x) 도 계속 실행시켜버려 메모리가 부족해져버린다.

(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))

(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))

;; #lang sicp에서는 Applicative-Order Evaluation이기에
(sqrt 9)
;;!&gt; . Interactions disabled; out of memory

;; #lang lazy에서는 Lazy Evaluation이기에
(sqrt 9)
;;=&gt; 3.00009155413138
</code></pre>
<h2 id="1_07"><a class="header" href="#1_07">1_07</a></h2>
<pre><code class="language-lisp">;; file: 1_07.rkt
(#%require threading)
(#%require (prefix racket: racket))
(#%require rackunit)

;; 1.1.7 연습: 뉴튼 법으로 제곱근 찾기

(define (square x)
  (* x x))

#;(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (~&gt; (+ x y) 
      (/ 2)))

#;(define (good-enough? guess x)
    (~&gt; (square guess)
        (- x)
        (abs)
        (&lt; 0.001)))

(define (sqrt x)
  (sqrt-iter 1.0 x))


;; ========================================
;; 중요한거. 번역판을 읽으면 이 문제를 풀기 어려워진다.
;; 원문을 읽어야 이 문제를 보다 풀기가 쉬워진다.
;;
;; An alternative strategy for implementing good-enough? is to watch how guess changes from one iteration to the next
;; and to stop when the change is a very small fraction of the guess.
;; 반복할 때마다 `guess`의 **변화량**를 살펴보고,
;; `guess`에 **변화량**이 **아주 작은** 비율이 되었을 때 멈추는 것이다.
(define DECIMAL-EPSILON
  (let loop ([e 1.0])
    (if (= (+ 1.0 e) 1.0)
        (* 2 e)
        (loop (/ e 2)))))

(define VERY-SMALL-RADIO DECIMAL-EPSILON)
;; (define VERY-SMALL-RADIO 0.00000000001)

VERY-SMALL-RADIO
;;=&gt; 2.220446049250313e-16

(define (good-enough? guess next-guess)
  (let ((diff (- guess next-guess)))
    (~&gt; (/ diff next-guess)
        (abs)
        (&lt; VERY-SMALL-RADIO))))

(define (sqrt-iter guess x)
  (let ((next-guess (improve guess x)))
    (if (good-enough? guess next-guess)
        guess
        (sqrt-iter next-guess x))))

;; 아주 큰 수의 제곱근을 잘 구하는가?
;; 아주 작은 수 의 제곱근을 잘 구하는가?
(define COMPARE-EPSILON 0.00000001)
(check-= (sqrt 0.00000000123456) (racket:sqrt 0.00000000123456) COMPARE-EPSILON)
(check-= (sqrt 123456789012345) (racket:sqrt 123456789012345) COMPARE-EPSILON)


;; ref: https://sicp-solutions.net/post/sicp-solution-exercise-1-7/
</code></pre>
<h2 id="1_08"><a class="header" href="#1_08">1_08</a></h2>
<p>$$
\text{목표: } y = \sqrt[3]{x}
$$</p>
<p>$$
\text{⇒ 양변을 세제곱: } y^3 = x
$$</p>
<p>$$
\text{⇒ 함수로 표현: } f(y) = y^3 - x
$$</p>
<p>$$
\text{⇒ 도함수: } f'(y) = 3y^2
$$</p>
<p>$$
\text{⇒ 뉴튼 방법 일반식: } y_{n+1} = y_n - \frac{f(y_n)}{f'(y_n)}
$$</p>
<p>$$
\text{⇒ 대입: } y_{n+1} = y_n - \frac{y_n^3 - x}{3y_n^2}
$$</p>
<p>$$
= y_n - \frac{1}{3} \left( y_n - \frac{x}{y_n^2} \right)
$$</p>
<p>$$
= \frac{2y_n + \frac{x}{y_n^2}}{3}
$$</p>
<p>$$
\therefore \boxed{
y_{n+1} = \frac{x/y_n^2 + 2y_n}{3}
}
$$</p>
<pre><code class="language-lisp">;; file: 1_08.rkt
(#%require threading)
(#%require rackunit)

;; imporve 가 바뀌고 나머지는sqrt를 구할때와 거의 비슷한 흐름으로 흘러간다.
(define (improve guess x)
  "( x/y^2 + 2y ) / 3"
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))

(define VERY-SMALL-RADIO 0.00000000001)

(define (good-enough? guess next-guess)
  (let ((diff (- guess next-guess)))
    (~&gt; (/ diff next-guess)
        (abs)
        (&lt; VERY-SMALL-RADIO))))


(define (cube-root-iter guess x)
  (let ((next-guess (improve guess x)))
    (if (good-enough? guess next-guess)
        guess
        (cube-root-iter next-guess x))))

(define (cube-root x)
  (cube-root-iter 1.0 x))

(define (cube x)
  (* x x x))

(define COMPARE-EPSILON 0.00000001)
(check-= 12345 (cube (cube-root 12345)) COMPARE-EPSILON)
</code></pre>
<h2 id="1_09"><a class="header" href="#1_09">1_09</a></h2>
<pre><code class="language-lisp">;; file: 1_09.rkt
(#%require (prefix trace: racket/trace))

(define (x+ a b)
  (if (= a 0)
      b
      (inc (x+ (dec a) b))))

;; (x+ 2 1)
;; (inc (x+ 1 1))
;; (inc (inc (x+ 0 1)))
;; (inc (inc 1))
;; (inc 2)
;;=&gt; 3

(define (y+ a b)
  (if (= a 0)
      b
      (y+ (dec a) (inc b))))

;; (y+ 2 1)
;; (y+ 1 2))
;; (y+ 0 3)
;;=&gt; 3

(trace:trace x+)
(trace:trace y+)

(display "x+ ==============================\n")
(x+ 2 1)
;;&gt;&gt; &gt;{x+ 2 1}
;;&gt;&gt; &gt; {x+ 1 1}
;;&gt;&gt; &gt; &gt;{x+ 0 1}
;;&gt;&gt; &lt; &lt;1
;;&gt;&gt; &lt; 2
;;&gt;&gt; &lt;3
;;=&gt; 3
(display "y+ ==============================\n")
(y+ 2 1)
;;&gt;&gt; &gt;{y+ 2 1}
;;&gt;&gt; &gt;{y+ 1 2}
;;&gt;&gt; &gt;{y+ 0 3}
;;&gt;&gt; &lt;3
;;=&gt; 3
</code></pre>
<h2 id="1_10"><a class="header" href="#1_10">1_10</a></h2>
<pre><code class="language-lisp">;; file: 1_10.rkt
(#%require (prefix trace: racket/trace))

(define (A x y)
  ;; A(x, 0) = 0
  ;; A(0, y) = 2y
  ;; A(x, 1) = 2
  ;; A(x, y) = A(x-1, A(x, y-1))
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else   (A (- x 1) (A x (- y 1))))))

(A 1 10)
;;=&gt; 1024
(A 2 4)
;;=&gt; 65536
(A 3 3)
;;=&gt; 65536
(A 4 2)
;;=&gt; 4


(define (f n) (A 0 n))
;; A(0, y) = 2y
;; f(n) = 2n

(define (g n) (A 1 n))
;; A(1, n-0)
;; = 2 * A(1, n-1)
;; = 2 * 2 * A(1, n-2)
;; = 2 * 2 * ... * A(1, n-(n- 1))
;; = 2 * 2 * ... * 2
;; g(n) = 2^n

(define (h n) (A 2 n))
;; 2^2^2 or 2^h(n-1)
;; A(2, n - 0)
;; = A(1, A(2, n-1))
;; = A(1, A(1, A(2, n-2))
;; = A(1, A(1, A(1, ... A(1, A(2, n-(n-1))))
;; h(n) = 2^2^2....2 (2의 갯수는 n개)
;; h(n) = pow(2, h(n-1))

(define (k n) (* 5 n n))
;; k(n) = 5n^2


;; Primitive Recursive Function = 반복 횟수가 미리 정해져 있어서 for문 같은 단순 반복으로 구현 가능 (factorial같은거)
;; Ackermann은 'for' 문 같은 구조로는 표현할 수 없는 함수도 있다는걸 보여주기 위해 Ackermann함수를 만듬.
;; 재귀 깊이가 입력값에 따라 아주 빠르게 늘어나서, 고정된 반복 횟수로 미리 제한하는 'for'문으로는 표현하기 힘듬.
;;
;; ref:
;;   - https://en.wikipedia.org/wiki/Ackermann_function
;;   - https://plato.stanford.edu/Entries/recursive-functions/ackermann-peter.html
;;   - https://sites.google.com/site/pointlesslargenumberstuff/home/2/ackermann

;; Ackermann original function
(define (φ x y z)
  ;; φ(x, y, 0) = x + y
  ;; φ(x, 0, z) = α(x, z-1)
  ;; φ(x, y, z) = φ(x, φ(x, y-1, z) z-1)
  (cond ((= z 0) (+ x y))
        ((= y 0) (α x (- z 1)))
        (else    (φ x (φ x (- y 1) z) (- z 1)))))

(define (α x y)
  ;; α(x, 0) = 0
  ;; α(x, 1) = 1
  ;; α(x, y) = x
  (cond ((= y 0) 0)
        ((= y 1) 1)
        (else    x)))

;; Ackermann-Peter function
(define (C m n)
  ;; C(0, n) = n+1
  ;; C(m, 0) = C(m-1, 1)
  ;; C(m, n) = C(m-1, C(m, n-1))
  (cond ((= m 0) (+ n 1))
        ((= n 0) (C (- m 1) 1))
        (else    (C (- m 1) (C m (- n 1))))))

(trace:trace φ)
(trace:trace C)
(φ 1 2 3)
(C 2 1)
</code></pre>
<h2 id="1_11"><a class="header" href="#1_11">1_11</a></h2>
<pre><code class="language-lisp">;; file: 1_11.rkt
(#%require (prefix racket: racket))
(#%require rackunit)

;; n &lt;  3 : f(n) = n                        
;; n &gt;= 3 : f(n) = f(n-1) + 2f(n-2) + 3f(n-3)   

(define (f-recur n)
  (cond ((&lt; n 3) n)
        (else    (+ (f-recur (- n 1))
                    (* 2 (f-recur (- n 2)))
                    (* 3 (f-recur (- n 3)))))))



;;      |  p1    |   p2    |   p3   |
;; f(n) = f(n-1) + 2f(n-2) + 3f(n-3)
;; ...
;; f(4) = f(3) + 2f(2) + 3f(1) = (2 + 2*1 + 3*0) + 2*2 + 3*1 = 11
;; f(3) = f(2) + 2f(1) + 3f(0) =  2              + 2*1 + 3*0 = 4
;; f(2) = 2
;; f(1) = 1
;; f(0) = 0

(define (iter curr-n target-n fn-1 fn-2 fn-3)
  (let ((next-fn-1 (+ fn-1 (* 2 fn-2) (* 3 fn-3)))
        (next-fn-2 fn-1)
        (next-fn-3 fn-2))
    (if (= curr-n target-n)
        next-fn-1
        (iter (inc curr-n) target-n next-fn-1 next-fn-2 next-fn-3))))

(define (f-iter n)
  (if (&lt; n 3)
      n
      (iter 3 n 2 1 0)))

(racket:for ([i 20])
            (check-eq? (f-recur i)(f-iter i)))
</code></pre>
<h2 id="1_12"><a class="header" href="#1_12">1_12</a></h2>
<pre><code class="language-lisp">;; file: 1_12.rkt
(#%require (prefix racket: racket))

;; 파스칼 삼각형

(define (P x y)
  (cond ((zero? x) 1)
        ((= x y)   1)
        (else      (+ (P (- x 1) y)
                      (P (- x 1) (- y 1))))))


(racket:for ([y (racket:in-inclusive-range 0 5)])
            (display y)
            (display ": ")
            (racket:for ([x (racket:in-inclusive-range 0 y)])
                        (display (P x y))
                        (display " "))
            (newline))
;;&gt;&gt; 0: 1 
;;&gt;&gt; 1: 1 1 
;;&gt;&gt; 2: 1 2 1 
;;&gt;&gt; 3: 1 2 4 1 
;;&gt;&gt; 4: 1 2 4 8 1 
;;&gt;&gt; 5: 1 2 4 8 16 1 
</code></pre>
<h2 id="1_13"><a class="header" href="#1_13">1_13</a></h2>
<pre><code class="language-lisp">;; file: 1_13.rkt

(#%require (prefix racket: racket))
(#%require threading)
(#%require rackunit)

;; ==============================================================
;; - 특성방정식(Characteristic equation)
;;   - https://en.wikipedia.org/wiki/Characteristic_equation_(calculus)
;;   - 선형 점화식의 일반해를 구하기 위해 도입하는 보조적인 다항방정식
;;     - 즉, 쉽게 구할 수 있는걸로 바꿔 계산하자임.
;;   - 제약조건
;;     - 선형(linear)
;;       - 곱하기, 더하기만 있음.(항들 사이에 곱하거나 제곱하지 않음)
;;       - 안되는 경우: F(n)=F(n−1)*F(n−2) (항 들 사이에 곱했음)
;;     - 상수 계수(with constant coefficients)
;;       - 계수들이 모두 상수여야 함 (즉, n에 따라 변하면 안 됨)
;;       - 안되는 경우: F(n)=n*F(n−1)+F(n−2) (n에 따라 변함)
;;     - 동차(homogeneous)
;;       - 오른쪽에 독립적인 항이 없음
;;       - 안되는 경우: F(n)=F(n−1)+F(n−2)+1 (오른쪽에 상수, n, 2^n, +5 같은 추가적인 항이 붙어 있으면 비동차)
;; - 근의 공식(quadratic equation)
;;   - https://en.wikipedia.org/wiki/Quadratic_equation
;; - (1+√5)/2
;;   - 황금비(golden ratio): https://en.wikipedia.org/wiki/Golden_ratio
;; - 비넷공식(binet formula)
;;   - https://en.wikipedia.org/wiki/Fibonacci_sequence#Binet's_formula
;; - 귀납법(induction)
;;   - https://en.wikipedia.org/wiki/Mathematical_induction
;;   - 歸納(돌아갈 귀, 들일 납)
;;   - 개별적인 사실들로부터 일반적인 결론을 이끌어내는  
;;   - 기저 사례(Base Case): 증명하고자 하는 명제가 특정 초기 값에 대해 참임을 보이는 단계
;;   - 귀납 단계(Induction Step): 특정 수 n에 대해 명제가 참이라고 가정하고 (귀납 가설), 이를 이용하여 n+1에 대해서도 명제가 참임을 증명.


;; ==============================================================
;; 1. Fib(n)이 (φ^n)/√5에 가까운 정수임을 증명해라. (φ = (1+√5)/2, ψ = (1−√5)/2)
;;
;; # 1.1: 일반적인 접근법
;;
;; ## Fib는 특성방정식을 만족함.(선형/상수계수/동차를 만족함)
;; F(n) = F(n−1) + F(n−2)
;;
;; Fib(n) = x^n 이라 바꿔 계산하면.
;; x^n           = x^(n-1)         + x^(n-2)
;; x^n / x^(n-2) = x^(n-1)/x^(n-2) + x^(n-2)/x^(n-2)
;;
;; x^2         = x + 1
;; x^2 - x - 1 = 0
;;
;; 근의 공식으로 풀면
;; x = (1+√5)/2 = φ
;; x = (1-√5)/2 = ψ
;;
;;
;; ## Binet공식: F(n)= (φ^n - ψ^n)/√5
;; 앞서구한 해 φ와 ψ로 F(n)을 나타내면
;; F(n)     = Aφ^n + Bψ^n
;; F(0) = 0 = A + B       | 즉, A = -B
;; F(1) = 1 = Aφ + Bψ
;;          = Aφ - Aψ
;;          = A(φ - ψ)
;;
;; A =  1/(φ - ψ)
;; B = -1/(φ - ψ)
;;
;; φ - ψ = (1+√5)/2 - (1-√5)/2
;;       = 2√5/2
;;       = √5
;;
;; A =  1/√5
;; B = -1/√5
;;
;; F(n) = Aφ^n     + Bψ^n
;;      = 1/√5*φ^n - 1/√5*ψ^n
;;      = (φ^n - ψ^n)/√5
;;
;;
;; # 1.2: G(n)을 도입한 다른 접근법
;;
;; φ + ψ = 1
;; φ - ψ = √5
;; φ * ψ = -1
;; 
;; F(n+2)            = (φ+ψ)*F(n+1) - (φ*ψ)*F(n)
;; F(n+2) - φ*F(n+1) = ψ*(F(n+1) - φ*F(n))
;;
;;
;; ## G(n) 정의
;;
;; G(n  ) = F(n+1) - φ*F(n)
;; G(n+1) = ψ*G(n)
;; G(0)   = F(1)   - φ*F(0)
;;        = 1      - φ*0
;;        = 1
;;        = ψ^0
;; G(1)   = ψ*G(0)
;;        = ψ^1
;; G(n)   = ψ^n
;;        = F(n+1) - φ*F(n)
;;
;; ## 역전개하여 F(n+1) 유도
;; F(n+1) - φ*F(n) = ψ^n
;;
;; F(n+1) = φ*F(n)                             + ψ^n
;;        = φ(φ*F(n-1)             + ψ^(n-1))  + ψ^n
;;        = φ^2*F(n-1)                         + ψ^n + φ*ψ^(n-1)
;;        = φ^3*F(n-2)                         + ψ^n + φ*ψ^(n-1) + φ*ψ^(n-2)
;;        = ...
;;        = φ^(n+1)*F(0)                       + sum(k=0~n, φ^(n-k)*ψ^k)
;;        = φ^(n+1)*0                          + sum(k=0~n, φ^(n-k)*ψ^k)
;;        = sum(k=0~n, φ^(n-k)*ψ^k)
;;        = φ^n * sum(k=0~n, (ψ/φ)^k)                                |  sum(k=0~n, r^k) = (1-r^(n+1)) / (1-r)
;;        = φ^n * (1-(ψ/φ)^(n+1))            / (1-(ψ/φ))
;;        = φ^n * (1-(ψ/φ)^(n+1)) * φ^(n+1)  / (1-(ψ/φ)) * φ^(n+1)
;;        = φ^n * (φ^(n+1) - ψ^(n+1))        / (φ^(n+1) - (ψ * φ^n))
;;        = (φ^(n+1) - ψ^(n+1)) / (φ - ψ)
;;        = (φ^(n+1) - ψ^(n+1)) / √5
;;
;; 따라서
;; F(n)   = (φ^n - ψ^n) / √5
;;
;;
;; ## 1.3: Fib(n)이 (φ^n)/√5에 가까운 정수임을 증명.
;;
;; ψ = (1-√5)/2
;;   = −0.6180339887...
;; |ψ^0|/√5 = 0.447....  | 1/2 보다 작음.
;; |ψ^1|/√5 = 0.276....
;; ...
;; |ψ^n|/√5 = 0.000....  | 0으로 수렴
;; |ψ^n|/√5 = 1/2보다 작고 0으로 수렴.
;;
;; F(n)  = (φ^n     -  ψ^n)/√5
;;       = (φ^n)/√5 - (ψ^n)/√5
;;      ~= (φ^n)/√5            | (ψ^n)/√5 은 0으로 수렴함으로.
;;      ~= (φ^n)/√5            | 따라서 F(n)은 (φ^n)/√5에 가까운 정수.
;;
;; 더 나가자면 |ψ^n|/√5 는 항상 1/2보다 작고 0으로 수렴하므로,
;; 오차는 round 함수의 오차 허용 한계인 0.5보다 항상 작다.
;; 따라서
;;
;; F(n) = round((φ^n)/√5)
;;

;; ==============================================================
;; 2. Fib의 정의로 Fib(n) = (φ^n – ψ^n)/√5 임을 induction으로 밝혀라
;;
;; ## 기저 사례(Base case)
;;
;; n = 0 일때 성립
;; (φ^0 – ψ^0)/√5 = (1 - 1)/√5
;;                = 0
;;
;; n = 1 일때 성립
;; (φ^1 – ψ^1)/√5 = (φ – ψ)/√5
;;                = ((1+√5)/2) - (1-√5)/2) /√5
;;                = (√5/2 + √5/2)/√5
;;                = 1
;;
;; ## 귀납단계(Induction Step)
;;
;; Fib(n  ) = (φ^(n-0) – ψ^(n-0))/√5
;; Fib(n-1) = (φ^(n-1) – ψ^(n-1))/√5
;; Fib(n+1) = Fib(n)         + Fib(n-1)
;;          = (φ^n – ψ^n)/√5 + (φ^(n-1) – ψ^(n-1))/√5
;;          = (φ^n + φ^(n-1)) – (ψ^n + ψ^(n-1)) /√5
;;
;; φ   =  (1+√5)/2
;; φ^2 =  (1 + 2√5 + 5)/4
;;     =  (6 + 2√5)/4
;;     = 2(3 + √5)/4
;;     =  (3 + √5)/2
;;     = (1+√5)/2 + 1
;;     = φ + 1
;;
;; (φ^n + φ^(n-1)) = φ^(n-1) * (φ + 1)
;;                 = φ^(n-1) * φ^2
;;                 = φ^(n+1)
;; (ψ^n + ψ^(n-1)) = ψ^(n+1)
;;
;; 따라서 Fib(n+1) = (φ^(n+1) - ψ^(n+1)) /√5
;;
;; ## 결론.
;; 기저 사례와 귀납 단계를 통해 Fib(n) = (φ^n – ψ^n)/√5 이다.





(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

(define (fib-binet n)
  (let* ((root-5 (sqrt 5))
         (φ (/ (+ 1 root-5) 2))
         (ψ (/ (- 1 root-5) 2)))
    (~&gt; (- (expt φ n) (expt ψ n))
        (/ root-5)
        (round-half-up))))

(define (round-half-up x)
  ;; racket:exact-floor는 IEEE-754 방식(일명 "round half to even" 또는 bankers' rounding)을 사용
  ;; Round half up은 0.5이상 일때 무조건 올림.
  (cond ((zero? x) 0)
        ((positive? x) (racket:exact-floor (+ x 0.5)))
        (else          (racket:exact-floor (- x 0.5)))))

(racket:for ([x (racket:in-inclusive-range 1 75)])
            ;; 부동소수점 정밀도의 한계로 에러가 발생.
            (check-eq? (fib x) (fib-binet x) (racket:~a x)))
</code></pre>
<h2 id="1_14"><a class="header" href="#1_14">1_14</a></h2>
<ul>
<li>1.2.2에서 나온 count-change 함수가 11 센트(cent)에 맞게 잔돈을 만들어내는 트리를 그려보아라.</li>
</ul>
<pre class="mermaid">
%%{init: {'flowchart' : {'curve' : 'monotoneX'}}}%%
graph TD
  cc_11_05_a["(cc 11 5)"] --> cc_11_04_a["(cc 11 4)"]
  cc_11_04_a --> cc_11_03_a["(cc 11 3)"]
  cc_11_03_a --> cc_11_02_a["(cc 11 2)"]
  cc_11_02_a --> cc_11_01_a["(cc 11 1)"]
  cc_11_01_a --> cc_11_00_a["(cc 11 0)"]
  cc_11_01_a --> cc_10_01_a["(cc 10 1)"]
  cc_10_01_a --> cc_10_00_a["(cc 10 0)"]
  cc_10_01_a --> cc_09_01_a["(cc 9 1)"]
  cc_09_01_a --> cc_09_00_a["(cc 9 0)"]
  cc_09_01_a --> cc_08_01_a["(cc 8 1)"]
  cc_08_01_a --> cc_08_00_a["(cc 8 0)"]
  cc_08_01_a --> cc_07_01_a["(cc 7 1)"]
  cc_07_01_a --> cc_07_00_a["(cc 7 0)"]
  cc_07_01_a --> cc_06_01_a["(cc 6 1)"]
  cc_06_01_a --> cc_06_00_a["(cc 6 0)"]
  cc_06_01_a --> cc_05_01_a["(cc 5 1)"]
  cc_05_01_a --> cc_05_00_a["(cc 5 0)"]
  cc_05_01_a --> cc_04_01_a["(cc 4 1)"]
  cc_04_01_a --> cc_04_00_a["(cc 4 0)"]
  cc_04_01_a --> cc_03_01_a["(cc 3 1)"]
  cc_03_01_a --> cc_03_00_a["(cc 3 0)"]
  cc_03_01_a --> cc_02_01_a["(cc 2 1)"]
  cc_02_01_a --> cc_02_00_a["(cc 2 0)"]
  cc_02_01_a --> cc_01_01_a["(cc 1 1)"]
  cc_01_01_a --> cc_01_00_a["(cc 1 0)"]
  cc_01_01_a --> cc_00_01_a["(cc 0 1)"]

  cc_11_02_a --> cc_06_02_a["(cc 6 2)"]
  cc_06_02_a --> cc_06_01_b["(cc 6 1)"]
  cc_06_01_b --> cc_06_00_b["(cc 6 0)"]
  cc_06_01_b --> cc_05_01_b["(cc 5 1)"]
  cc_05_01_b --> cc_05_00_b["(cc 5 0)"]
  cc_05_01_b --> cc_04_01_b["(cc 4 1)"]
  cc_04_01_b --> cc_04_00_b["(cc 4 0)"]
  cc_04_01_b --> cc_03_01_b["(cc 3 1)"]
  cc_03_01_b --> cc_03_00_b["(cc 3 0)"]
  cc_03_01_b --> cc_02_01_b["(cc 2 1)"]
  cc_02_01_b --> cc_02_00_b["(cc 2 0)"]
  cc_02_01_b --> cc_01_01_b["(cc 1 1)"]
  cc_01_01_b --> cc_01_00_b["(cc 1 0)"]
  cc_01_01_b --> cc_00_01_b["(cc 0 1)"]

  cc_06_02_a --> cc_01_02_a["(cc 1 2)"]
  cc_01_02_a --> cc_01_01_c["(cc 1 1)"]
  cc_01_01_c --> cc_01_00_c["(cc 1 0)"]
  cc_01_01_c --> cc_00_01_c["(cc 0 1)"]
  cc_01_02_a --> cc_m4_02["(cc -4 2)"]

  cc_11_03_a --> cc_01_03_a["(cc 1 3)"]
  cc_01_03_a --> cc_01_02_b["(cc 1 2)"]
  cc_01_02_b --> cc_01_01_d["(cc 1 1)"]
  cc_01_01_d --> cc_01_00_d["(cc 1 0)"]
  cc_01_01_d --> cc_00_01_d["(cc 0 1)"]
  cc_01_02_b --> cc_m4_02_b["(cc -4 2)"]

  cc_01_03_a --> cc_m9_03["(cc -9 3)"]

  cc_11_04_a --> cc_m14_04["(cc -14 4)"]

  cc_11_05_a --> cc_m39_05["(cc -39 5)"]

  classDef highlightNode fill:#ffcccc,stroke:#cc0000,stroke-width:2px;
  class cc_00_01_a highlightNode;
  class cc_00_01_b highlightNode;
  class cc_00_01_c highlightNode;
  class cc_00_01_d highlightNode;
</pre>
<pre><code class="language-lisp">;; file: 1_14.rkt
(#%require (prefix trace: racket/trace))

;; 1.2.2: count-change
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0)
         1)
        ((or (&lt; amount 0) (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
;;=&gt; 292

(trace:trace cc)
(count-change 11)
;;=&gt; 4
;;
;; 1. 10x 1 +  1x 1
;; 2.  5x 1 +  1x 6
;; 3.  5x 2 +  1x 1
;; 4.  1x11

;; amount가 증가함에 따라 사용되는 공간과 수행 단계의 증가 차수는?
;;
;; 1. 수행 단계 수 (시간 복잡도)
;; - https://en.wikipedia.org/wiki/Time_complexity
;;
;; - 얼핏보면: O(2^n)
;;   - cc안에서 cc가 두번 호출. 호출 트리가 이진 트리처럼 보임
;; - 사실은: O(n^5)
;;   - amount뿐만 아니라 동전 종류도 고려되야함.
;;   - 그리고 cc를 보면 중복호출하는데 이 중복 계산도 포함하게 되면 - O(n^k)
;;   - 메모이제이션이나 동적 계획법으로 풀면 O(n*k) 복잡도는 줄어들 수 있음.
;;
;; 2. 공간 사용량 (공간 복잡도)
;; - https://en.wikipedia.org/wiki/Space_complexity
;;
;; - 선형 O(n)
;;   - amount가 지속적 감소 ( 최대 호출 스택 깊이 )
</code></pre>
<h2 id="1_15"><a class="header" href="#1_15">1_15</a></h2>
<pre><code class="language-lisp">;; file: 1_15.rkt
(#%require (prefix trace: racket/trace))

(define (cube x)
  (* x x x))

(define (p x)
  (- (* 3 x)
     (* 4 (cube x))))

(define (sine angle)
  (if (not (&gt; (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

(trace:trace p)
(trace:trace sine)

;; 1. (sine 12.15)가 호출되면 p가 몇번 호출되나?
;; sine에서 angle을 3.0으로 계속 나누고 탈출조건은 |angle| &lt; 0.1이니
;;
;; |12.15/3^(x - 1)} &lt; 0.1
;; |3^(x - 1)|       &lt; 121.5
;; 3^4=81
;; 3^5=243
;; 따라서 x = 5

;; (/ 12.15 3)               4.05
;; (/ 4.05 3)                1.3499999999999999
;; (/ 1.3499999999999999 3)  0.44999999999999996
;; (/ 0.44999999999999996 3) 0.15
;; (/ 0.15 3)                0.049999999999999996

(sine 12.15)
;;&gt;&gt; &gt;{sine 12.15}
;;&gt;&gt; &gt; {sine 4.05}
;;&gt;&gt; &gt; &gt;{sine 1.3499999999999999}
;;&gt;&gt; &gt; &gt; {sine 0.44999999999999996}
;;&gt;&gt; &gt; &gt; &gt;{sine 0.15}
;;&gt;&gt; &gt; &gt; &gt; {sine 0.049999999999999996}
;;&gt;&gt; &lt; &lt; &lt; 0.049999999999999996
;;&gt;&gt; &gt; &gt; &gt;{p 0.049999999999999996}        --- 1
;;&gt;&gt; &lt; &lt; &lt;0.1495
;;&gt;&gt; &gt; &gt; {p 0.1495}                       --- 2
;;&gt;&gt; &lt; &lt; 0.4351345505
;;&gt;&gt; &gt; &gt;{p 0.4351345505}                  --- 3
;;&gt;&gt; &lt; &lt;0.9758465331678772
;;&gt;&gt; &gt; {p 0.9758465331678772}             --- 4
;;&gt;&gt; &lt; -0.7895631144708228
;;&gt;&gt; &gt;{p -0.7895631144708228}             --- 5
;;&gt;&gt; &lt;-0.39980345741334
;;=&gt; -0.39980345741334


;; 2. (sine a)를 계산시 시간 복접도와 공간 복잡도를 a로 표현.
;;
;; 깊이 - 여기선 시간복잡도, 공간사용량도 깊이랑 같음.
;; a/3^n &lt; 0.1
;; 3^n   &gt; 10a
;; n     &gt; log3(10a)
;;
;; - 수행 단계 수 (시간 복잡도): O(log(a))
;; - 공간 사용량  (공간 복잡도): O(log(a))
</code></pre>
<h2 id="1_16"><a class="header" href="#1_16">1_16</a></h2>
<pre><code class="language-lisp">;; file: 1_16.rkt
</code></pre>
<h2 id="1_17"><a class="header" href="#1_17">1_17</a></h2>
<pre><code class="language-lisp">;; file: 1_17.rkt
</code></pre>
<h2 id="1_18"><a class="header" href="#1_18">1_18</a></h2>
<pre><code class="language-lisp">;; file: 1_18.rkt
</code></pre>
<h2 id="1_19"><a class="header" href="#1_19">1_19</a></h2>
<pre><code class="language-lisp">;; file: 1_19.rkt
</code></pre>
<h2 id="1_20"><a class="header" href="#1_20">1_20</a></h2>
<pre><code class="language-lisp">;; file: 1_20.rkt
</code></pre>
<h2 id="1_21"><a class="header" href="#1_21">1_21</a></h2>
<pre><code class="language-lisp">;; file: 1_21.rkt
</code></pre>
<h2 id="1_22"><a class="header" href="#1_22">1_22</a></h2>
<pre><code class="language-lisp">;; file: 1_22.rkt
</code></pre>
<h2 id="1_23"><a class="header" href="#1_23">1_23</a></h2>
<pre><code class="language-lisp">;; file: 1_23.rkt
</code></pre>
<h2 id="1_24"><a class="header" href="#1_24">1_24</a></h2>
<pre><code class="language-lisp">;; file: 1_24.rkt
</code></pre>
<h2 id="1_25"><a class="header" href="#1_25">1_25</a></h2>
<pre><code class="language-lisp">;; file: 1_25.rkt
</code></pre>
<h2 id="1_26"><a class="header" href="#1_26">1_26</a></h2>
<pre><code class="language-lisp">;; file: 1_26.rkt
</code></pre>
<h2 id="1_27"><a class="header" href="#1_27">1_27</a></h2>
<pre><code class="language-lisp">;; file: 1_27.rkt
</code></pre>
<h2 id="1_28"><a class="header" href="#1_28">1_28</a></h2>
<pre><code class="language-lisp">;; file: 1_28.rkt
</code></pre>
<h2 id="1_29"><a class="header" href="#1_29">1_29</a></h2>
<pre><code class="language-lisp">;; file: 1_29.rkt
</code></pre>
<h2 id="1_30"><a class="header" href="#1_30">1_30</a></h2>
<pre><code class="language-lisp">;; file: 1_30.rkt
</code></pre>
<h2 id="1_31"><a class="header" href="#1_31">1_31</a></h2>
<pre><code class="language-lisp">;; file: 1_31.rkt
</code></pre>
<h2 id="1_32"><a class="header" href="#1_32">1_32</a></h2>
<pre><code class="language-lisp">;; file: 1_32.rkt
</code></pre>
<h2 id="1_33"><a class="header" href="#1_33">1_33</a></h2>
<pre><code class="language-lisp">;; file: 1_33.rkt
</code></pre>
<h2 id="1_34"><a class="header" href="#1_34">1_34</a></h2>
<pre><code class="language-lisp">;; file: 1_34.rkt
</code></pre>
<h2 id="1_35"><a class="header" href="#1_35">1_35</a></h2>
<pre><code class="language-lisp">;; file: 1_35.rkt
</code></pre>
<h2 id="1_36"><a class="header" href="#1_36">1_36</a></h2>
<pre><code class="language-lisp">;; file: 1_36.rkt
</code></pre>
<h2 id="1_37"><a class="header" href="#1_37">1_37</a></h2>
<pre><code class="language-lisp">;; file: 1_37.rkt
</code></pre>
<h2 id="1_38"><a class="header" href="#1_38">1_38</a></h2>
<pre><code class="language-lisp">;; file: 1_38.rkt
</code></pre>
<h2 id="1_39"><a class="header" href="#1_39">1_39</a></h2>
<pre><code class="language-lisp">;; file: 1_39.rkt
</code></pre>
<h2 id="1_40"><a class="header" href="#1_40">1_40</a></h2>
<pre><code class="language-lisp">;; file: 1_40.rkt
</code></pre>
<h2 id="1_41"><a class="header" href="#1_41">1_41</a></h2>
<pre><code class="language-lisp">;; file: 1_41.rkt
</code></pre>
<h2 id="1_42"><a class="header" href="#1_42">1_42</a></h2>
<pre><code class="language-lisp">;; file: 1_42.rkt
</code></pre>
<h2 id="1_43"><a class="header" href="#1_43">1_43</a></h2>
<pre><code class="language-lisp">;; file: 1_43.rkt
</code></pre>
<h2 id="1_44"><a class="header" href="#1_44">1_44</a></h2>
<pre><code class="language-lisp">;; file: 1_44.rkt
</code></pre>
<h2 id="1_45"><a class="header" href="#1_45">1_45</a></h2>
<pre><code class="language-lisp">;; file: 1_45.rkt
</code></pre>
<h2 id="1_46"><a class="header" href="#1_46">1_46</a></h2>
<pre><code class="language-lisp">;; file: 1_46.rkt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="연습문제-풀이-02"><a class="header" href="#연습문제-풀이-02">연습문제 풀이 02</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_02">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_02</a></li>
</ul>
<h2 id="2_01"><a class="header" href="#2_01">2_01</a></h2>
<pre><code class="language-lisp">;; file: 2_01.rkt
</code></pre>
<h2 id="2_02"><a class="header" href="#2_02">2_02</a></h2>
<pre><code class="language-lisp">;; file: 2_02.rkt
</code></pre>
<h2 id="2_03"><a class="header" href="#2_03">2_03</a></h2>
<pre><code class="language-lisp">;; file: 2_03.rkt
</code></pre>
<h2 id="2_04"><a class="header" href="#2_04">2_04</a></h2>
<pre><code class="language-lisp">;; file: 2_04.rkt
</code></pre>
<h2 id="2_05"><a class="header" href="#2_05">2_05</a></h2>
<pre><code class="language-lisp">;; file: 2_05.rkt
</code></pre>
<h2 id="2_06"><a class="header" href="#2_06">2_06</a></h2>
<pre><code class="language-lisp">;; file: 2_06.rkt
</code></pre>
<h2 id="2_07"><a class="header" href="#2_07">2_07</a></h2>
<pre><code class="language-lisp">;; file: 2_07.rkt
</code></pre>
<h2 id="2_08"><a class="header" href="#2_08">2_08</a></h2>
<pre><code class="language-lisp">;; file: 2_08.rkt
</code></pre>
<h2 id="2_09"><a class="header" href="#2_09">2_09</a></h2>
<pre><code class="language-lisp">;; file: 2_09.rkt
</code></pre>
<h2 id="2_10"><a class="header" href="#2_10">2_10</a></h2>
<pre><code class="language-lisp">;; file: 2_10.rkt
</code></pre>
<h2 id="2_11"><a class="header" href="#2_11">2_11</a></h2>
<pre><code class="language-lisp">;; file: 2_11.rkt
</code></pre>
<h2 id="2_12"><a class="header" href="#2_12">2_12</a></h2>
<pre><code class="language-lisp">;; file: 2_12.rkt
</code></pre>
<h2 id="2_13"><a class="header" href="#2_13">2_13</a></h2>
<pre><code class="language-lisp">;; file: 2_13.rkt
</code></pre>
<h2 id="2_14"><a class="header" href="#2_14">2_14</a></h2>
<pre><code class="language-lisp">;; file: 2_14.rkt
</code></pre>
<h2 id="2_15"><a class="header" href="#2_15">2_15</a></h2>
<pre><code class="language-lisp">;; file: 2_15.rkt
</code></pre>
<h2 id="2_16"><a class="header" href="#2_16">2_16</a></h2>
<pre><code class="language-lisp">;; file: 2_16.rkt
</code></pre>
<h2 id="2_17"><a class="header" href="#2_17">2_17</a></h2>
<pre><code class="language-lisp">;; file: 2_17.rkt
</code></pre>
<h2 id="2_18"><a class="header" href="#2_18">2_18</a></h2>
<pre><code class="language-lisp">;; file: 2_18.rkt
</code></pre>
<h2 id="2_19"><a class="header" href="#2_19">2_19</a></h2>
<pre><code class="language-lisp">;; file: 2_19.rkt
</code></pre>
<h2 id="2_20"><a class="header" href="#2_20">2_20</a></h2>
<pre><code class="language-lisp">;; file: 2_20.rkt
</code></pre>
<h2 id="2_21"><a class="header" href="#2_21">2_21</a></h2>
<pre><code class="language-lisp">;; file: 2_21.rkt
</code></pre>
<h2 id="2_22"><a class="header" href="#2_22">2_22</a></h2>
<pre><code class="language-lisp">;; file: 2_22.rkt
</code></pre>
<h2 id="2_23"><a class="header" href="#2_23">2_23</a></h2>
<pre><code class="language-lisp">;; file: 2_23.rkt
</code></pre>
<h2 id="2_24"><a class="header" href="#2_24">2_24</a></h2>
<pre><code class="language-lisp">;; file: 2_24.rkt
</code></pre>
<h2 id="2_25"><a class="header" href="#2_25">2_25</a></h2>
<pre><code class="language-lisp">;; file: 2_25.rkt
</code></pre>
<h2 id="2_26"><a class="header" href="#2_26">2_26</a></h2>
<pre><code class="language-lisp">;; file: 2_26.rkt
</code></pre>
<h2 id="2_27"><a class="header" href="#2_27">2_27</a></h2>
<pre><code class="language-lisp">;; file: 2_27.rkt
</code></pre>
<h2 id="2_28"><a class="header" href="#2_28">2_28</a></h2>
<pre><code class="language-lisp">;; file: 2_28.rkt
</code></pre>
<h2 id="2_29"><a class="header" href="#2_29">2_29</a></h2>
<pre><code class="language-lisp">;; file: 2_29.rkt
</code></pre>
<h2 id="2_30"><a class="header" href="#2_30">2_30</a></h2>
<pre><code class="language-lisp">;; file: 2_30.rkt
</code></pre>
<h2 id="2_31"><a class="header" href="#2_31">2_31</a></h2>
<pre><code class="language-lisp">;; file: 2_31.rkt
</code></pre>
<h2 id="2_32"><a class="header" href="#2_32">2_32</a></h2>
<pre><code class="language-lisp">;; file: 2_32.rkt
</code></pre>
<h2 id="2_33"><a class="header" href="#2_33">2_33</a></h2>
<pre><code class="language-lisp">;; file: 2_33.rkt
</code></pre>
<h2 id="2_34"><a class="header" href="#2_34">2_34</a></h2>
<pre><code class="language-lisp">;; file: 2_34.rkt
</code></pre>
<h2 id="2_35"><a class="header" href="#2_35">2_35</a></h2>
<pre><code class="language-lisp">;; file: 2_35.rkt
</code></pre>
<h2 id="2_36"><a class="header" href="#2_36">2_36</a></h2>
<pre><code class="language-lisp">;; file: 2_36.rkt
</code></pre>
<h2 id="2_37"><a class="header" href="#2_37">2_37</a></h2>
<pre><code class="language-lisp">;; file: 2_37.rkt
</code></pre>
<h2 id="2_38"><a class="header" href="#2_38">2_38</a></h2>
<pre><code class="language-lisp">;; file: 2_38.rkt
</code></pre>
<h2 id="2_39"><a class="header" href="#2_39">2_39</a></h2>
<pre><code class="language-lisp">;; file: 2_39.rkt
</code></pre>
<h2 id="2_40"><a class="header" href="#2_40">2_40</a></h2>
<pre><code class="language-lisp">;; file: 2_40.rkt
</code></pre>
<h2 id="2_41"><a class="header" href="#2_41">2_41</a></h2>
<pre><code class="language-lisp">;; file: 2_41.rkt
</code></pre>
<h2 id="2_42"><a class="header" href="#2_42">2_42</a></h2>
<pre><code class="language-lisp">;; file: 2_42.rkt
</code></pre>
<h2 id="2_43"><a class="header" href="#2_43">2_43</a></h2>
<pre><code class="language-lisp">;; file: 2_43.rkt
</code></pre>
<h2 id="2_44"><a class="header" href="#2_44">2_44</a></h2>
<pre><code class="language-lisp">;; file: 2_44.rkt
</code></pre>
<h2 id="2_45"><a class="header" href="#2_45">2_45</a></h2>
<pre><code class="language-lisp">;; file: 2_45.rkt
</code></pre>
<h2 id="2_46"><a class="header" href="#2_46">2_46</a></h2>
<pre><code class="language-lisp">;; file: 2_46.rkt
</code></pre>
<h2 id="2_47"><a class="header" href="#2_47">2_47</a></h2>
<pre><code class="language-lisp">;; file: 2_47.rkt
</code></pre>
<h2 id="2_48"><a class="header" href="#2_48">2_48</a></h2>
<pre><code class="language-lisp">;; file: 2_48.rkt
</code></pre>
<h2 id="2_49"><a class="header" href="#2_49">2_49</a></h2>
<pre><code class="language-lisp">;; file: 2_49.rkt
</code></pre>
<h2 id="2_50"><a class="header" href="#2_50">2_50</a></h2>
<pre><code class="language-lisp">;; file: 2_50.rkt
</code></pre>
<h2 id="2_51"><a class="header" href="#2_51">2_51</a></h2>
<pre><code class="language-lisp">;; file: 2_51.rkt
</code></pre>
<h2 id="2_52"><a class="header" href="#2_52">2_52</a></h2>
<pre><code class="language-lisp">;; file: 2_52.rkt
</code></pre>
<h2 id="2_53"><a class="header" href="#2_53">2_53</a></h2>
<pre><code class="language-lisp">;; file: 2_53.rkt
</code></pre>
<h2 id="2_54"><a class="header" href="#2_54">2_54</a></h2>
<pre><code class="language-lisp">;; file: 2_54.rkt
</code></pre>
<h2 id="2_55"><a class="header" href="#2_55">2_55</a></h2>
<pre><code class="language-lisp">;; file: 2_55.rkt
</code></pre>
<h2 id="2_56"><a class="header" href="#2_56">2_56</a></h2>
<pre><code class="language-lisp">;; file: 2_56.rkt
</code></pre>
<h2 id="2_57"><a class="header" href="#2_57">2_57</a></h2>
<pre><code class="language-lisp">;; file: 2_57.rkt
</code></pre>
<h2 id="2_58"><a class="header" href="#2_58">2_58</a></h2>
<pre><code class="language-lisp">;; file: 2_58.rkt
</code></pre>
<h2 id="2_59"><a class="header" href="#2_59">2_59</a></h2>
<pre><code class="language-lisp">;; file: 2_59.rkt
</code></pre>
<h2 id="2_60"><a class="header" href="#2_60">2_60</a></h2>
<pre><code class="language-lisp">;; file: 2_60.rkt
</code></pre>
<h2 id="2_61"><a class="header" href="#2_61">2_61</a></h2>
<pre><code class="language-lisp">;; file: 2_61.rkt
</code></pre>
<h2 id="2_62"><a class="header" href="#2_62">2_62</a></h2>
<pre><code class="language-lisp">;; file: 2_62.rkt
</code></pre>
<h2 id="2_63"><a class="header" href="#2_63">2_63</a></h2>
<pre><code class="language-lisp">;; file: 2_63.rkt
</code></pre>
<h2 id="2_64"><a class="header" href="#2_64">2_64</a></h2>
<pre><code class="language-lisp">;; file: 2_64.rkt
</code></pre>
<h2 id="2_65"><a class="header" href="#2_65">2_65</a></h2>
<pre><code class="language-lisp">;; file: 2_65.rkt
</code></pre>
<h2 id="2_66"><a class="header" href="#2_66">2_66</a></h2>
<pre><code class="language-lisp">;; file: 2_66.rkt
</code></pre>
<h2 id="2_67"><a class="header" href="#2_67">2_67</a></h2>
<pre><code class="language-lisp">;; file: 2_67.rkt
</code></pre>
<h2 id="2_68"><a class="header" href="#2_68">2_68</a></h2>
<pre><code class="language-lisp">;; file: 2_68.rkt
</code></pre>
<h2 id="2_69"><a class="header" href="#2_69">2_69</a></h2>
<pre><code class="language-lisp">;; file: 2_69.rkt
</code></pre>
<h2 id="2_70"><a class="header" href="#2_70">2_70</a></h2>
<pre><code class="language-lisp">;; file: 2_70.rkt
</code></pre>
<h2 id="2_71"><a class="header" href="#2_71">2_71</a></h2>
<pre><code class="language-lisp">;; file: 2_71.rkt
</code></pre>
<h2 id="2_72"><a class="header" href="#2_72">2_72</a></h2>
<pre><code class="language-lisp">;; file: 2_72.rkt
</code></pre>
<h2 id="2_73"><a class="header" href="#2_73">2_73</a></h2>
<pre><code class="language-lisp">;; file: 2_73.rkt
</code></pre>
<h2 id="2_74"><a class="header" href="#2_74">2_74</a></h2>
<pre><code class="language-lisp">;; file: 2_74.rkt
</code></pre>
<h2 id="2_75"><a class="header" href="#2_75">2_75</a></h2>
<pre><code class="language-lisp">;; file: 2_75.rkt
</code></pre>
<h2 id="2_76"><a class="header" href="#2_76">2_76</a></h2>
<pre><code class="language-lisp">;; file: 2_76.rkt
</code></pre>
<h2 id="2_77"><a class="header" href="#2_77">2_77</a></h2>
<pre><code class="language-lisp">;; file: 2_77.rkt
</code></pre>
<h2 id="2_78"><a class="header" href="#2_78">2_78</a></h2>
<pre><code class="language-lisp">;; file: 2_78.rkt
</code></pre>
<h2 id="2_79"><a class="header" href="#2_79">2_79</a></h2>
<pre><code class="language-lisp">;; file: 2_79.rkt
</code></pre>
<h2 id="2_80"><a class="header" href="#2_80">2_80</a></h2>
<pre><code class="language-lisp">;; file: 2_80.rkt
</code></pre>
<h2 id="2_81"><a class="header" href="#2_81">2_81</a></h2>
<pre><code class="language-lisp">;; file: 2_81.rkt
</code></pre>
<h2 id="2_82"><a class="header" href="#2_82">2_82</a></h2>
<pre><code class="language-lisp">;; file: 2_82.rkt
</code></pre>
<h2 id="2_83"><a class="header" href="#2_83">2_83</a></h2>
<pre><code class="language-lisp">;; file: 2_83.rkt
</code></pre>
<h2 id="2_84"><a class="header" href="#2_84">2_84</a></h2>
<pre><code class="language-lisp">;; file: 2_84.rkt
</code></pre>
<h2 id="2_85"><a class="header" href="#2_85">2_85</a></h2>
<pre><code class="language-lisp">;; file: 2_85.rkt
</code></pre>
<h2 id="2_86"><a class="header" href="#2_86">2_86</a></h2>
<pre><code class="language-lisp">;; file: 2_86.rkt
</code></pre>
<h2 id="2_87"><a class="header" href="#2_87">2_87</a></h2>
<pre><code class="language-lisp">;; file: 2_87.rkt
</code></pre>
<h2 id="2_88"><a class="header" href="#2_88">2_88</a></h2>
<pre><code class="language-lisp">;; file: 2_88.rkt
</code></pre>
<h2 id="2_89"><a class="header" href="#2_89">2_89</a></h2>
<pre><code class="language-lisp">;; file: 2_89.rkt
</code></pre>
<h2 id="2_90"><a class="header" href="#2_90">2_90</a></h2>
<pre><code class="language-lisp">;; file: 2_90.rkt
</code></pre>
<h2 id="2_91"><a class="header" href="#2_91">2_91</a></h2>
<pre><code class="language-lisp">;; file: 2_91.rkt
</code></pre>
<h2 id="2_92"><a class="header" href="#2_92">2_92</a></h2>
<pre><code class="language-lisp">;; file: 2_92.rkt
</code></pre>
<h2 id="2_93"><a class="header" href="#2_93">2_93</a></h2>
<pre><code class="language-lisp">;; file: 2_93.rkt
</code></pre>
<h2 id="2_94"><a class="header" href="#2_94">2_94</a></h2>
<pre><code class="language-lisp">;; file: 2_94.rkt
</code></pre>
<h2 id="2_95"><a class="header" href="#2_95">2_95</a></h2>
<pre><code class="language-lisp">;; file: 2_95.rkt
</code></pre>
<h2 id="2_96"><a class="header" href="#2_96">2_96</a></h2>
<pre><code class="language-lisp">;; file: 2_96.rkt
</code></pre>
<h2 id="2_97"><a class="header" href="#2_97">2_97</a></h2>
<pre><code class="language-lisp">;; file: 2_97.rkt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="연습문제-풀이-03"><a class="header" href="#연습문제-풀이-03">연습문제 풀이 03</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_03">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_03</a></li>
</ul>
<h2 id="3_01"><a class="header" href="#3_01">3_01</a></h2>
<pre><code class="language-lisp">;; file: 3_01.rkt
</code></pre>
<h2 id="3_02"><a class="header" href="#3_02">3_02</a></h2>
<pre><code class="language-lisp">;; file: 3_02.rkt
</code></pre>
<h2 id="3_03"><a class="header" href="#3_03">3_03</a></h2>
<pre><code class="language-lisp">;; file: 3_03.rkt
</code></pre>
<h2 id="3_04"><a class="header" href="#3_04">3_04</a></h2>
<pre><code class="language-lisp">;; file: 3_04.rkt
</code></pre>
<h2 id="3_05"><a class="header" href="#3_05">3_05</a></h2>
<pre><code class="language-lisp">;; file: 3_05.rkt
</code></pre>
<h2 id="3_06"><a class="header" href="#3_06">3_06</a></h2>
<pre><code class="language-lisp">;; file: 3_06.rkt
</code></pre>
<h2 id="3_07"><a class="header" href="#3_07">3_07</a></h2>
<pre><code class="language-lisp">;; file: 3_07.rkt
</code></pre>
<h2 id="3_08"><a class="header" href="#3_08">3_08</a></h2>
<pre><code class="language-lisp">;; file: 3_08.rkt
</code></pre>
<h2 id="3_09"><a class="header" href="#3_09">3_09</a></h2>
<pre><code class="language-lisp">;; file: 3_09.rkt
</code></pre>
<h2 id="3_10"><a class="header" href="#3_10">3_10</a></h2>
<pre><code class="language-lisp">;; file: 3_10.rkt
</code></pre>
<h2 id="3_11"><a class="header" href="#3_11">3_11</a></h2>
<pre><code class="language-lisp">;; file: 3_11.rkt
</code></pre>
<h2 id="3_12"><a class="header" href="#3_12">3_12</a></h2>
<pre><code class="language-lisp">;; file: 3_12.rkt
</code></pre>
<h2 id="3_13"><a class="header" href="#3_13">3_13</a></h2>
<pre><code class="language-lisp">;; file: 3_13.rkt
</code></pre>
<h2 id="3_14"><a class="header" href="#3_14">3_14</a></h2>
<pre><code class="language-lisp">;; file: 3_14.rkt
</code></pre>
<h2 id="3_15"><a class="header" href="#3_15">3_15</a></h2>
<pre><code class="language-lisp">;; file: 3_15.rkt
</code></pre>
<h2 id="3_16"><a class="header" href="#3_16">3_16</a></h2>
<pre><code class="language-lisp">;; file: 3_16.rkt
</code></pre>
<h2 id="3_17"><a class="header" href="#3_17">3_17</a></h2>
<pre><code class="language-lisp">;; file: 3_17.rkt
</code></pre>
<h2 id="3_18"><a class="header" href="#3_18">3_18</a></h2>
<pre><code class="language-lisp">;; file: 3_18.rkt
</code></pre>
<h2 id="3_19"><a class="header" href="#3_19">3_19</a></h2>
<pre><code class="language-lisp">;; file: 3_19.rkt
</code></pre>
<h2 id="3_20"><a class="header" href="#3_20">3_20</a></h2>
<pre><code class="language-lisp">;; file: 3_20.rkt
</code></pre>
<h2 id="3_21"><a class="header" href="#3_21">3_21</a></h2>
<pre><code class="language-lisp">;; file: 3_21.rkt
</code></pre>
<h2 id="3_22"><a class="header" href="#3_22">3_22</a></h2>
<pre><code class="language-lisp">;; file: 3_22.rkt
</code></pre>
<h2 id="3_23"><a class="header" href="#3_23">3_23</a></h2>
<pre><code class="language-lisp">;; file: 3_23.rkt
</code></pre>
<h2 id="3_24"><a class="header" href="#3_24">3_24</a></h2>
<pre><code class="language-lisp">;; file: 3_24.rkt
</code></pre>
<h2 id="3_25"><a class="header" href="#3_25">3_25</a></h2>
<pre><code class="language-lisp">;; file: 3_25.rkt
</code></pre>
<h2 id="3_26"><a class="header" href="#3_26">3_26</a></h2>
<pre><code class="language-lisp">;; file: 3_26.rkt
</code></pre>
<h2 id="3_27"><a class="header" href="#3_27">3_27</a></h2>
<pre><code class="language-lisp">;; file: 3_27.rkt
</code></pre>
<h2 id="3_28"><a class="header" href="#3_28">3_28</a></h2>
<pre><code class="language-lisp">;; file: 3_28.rkt
</code></pre>
<h2 id="3_29"><a class="header" href="#3_29">3_29</a></h2>
<pre><code class="language-lisp">;; file: 3_29.rkt
</code></pre>
<h2 id="3_30"><a class="header" href="#3_30">3_30</a></h2>
<pre><code class="language-lisp">;; file: 3_30.rkt
</code></pre>
<h2 id="3_31"><a class="header" href="#3_31">3_31</a></h2>
<pre><code class="language-lisp">;; file: 3_31.rkt
</code></pre>
<h2 id="3_32"><a class="header" href="#3_32">3_32</a></h2>
<pre><code class="language-lisp">;; file: 3_32.rkt
</code></pre>
<h2 id="3_33"><a class="header" href="#3_33">3_33</a></h2>
<pre><code class="language-lisp">;; file: 3_33.rkt
</code></pre>
<h2 id="3_34"><a class="header" href="#3_34">3_34</a></h2>
<pre><code class="language-lisp">;; file: 3_34.rkt
</code></pre>
<h2 id="3_35"><a class="header" href="#3_35">3_35</a></h2>
<pre><code class="language-lisp">;; file: 3_35.rkt
</code></pre>
<h2 id="3_36"><a class="header" href="#3_36">3_36</a></h2>
<pre><code class="language-lisp">;; file: 3_36.rkt
</code></pre>
<h2 id="3_37"><a class="header" href="#3_37">3_37</a></h2>
<pre><code class="language-lisp">;; file: 3_37.rkt
</code></pre>
<h2 id="3_38"><a class="header" href="#3_38">3_38</a></h2>
<pre><code class="language-lisp">;; file: 3_38.rkt
</code></pre>
<h2 id="3_39"><a class="header" href="#3_39">3_39</a></h2>
<pre><code class="language-lisp">;; file: 3_39.rkt
</code></pre>
<h2 id="3_40"><a class="header" href="#3_40">3_40</a></h2>
<pre><code class="language-lisp">;; file: 3_40.rkt
</code></pre>
<h2 id="3_41"><a class="header" href="#3_41">3_41</a></h2>
<pre><code class="language-lisp">;; file: 3_41.rkt
</code></pre>
<h2 id="3_42"><a class="header" href="#3_42">3_42</a></h2>
<pre><code class="language-lisp">;; file: 3_42.rkt
</code></pre>
<h2 id="3_43"><a class="header" href="#3_43">3_43</a></h2>
<pre><code class="language-lisp">;; file: 3_43.rkt
</code></pre>
<h2 id="3_44"><a class="header" href="#3_44">3_44</a></h2>
<pre><code class="language-lisp">;; file: 3_44.rkt
</code></pre>
<h2 id="3_45"><a class="header" href="#3_45">3_45</a></h2>
<pre><code class="language-lisp">;; file: 3_45.rkt
</code></pre>
<h2 id="3_46"><a class="header" href="#3_46">3_46</a></h2>
<pre><code class="language-lisp">;; file: 3_46.rkt
</code></pre>
<h2 id="3_47"><a class="header" href="#3_47">3_47</a></h2>
<pre><code class="language-lisp">;; file: 3_47.rkt
</code></pre>
<h2 id="3_48"><a class="header" href="#3_48">3_48</a></h2>
<pre><code class="language-lisp">;; file: 3_48.rkt
</code></pre>
<h2 id="3_49"><a class="header" href="#3_49">3_49</a></h2>
<pre><code class="language-lisp">;; file: 3_49.rkt
</code></pre>
<h2 id="3_50"><a class="header" href="#3_50">3_50</a></h2>
<pre><code class="language-lisp">;; file: 3_50.rkt
</code></pre>
<h2 id="3_51"><a class="header" href="#3_51">3_51</a></h2>
<pre><code class="language-lisp">;; file: 3_51.rkt
</code></pre>
<h2 id="3_52"><a class="header" href="#3_52">3_52</a></h2>
<pre><code class="language-lisp">;; file: 3_52.rkt
</code></pre>
<h2 id="3_53"><a class="header" href="#3_53">3_53</a></h2>
<pre><code class="language-lisp">;; file: 3_53.rkt
</code></pre>
<h2 id="3_54"><a class="header" href="#3_54">3_54</a></h2>
<pre><code class="language-lisp">;; file: 3_54.rkt
</code></pre>
<h2 id="3_55"><a class="header" href="#3_55">3_55</a></h2>
<pre><code class="language-lisp">;; file: 3_55.rkt
</code></pre>
<h2 id="3_56"><a class="header" href="#3_56">3_56</a></h2>
<pre><code class="language-lisp">;; file: 3_56.rkt
</code></pre>
<h2 id="3_57"><a class="header" href="#3_57">3_57</a></h2>
<pre><code class="language-lisp">;; file: 3_57.rkt
</code></pre>
<h2 id="3_58"><a class="header" href="#3_58">3_58</a></h2>
<pre><code class="language-lisp">;; file: 3_58.rkt
</code></pre>
<h2 id="3_59"><a class="header" href="#3_59">3_59</a></h2>
<pre><code class="language-lisp">;; file: 3_59.rkt
</code></pre>
<h2 id="3_60"><a class="header" href="#3_60">3_60</a></h2>
<pre><code class="language-lisp">;; file: 3_60.rkt
</code></pre>
<h2 id="3_61"><a class="header" href="#3_61">3_61</a></h2>
<pre><code class="language-lisp">;; file: 3_61.rkt
</code></pre>
<h2 id="3_62"><a class="header" href="#3_62">3_62</a></h2>
<pre><code class="language-lisp">;; file: 3_62.rkt
</code></pre>
<h2 id="3_63"><a class="header" href="#3_63">3_63</a></h2>
<pre><code class="language-lisp">;; file: 3_63.rkt
</code></pre>
<h2 id="3_64"><a class="header" href="#3_64">3_64</a></h2>
<pre><code class="language-lisp">;; file: 3_64.rkt
</code></pre>
<h2 id="3_65"><a class="header" href="#3_65">3_65</a></h2>
<pre><code class="language-lisp">;; file: 3_65.rkt
</code></pre>
<h2 id="3_66"><a class="header" href="#3_66">3_66</a></h2>
<pre><code class="language-lisp">;; file: 3_66.rkt
</code></pre>
<h2 id="3_67"><a class="header" href="#3_67">3_67</a></h2>
<pre><code class="language-lisp">;; file: 3_67.rkt
</code></pre>
<h2 id="3_68"><a class="header" href="#3_68">3_68</a></h2>
<pre><code class="language-lisp">;; file: 3_68.rkt
</code></pre>
<h2 id="3_69"><a class="header" href="#3_69">3_69</a></h2>
<pre><code class="language-lisp">;; file: 3_69.rkt
</code></pre>
<h2 id="3_70"><a class="header" href="#3_70">3_70</a></h2>
<pre><code class="language-lisp">;; file: 3_70.rkt
</code></pre>
<h2 id="3_71"><a class="header" href="#3_71">3_71</a></h2>
<pre><code class="language-lisp">;; file: 3_71.rkt
</code></pre>
<h2 id="3_72"><a class="header" href="#3_72">3_72</a></h2>
<pre><code class="language-lisp">;; file: 3_72.rkt
</code></pre>
<h2 id="3_73"><a class="header" href="#3_73">3_73</a></h2>
<pre><code class="language-lisp">;; file: 3_73.rkt
</code></pre>
<h2 id="3_74"><a class="header" href="#3_74">3_74</a></h2>
<pre><code class="language-lisp">;; file: 3_74.rkt
</code></pre>
<h2 id="3_75"><a class="header" href="#3_75">3_75</a></h2>
<pre><code class="language-lisp">;; file: 3_75.rkt
</code></pre>
<h2 id="3_76"><a class="header" href="#3_76">3_76</a></h2>
<pre><code class="language-lisp">;; file: 3_76.rkt
</code></pre>
<h2 id="3_77"><a class="header" href="#3_77">3_77</a></h2>
<pre><code class="language-lisp">;; file: 3_77.rkt
</code></pre>
<h2 id="3_78"><a class="header" href="#3_78">3_78</a></h2>
<pre><code class="language-lisp">;; file: 3_78.rkt
</code></pre>
<h2 id="3_79"><a class="header" href="#3_79">3_79</a></h2>
<pre><code class="language-lisp">;; file: 3_79.rkt
</code></pre>
<h2 id="3_80"><a class="header" href="#3_80">3_80</a></h2>
<pre><code class="language-lisp">;; file: 3_80.rkt
</code></pre>
<h2 id="3_81"><a class="header" href="#3_81">3_81</a></h2>
<pre><code class="language-lisp">;; file: 3_81.rkt
</code></pre>
<h2 id="3_82"><a class="header" href="#3_82">3_82</a></h2>
<pre><code class="language-lisp">;; file: 3_82.rkt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="연습문제-풀이-04"><a class="header" href="#연습문제-풀이-04">연습문제 풀이 04</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_04">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_04</a></li>
</ul>
<h2 id="4_01"><a class="header" href="#4_01">4_01</a></h2>
<pre><code class="language-lisp">;; file: 4_01.rkt
(#%require rackunit)
(#%require (prefix racket: racket))

(racket:require "../allcode/ch4-4.1.1-mceval.rkt")

;; 여기서의 cons는 left평가후 right를 평가한다.
(cons
 (begin (display "1") (newline) 1)
 (begin (display "2") (newline) 2))
;;&gt;&gt; 1
;;&gt;&gt; 2
;;=&gt; (1 . 2)

;; cons의 구현과 상관없이, 순서를 강제하려면 cons에서 left/right를 계산하는게 아닌,
;; 미리 left/right를 계산해버리면 된다.
(let* ((left  (begin (display "1") (newline) 1))
       (right (begin (display "2") (newline) 2)))
  (cons left right))
;;&gt;&gt; 1
;;&gt;&gt; 2
;;=&gt; (1 . 2)

(let* ((right (begin (display "2") (newline) 2))
       (left  (begin (display "1") (newline) 1)))
  (cons left right))
;;&gt;&gt; 2
;;&gt;&gt; 1
;;=&gt; (1 . 2)

;; list-of-values 를 다시 작성하면
;; before
'(define (list-of-values exps env)
   (if (no-operands? exps)
       '()
       (cons (eval (first-operand exps) env)
             (list-of-values (rest-operand exps) env))))

;; after
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operands exps) env)))
        (cons left right))))
</code></pre>
<h2 id="4_02"><a class="header" href="#4_02">4_02</a></h2>
<pre><code class="language-lisp">;; file: 4_02.rkt
(#%require rackunit)
(#%require (prefix racket: racket))
(#%require "../allcode/helper/my-util.rkt")
(racket:require "../allcode/ch4-4.1.1-mceval.rkt")

;; a) eval의 cond절에서
;;    assignment 혹은 definition보다
;;        ((assignment? exp) (eval-assignment exp env))
;;        ((definition? exp) (eval-definition exp env))
;;    application을
;;        ((application? exp) (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;    먼저 배치한다는 계획에서 잘못된 점은무엇인가?
;;   - (귀띔 : 저 생각대로 (define x 3) 식을 처리하면 어떻게 될까?)
;;
;;  이런식으로 함수 호출이 먼저 된다면?
;;
;;(define (eval exp env)
;;  (cond (
;;        ...
;;        ((variable? exp) ; symbol? 이면
;;         (lookup-variable-value exp env))
;;        ...
;;        ((application? exp) ; pair? 이면 함수 호출
;;         (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;        ...
;;        ((assignment? exp) ; set! 으로 시작
;;         (eval-assignment exp env))
;;       ((definition? exp) ; define 으로 시작
;;         (eval-definition exp env))
;;        ...
;;    )))
;;
;; - 간단히
;    - '(define x 3)가 pair?를 만족함으로 application(함수 콜)을 처리하는 로직에 떨어지게 됨.
;;   - 당연히 'define이라는 함수가 정의가 되지 않았으므로 에러 발생 예상.
;; - 자세히.
;;   - ((application? '(define x 3)) ; pair? 이면 함수 호출
;;   - (apply (eval 'define env) (list-of-values '(x 3) env)) 를 수행하게 되는데
;;     - (eval 'define env) 에서 'define은 심볼이므로
;;     - ((variable? 'define) (lookup-variable-value 'define env)) 로 떨어지게 됨
;;       - lookup-variable-value은 아직 구현이 나와있지 않으나 'define이 env에 정의되지 않았을 거임 그래서 에러가 발생할꺼.(에러가 발생안한다면 잘못된 구현)


;; b)언어 문법을 바꾸어서 프로시저 적용 식이 언제나 call로 시작되게 하자.
;;   - 보기를 들어， (factorial 3)은 (call factorial 3)으로， (+ 1 2)는 (call + 1 2)로 된다.
;;
;; eval함수에서 함수를 처리하는 부분은
;; ((application? exp) ; pair? 이면 함수 호출
;;   (apply (eval (operator exp) env) (list-of-values (operands exp) env)))
;;
;; exp가 (factorial 3) 에서 (call factorial 3) 식으로 바뀌었으므로
;; application? /  operator / operands 부분을 고쳐야함.


;; 단순 pair?로 체크하는걸 'call로 시작하는 리스트를 확인하는걸로 바꾸고
;(define (application? exp)
;;  (pair? exp))
(define (application? exp)
  (tagged-list? exp 'call))

;; rest로 첫번째 아이템('call)은 건너띄면 됨.
;;(define (operator exp)
;;  (first exp))
;;(define (operands exp)
;;  (rest exp))
(define (operator exp)
  (first (rest exp)))
 (define (operands exp)
  (rest (rest exp)))
</code></pre>
<h2 id="4_03"><a class="header" href="#4_03">4_03</a></h2>
<p>Exercise 2.73</p>
<pre><code class="language-lisp">;; file: 4_03.rkt

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require "../allcode/ch4-4.1.1-mceval.rkt")
(#%require "../allcode/ch3-3.3.3.rkt")

;; eval을 data-directed style 로 고쳐라
;; 그 후 Exercise 2.73 와 비교해보자
;;
;; 챕터 2.4.3에 data-directed style이 나온다.
;;
;; == basic style
;; (define (deriv exp var)
;;   (cond ((number? exp) ...)
;;         ((variable? exp)  ...)
;;         ((sum? exp) ...)
;;         ((product? exp) ...)
;;         (else  ...)
;;   ))
;; == data-directed style
;; (define (deriv exp var)
;;    (cond ((number? exp) ...)
;;          ((variable? exp)  ...)
;;          (else
;;            ((get 'deriv (operator exp)) (operands exp) var))
;;     ))
;;

;; eval에서 ***로 마크한 조건들이 data-directed style로 바뀌기 좋은 형태이다.
;;
;; (define (eval exp env)
;;   (cond ((self-evaluating? exp) ; 숫자? / 문자열?
;;         ((variable? exp)        ; symbol? 이면
;;     *** ((quoted? exp)          ; quote 로 시작
;;     *** ((assignment? exp)      ; set! 으로 시작
;;     *** ((definition? exp)      ; define 으로 시작
;;     *** ((if? exp)              ; if 로 시작
;;     *** ((lambda? exp)          ; lambda 로 시작
;;     *** ((begin? exp)           ; begin 으로 시작
;;     *** ((cond? exp)            ; cond 로 시작
;;         ((application? exp)     ; pair? 이면 함수 호출
;;         (else
;;   ))
;;
;;
;; (define (eval exp env)
;;   (cond ((self-evaluating? exp) ; 숫자? / 문자열?
;;         ((variable? exp)        ; symbol? 이면
;;     *** ((started-with-builtin-tag? exp)
;;     ***  ((get-tagged-func exp) exp env))
;;         ((application? exp)     ; pair? 이면 함수 호출
;;         (else
;;   ))
;;
;; 그리고 각 함수들에 대해 (tagged-func-name&gt; exp env) 이런 식으로 정규화를 시켜줘야 한다.

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((started-with-builtin-tag? exp)
         ((get-tagged-func exp) exp env))   
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (started-with-builtin-tag? exp)
  (if (not (pair? exp))
      false
      (not (null? (get-tagged-func exp)))))

(define (get-tagged-func exp)
  (let ((tag (first exp)))
    (get tag 'built-in)))

(define (tagged-func-quote  exp env) (text-of-quotation exp))
(define (tagged-func-assign exp env) (eval-assignment exp env))
(define (tagged-func-define exp env) (eval-definition exp env))
(define (tagged-func-if     exp env) (eval-if exp env))
(define (tagged-func-lambda exp env) (make-procedure (lambda-parameters exp) (lambda-body exp) env))
(define (tagged-func-begin  exp env) (eval-sequence (begin-actions exp) env))
(define (tagged-func-cond   exp env) (eval (cond-&gt;if exp) env))

(put 'quote  'built-in tagged-func-quote)
(put 'assign 'built-in tagged-func-assign)
(put 'define 'built-in tagged-func-define)
(put 'if     'built-in tagged-func-if)
(put 'lambda 'built-in tagged-func-lambda)
(put 'begin  'built-in tagged-func-begin)
(put 'cond   'built-in tagged-func-cond)
</code></pre>
<h2 id="4_04"><a class="header" href="#4_04">4_04</a></h2>
<pre><code class="language-lisp">;; file: 4_04.rkt

(#%require rackunit)
(#%require (prefix racket: racket))
(#%require "../allcode/helper/my-util.rkt")
(#%require "../allcode/ch4-4.1.1-mceval.rkt")

;; Install and and or as new special forms
;;

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))

        ;; 여기에 and/or 를 넣어주자.
        ((and? exp) (builtin-and exp env))
        ((or?  exp) (builtin-or  exp env))
        
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define (and? exp) (tagged-list? exp 'and))
(define (or?  exp) (tagged-list? exp 'or))

(define (builtin-and exp env)
  (define (iter env fst rst)
    (if (false? (lookup-variable-value fst env))
        false
        (if (null? rst)
            true
            (iter env (first rst) (rest rst)))))
  (let ((args (rest exp))) ; '(and 1 2 3) =&gt; '(1 2 3)
    (iter env (first args) (rest args))))

(define (builtin-or  exp env)
  (define (iter env fst rst)
    (if (true? (lookup-variable-value fst env))
        true
        (if (null? rst)
            false
            (iter env (first rst) (rest rst)))))
  (let ((args (rest exp))) ; '(or 1 2 3) =&gt; '(1 2 3)
    (iter env (first args) (rest args))))


(check-eq? (eval '(and true true true) (setup-environment)) true)
(check-eq? (eval '(and false true true) (setup-environment)) false)
(check-eq? (eval '(and true false true) (setup-environment)) false)
(check-eq? (eval '(and true true false) (setup-environment)) false)

(check-eq? (eval '(or false false false) (setup-environment)) false)
(check-eq? (eval '(or true false false) (setup-environment)) true)
(check-eq? (eval '(or false true false) (setup-environment)) true)
(check-eq? (eval '(or false false true) (setup-environment)) true)

(define env1 (setup-environment))
(define-variable! 'a true env1)
(check-eq? (eval '(or false false a) env1) true)

;; Derived expressions.
;; 4.1.2Representing Expressions
;;  - Derived expressions
;; (cond ((&gt; x 0) x)
;;       ((= x 0) (display 'zero) 0)
;;       (else (- x)))
;;
;; (if (&gt; x 0)
;;     x
;;     (if (= x 0)
;;         (begin (display 'zero) 0)
;;         (- x)))
;;
;; - cond는 if로 변환하여 계산됨
;;   -cond는 if로부터 파생된(derived) 표현식임)
;;
;; and / or 역시 if 로 변환하여 계산할 수 있음.


(define (expand-and clauses)
  (if (null? clauses)
      'true
      (let ((fst (car clauses))
            (rst (cdr clauses)))
        (make-if fst
                 (expand-and rst)
                 'false))))

(define (expand-or clauses)
  (if (null? clauses)
      'false
      (let ((fst (car clauses))
            (rst (cdr clauses)))
        (make-if fst
                 'true
                 (expand-or rst)))))

(define (builtin-and-derived exp env) (eval (expand-and (rest exp)) env))
(define (builtin-or-derived  exp env) (eval (expand-or  (rest exp)) env))

(set! builtin-and builtin-and-derived)
(set! builtin-or  builtin-or-derived)

(check-equal? (expand-and '(1 2 3)) '(if 1 (if 2 (if 3 true false) false) false))
(check-equal? (expand-or  '(1 2 3)) '(if 1 true (if 2 true (if 3 true false))))

(check-eq? (eval '(and true true true) (setup-environment)) true)
(check-eq? (eval '(and false true true) (setup-environment)) false)
(check-eq? (eval '(and true false true) (setup-environment)) false)
(check-eq? (eval '(and true true false) (setup-environment)) false)

(check-eq? (eval '(or false false false) (setup-environment)) false)
(check-eq? (eval '(or true false false) (setup-environment)) true)
(check-eq? (eval '(or false true false) (setup-environment)) true)
(check-eq? (eval '(or false false true) (setup-environment)) true)

(define env2 (setup-environment))
(define-variable! 'a true env2)
(check-eq? (eval '(or false false a) env2) true)
</code></pre>
<h2 id="4_05"><a class="header" href="#4_05">4_05</a></h2>
<pre><code class="language-lisp">;; file: 4_05.rkt

(#%require rackunit)
(#%require (prefix racket: racket))
(#%require "../allcode/helper/my-util.rkt")
(#%require "../allcode/ch4-4.1.1-mceval.rkt")

;; expand-clauses의 (sequence-&gt;exp (cond-actions first)) 부분을 수정하면 된다.
(define (cond-&gt;if exp)
  (expand-clauses (cond-clauses exp)))
 
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence-&gt;exp (cond-actions first))
                (error "ELSE clause isn't last -- COND-&gt;IF"
                       clauses))
            ;; Before:
            ;; (make-if (cond-predicate first)
            ;;             (sequence-&gt;exp (cond-actions first))
            ;;             (expand-clauses rest))
            ;; After:
            (if (=&gt;sequence? first)
                (make-if (cond-predicate first)
                         (expend=&gt;sequence first)
                         (expand-clauses rest))
                (make-if (cond-predicate first)
                         (sequence-&gt;exp (cond-actions first))
                         (expand-clauses rest)))))))


(define (=&gt;sequence? clause)
  (eq? (second clause) '=&gt;))

(define (expend=&gt;sequence clause)
  (list (third clause) (first clause)))

(check-equal? (expend=&gt;sequence '((assoc 'b '((a 1) (b 2))) =&gt; cadr))
              '(cadr (assoc 'b '((a 1) (b 2)))))

(check-equal? (cond-&gt;if '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                               (else false)))
              '(if (assoc 'b '((a 1) (b 2)))
                   (cadr (assoc 'b '((a 1) (b 2))))
                   false))



;;==== additional test
(check-equal? (cond-&gt;if '(cond ((= 1 1) true)
                               (else false)))
              '(if (= 1 1)
                   true
                   false))

(check-equal? (cond-&gt;if '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                               ((assoc 'b '((a 1) (b 2))) =&gt; cadr)))
              '(if (assoc 'b '((a 1) (b 2)))
                   (cadr (assoc 'b '((a 1) (b 2))))
                   (if (assoc 'b '((a 1) (b 2)))
                       (cadr (assoc 'b '((a 1) (b 2))))
                       false)))



;; eval test -----------------------

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! 'assoc (list 'primitive assoc) env2)
(define-variable! 'cadr (list 'primitive cadr) env2)

(check-equal? (eval '(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
                           (else false)) env2)
              2)
</code></pre>
<h2 id="4_06"><a class="header" href="#4_06">4_06</a></h2>
<pre><code class="language-lisp">;; file: 4_06.rkt
;; 4_07 / 4_08 / 4_09 / 4_16 / 4_17 / 4_18
;; 4_22


(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))

(racket:provide
 let?
 let-&gt;combination)


;; let-&gt;combination 구현 ------------------------------
;; 중첩 let을 생각안하면 4_07에서 오류를 맞이할거임.

(define (let-&gt;combination let-clause)
  (let* ((bindings (second let-clause))
         (vars (map first bindings))
         (exps (map second bindings))
         (body (rest (rest let-clause))))
    (cons (make-lambda vars body)
          exps)))

(check-equal? (let-&gt;combination '(let ((a 1) (b 2)) (+ a b)))
              '((lambda (a b) (+ a b)) 1 2))

(check-equal? (let-&gt;combination '(let () 1))
              '((lambda () 1))
              "empty")


;; eval이 let구문을 처리할 수 있도록 수정 ---------------

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)
(define (let? exp) (tagged-list? exp 'let))


;; test -----------------------

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(check-equal? (eval '(let ((a 1) (b 2)) (+ a b)) env2) 3)

(override-eval! origin/eval)
</code></pre>
<h2 id="4_07"><a class="header" href="#4_07">4_07</a></h2>
<pre><code class="language-lisp">;; file: 4_07.rkt
;; 4_06 cont

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))
(racket:provide
 make-let
 let*?
 let*-&gt;nested-lets)

;; 1-1. let*식이 여러개의 let식으로 변환될 수 있는지.
;;
;;  (let* ((x 3)
;;         (y (+ x 2))
;;         (z (+ x y 5)))
;;    (* x z)))
;;
;; (let ((x 3))
;;   (let ((y (+ x 2)))
;;     (let ((z (+ x y 5)))
;;       (* x z)))))
;;
;; 1-2. let*-&gt;nested-lets 를 작성해라.
(define (make-let binding body)
  ;; (make-let '((a 1)) '(1 2 3))
  ;; =&gt; (let ((a 1)) 1 2 3)
  (if (null? binding)
      (append (list 'let '()) body)
      (append (list 'let binding) body)))


(check-equal? (make-let '((b 1))
                        (list (make-let '((a 1))
                                        '((display) (display)))))
              '(let ((b 1))
                 (let ((a 1))
                   (display)
                   (display))))

(check-equal? (make-let '((b 1)) '('a 'b))
              '(let ((b 1)) 'a 'b))


(define (let*-&gt;nested-lets expr)
  (define (iter acc bs)
    (if (null? bs)
        acc
        (iter (make-let (list (first bs)) (list acc)) (rest bs))))
  (let* ((bindings (reverse (second expr)))
         (body (rest (rest expr))))
    (if (null? bindings)
        (make-let '() body)
        (iter (make-let (list (first bindings)) body) (rest bindings)))))

(define (let*? expr)
  (tagged-list? expr 'let*))

(check-equal? (let*-&gt;nested-lets
               '(let* ((x 3)
                       (y (+ x 2))
                       (z (+ x y 5)))
                  (* x z)))   
              '(let ((x 3))
                 (let ((y (+ x 2)))
                   (let ((z (+ x y 5)))
                     (* x z)))))

(check-equal? (let*-&gt;nested-lets
               '(let* () 1))
              '(let () 1))

(check-equal? (let*-&gt;nested-lets
               '(let* ((x 3)
                       (y x))
                  'a
                  'b))
              '(let ((x 3))
                 (let ((y x))
                   'a
                   'b)))

;; 2.1 eval에 (eval (let*-&gt;nested-lets exp) env)를 추가하면 동작할까?
;; 동작 한다.


(#%require "4_06.rkt")

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))

        ((let? exp) (eval (let-&gt;combination exp) env))   ; &lt;&lt;--- 저번 4_06에서 추가.
        ((let*? exp) (eval (let*-&gt;nested-lets exp) env)) ; &lt;&lt;--- 이번 4_07에서 추가.
        
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '* (list 'primitive *) env2)

(#%require (prefix r5rs: r5rs))
(define expression '(let* ((x 3)
                           (y (+ x 2))
                           (z (+ x y 5)))
                      (* x z)))

(#%require (prefix trace: racket/trace))

(check-equal? (eval expression env2)
              (r5rs:eval expression (scheme-report-environment 5)))

(override-eval! origin/eval)
</code></pre>
<h2 id="4_08"><a class="header" href="#4_08">4_08</a></h2>
<pre><code class="language-lisp">
#;(#%require errortrace)
;; file: 4_08.rkt
;; 4_06 cont

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(racket:require (racket:rename-in "4_06.rkt" (let-&gt;combination let-&gt;combination-normal)))

(racket:provide
 make-define
 let-&gt;combination)

;; 기존 let-&gt;combination
;; 
;; (let ((a 1) (b 2)) (+ a b)) =&gt; ((lambda (a b) (+ a b)) 1 2)
;;
;; (let &lt;var&gt; &lt;bindings&gt; &lt;body&gt;) 형태를 지원할 수 있도록 수정하해야함.
;;
;; 간단한 named-let expression이 다음과 같다고 하면,
;;
;; (let hello ((a 1) (b 2))
;;   (+ a b))
;;
;; a) lambda와 define사용.
;; ((lambda ()
;;    (define (hello a b)
;;      (+ a b))
;;    (hello 1 2)))
;;

(define (make-define func-name args body)
  (append (list 'define (append (list func-name) args)) body))

(check-equal? (make-define 'hello '(a b) '(1 2 3 4 5))
              '(define (hello a b) 1 2 3 4 5))

(define (let-named-&gt;combination let-clause)
  (let* ((bindings (third let-clause))
         (func-name (second let-clause))
         (vars (map first bindings))
         (exps (map second bindings))
         (body (rest (rest (rest let-clause)))))
    (list (make-lambda '()
                       (list (make-define func-name vars body)
                             (append (list func-name) exps))))))
    

(define (let-&gt;combination let-clause)
  (if (symbol? (second let-clause))
      (let-named-&gt;combination let-clause)      
      (let-&gt;combination-normal let-clause)))


(check-equal? (let-&gt;combination '(let ((a 1) (b 2)) (+ a b)))
              '((lambda (a b) (+ a b)) 1 2))

(check-equal? (let-&gt;combination '(let hello ((a 1) (b 2))
                                   (+ a b)))
              '((lambda ()
                  (define (hello a b)
                    (+ a b))
                  (hello 1 2))))

;; eval이 let구문을 처리할 수 있도록 수정 ---------------
(#%require "../allcode/ch4-4.1.1-mceval.rkt")

(define (let? exp) (tagged-list? exp 'let))
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '= (list 'primitive =) env2)

(check-equal? (eval '(let hello ((a 1) (b 2))
                       (+ a b))
                    env2)
              3)

(check-equal? (eval '(define (fib n)
                       (let fib-iter ((a 1)
                                      (b 0)
                                      (count n))
                         (if (= count 0)
                             b
                             (fib-iter (+ a b) 
                                       a 
                                       (- count 1)))))
                    env2)
              'ok)
(check-equal? (eval '(fib 10) env2) 55)
</code></pre>
<h2 id="4_09"><a class="header" href="#4_09">4_09</a></h2>
<pre><code class="language-lisp">;; file: 4_09.rkt
;; 4_06 4_07 cont

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require (prefix racket: racket))
(#%require (prefix r5rs/ r5rs))
(racket:provide
 do?
 while?
 until?
 do-&gt;expand
 while-&gt;do
 until-&gt;do)


;;  do / for / while / until 를 derived expression으로 구현해라
;; ref:
;; guile - do - https://www.gnu.org/software/guile/manual/html_node/while-do.html
;; common lisp - do - https://www.lispworks.com/documentation/HyperSpec/Body/m_do_do.htm
;; ruby - do for while until - https://www.geeksforgeeks.org/ruby/ruby-loops-for-while-do-while-until/

;; Derived expressions.
;; 4.1.2Representing Expressions
;;  - Derived expressions
;; (cond ((&gt; x 0) x)
;;       ((= x 0) (display 'zero) 0)
;;       (else (- x)))
;;
;; (if (&gt; x 0)
;;     x
;;     (if (= x 0)
;;         (begin (display 'zero) 0)
;;         (- x)))
;;
;; - cond는 if로 변환하여 계산됨
;;   -cond는 if로부터 파생된(derived) 표현식임)
(define (second-or-nil expr)
  (let ((x  (rest expr)))
    (if (null? x)
        nil
        (first x))))
(define (third-or-nil expr)
  (let ((x (rest (rest expr))))
    (if (null? x)
        nil
        (first x))))

(define (make-define func-name args body)
  (append (list 'define (append (list func-name) args)) body))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (comp f g h)
  (lambda (x)
    (h (f (g x)))))

(define (make-do vars assigns step-or-nils test ret body)
  (list 'let* (map list vars assigns)
        (make-define 'loop '()
                     (list (list 'if test
                                 ret
                                 (append (list 'begin)
                                         body
                                         (~&gt;&gt; (map (lambda (v x) (if (null? x) nil (list 'set! v x))) vars step-or-nils)
                                              (filter (comp not null? identity) ))
                                         '((loop))))))
        '(loop)))

(define (do-&gt;expand expr)
  (let* ((snd (second expr))
         (trd (third expr))
         (vars (map first snd))
         (assigns (map second snd))
         (step-or-nils (map third-or-nil snd))
         (test (first trd))
         (ret (second-or-nil trd))
         (body (rest (rest (rest expr)))))
    (make-do vars assigns step-or-nils test ret body)))

(check-equal? (do ((i 10 (dec i))
                   (j '()))
                ((&lt; i 0) j)
                (set! j (cons i j)))
              '(0 1 2 3 4 5 6 7 8 9 10))

(check-equal? (do-&gt;expand '(do ((i 10 (dec i))
                                (j '()))
                             ((&lt; i 0) j)
                             (set! j (cons i j))))
              
              '(let* ((i 10)
                      (j '()))
                 (define (loop)
                   (if (&lt; i 0)
                       j
                       (begin
                         (set! j (cons i j))
                         (set! i (dec i))
                         (loop))))
                 (loop)))



(define (while-&gt;do expr)
  (let ((vars '())
        (assigns '())
        (step-or-nils '())
        (test (second expr))
        (ret (quote '()))
        (body (rest (rest expr))))
    (make-do vars assigns step-or-nils (list 'not test) ret body)))

(check-equal? (while-&gt;do '(while (&gt; i 0)
                                 (set! i (dec i))))
              '(let* ()
                 (define (loop)
                   (if (not (&gt; i 0))
                       '()
                       (begin
                         (set! i (dec i))
                         (loop))))
                 (loop)))

(define (until-&gt;do expr)
  (let ((vars '())
        (assigns '())
        (step-or-nils '())
        (test (second expr))
        (ret (quote '()))
        (body (rest (rest expr))))
    (make-do vars assigns step-or-nils test ret body)))

(check-equal? (until-&gt;do '(until (&gt; i 5)
                                 (set! i (inc i))))
              '(let* ()
                 (define (loop)
                   (if (&gt; i 5)
                       '()
                       (begin
                         (set! i (inc i))
                         (loop))))
                 (loop)))

;; eval이 let구문을 처리할 수 있도록 수정 ---------------
(#%require (all-except "../allcode/ch4-4.1.1-mceval.rkt" eval))
(#%require "4_06.rkt")
(#%require "4_07.rkt")

(define (do? exp) (tagged-list? exp 'do))
(define (while? exp) (tagged-list? exp 'while))
(define (until? exp) (tagged-list? exp 'until))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env))   ; &lt;&lt;--- 저번 4_06에서 추가.
        ((let*? exp) (eval (let*-&gt;nested-lets exp) env)) ; &lt;&lt;--- 저번 4_07에서 추가.
        ((do? exp) (eval (do-&gt;expand exp) env)) ;; &lt;&lt;--- 추가.
        ((while? exp) (eval (while-&gt;do exp) env))
        ((until? exp) (eval (until-&gt;do exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '= (list 'primitive =) env2)
(define-variable! '&lt; (list 'primitive &lt;) env2)
(define-variable! '&gt; (list 'primitive &gt;) env2)
(define-variable! 'inc (list 'primitive inc) env2)
(define-variable! 'dec (list 'primitive dec) env2)
(define-variable! 'not (list 'primitive not) env2)


(check-equal? (eval '(do ((i 10 (dec i))
                          (j '()))
                       ((&lt; i 0) j)
                       (set! j (cons i j)))
                    env2)
              '(0 1 2 3 4 5 6 7 8 9 10))

(check-equal? (eval '(let ((acc '())
                           (i 5))
                       (while (&gt; i 0)
                              (set! acc (cons i acc))
                              (set! i (dec i)))
                       acc)
                    env2)
              '(1 2 3 4 5))

(check-equal? (eval '(let ((acc '())
                           (i 1))
                       (until (&gt; i 5)
                              (set! acc (cons i acc))
                              (set! i (inc i)))
                       acc)
                    env2)
              '(5 4 3 2 1))
</code></pre>
<h2 id="4_10"><a class="header" href="#4_10">4_10</a></h2>
<pre><code class="language-lisp">;; file: 4_10.rkt

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (all-except "../allcode/ch4-4.1.1-mceval.rkt" eval))

;; 기존 eval과 apply 코드는 그대로 두고 Scheme의 새로운 문법(syntax) 을 설계하고 구현하라.
;; define의 문법을 clojure 처럼 def / defn으로 변경.
;; -- scheme
;; (define x 10)
;; (define (foo a b c)
;;   (* a b c))
;;
;; -- clojure
;; (def x 10)
;; (defn foo [a b c]
;;   (* a b c))


(define (definition? exp)
  (or 
   (tagged-list? exp 'def)
   (tagged-list? exp 'defn)))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(check-equal? (definition-variable '(define (foo a b c)
                                      (* a b c)))
              'foo)

(define (definition-variable2 exp)
  (if (tagged-list? exp 'def)
      (second exp)
      (second exp)))

(check-equal? (definition-variable '(defn foo [a b c]
                                      (* a b c)))
              'foo)

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))

(check-equal? (definition-value '(define (foo a b c)
                                   (* a b c)))
              '(lambda (a b c) (* a b c)))

(define (definition-value2 exp)
  (if (tagged-list? exp 'def)
      (caddr exp)
      (make-lambda (third exp)
                   (rest (rest (rest exp))))))

(check-equal? (definition-value2 '(defn foo [a b c]
                                    (* a b c)))
              '(lambda (a b c) (* a b c)))

(define (eval-definition exp env)
  (define-variable! (definition-variable2 exp)
    (eval (definition-value2 exp) env)
    env)
  'ok)

;; racket모듈 특성상 동일한 코드를 다시 override할 필요가 있음.
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
(override-eval! eval)



(define env2 (setup-environment))
(define-variable! '* (list 'primitive *) env2)
(check-equal? (eval '(defn foo [a b c]
                       (* a b c))
                    env2)
              'ok)
(check-equal? (eval '(foo 2 3 4) env2)
              24)

(check-equal? (eval '(def x 10) env2)
              'ok)

(check-equal? (eval 'x env2)
              10)
</code></pre>
<h2 id="4_11"><a class="header" href="#4_11">4_11</a></h2>
<pre><code class="language-lisp">;; file: 4_11.rkt

(#%require rackunit)
(#%require threading)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix old: "../allcode/ch4-4.1.1-mceval.rkt"))

;; - 현재 frame형태
;;   - '((symbol-a symbol-b ...) value-a (primitive func-b) ...)
;; - 바꾸고자 하는 frame형태
;;   - '((symbol-a value-a) (symbol-b (primitive func-b)) ...)
;;
;; frame관련 함수들
;; - make-frame
;; - add-binding-to-frame!
;; - frame-variables
;; - frame-values

(define frame1 (old:make-frame '(a b) '(1 2)))
(check-equal? frame1
              '((a b) 1 2))
(old:add-binding-to-frame! 'c 3 frame1)
(check-equal? frame1
              '((c a b) 3 1 2))
(check-equal? (~&gt; (old:make-frame '(a b) '(1 2))
                  (old:frame-variables))
              '(a b))

(check-equal? (~&gt; (old:make-frame '(a b) '(1 2))
                  (old:frame-values))
              '(1 2))
(define (make-frame variables values)
  (map list variables values))

(define (add-binding-to-frame! var val frame)
  (let ((rst (rest frame))
        (var-val (list var val)))
    (set-cdr! frame (append rst (list var-val)))))

(define (frame-variables frame)
  (map first frame))
(define (frame-values frame)
  (map second frame))

(define frame2 (make-frame '(a b) '(1 2)))
(check-equal? frame2
              '((a 1) (b 2)))
(add-binding-to-frame! 'c 3 frame2)
(check-equal? frame2
              '((a 1) (b 2) (c 3)))
(check-equal? (~&gt; (make-frame '(a b) '(1 2))
                  (frame-variables))
              '(a b))
(check-equal? (~&gt; (make-frame '(a b) '(1 2))
                  (frame-values))
              '(1 2))
</code></pre>
<h2 id="4_12"><a class="header" href="#4_12">4_12</a></h2>
<pre><code class="language-lisp">;; file: 4_12.rkt
;; 4_13
(#%require rackunit)
(#%require threading)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))

(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (define-variable! origin/define-variable!)
                                  (set-variable-value! origin/set-variable-value!)
                                  (lookup-variable-value origin/lookup-variable-value)))
(racket:provide
 lookup-variable-values)

;; 주어진 함수들의 공통된 점을 묶어 추상화하고, 그 추상화를 이용하여 다시 정의하라.
;;
;; - define-variable!
;; - set-variable-value!
;; - lookup-variable-value 
;;
;; 3함수 모두 env를 돌며, variable의 찾음 여부에 따라 다른 동작들을 수행한다.
;; 종료조건은 var를 찾거나, env(frame list)를 모두 순회한 경우이다.
;; (단 define-variable!인 경우 첫번째 frame만 검사함. env(frame list)를 전부 순회하지 않음.
;;
;; 기타. env 는 [frame1 frame2 ..] 이다.

;; =======================================
(define (lookup-variable-values var env)
  ;; 함수 모양이 맘에 안들지만, 일단 기존 코드 모양의 수정을 최소화하겠다.
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             vals)   ; &lt;&lt;------------ 찾으면 vals를 반환한다.
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        nil          ; &lt;&lt;------------ 못찾으면 nil을 반환한다.
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))


(define (lookup-variable-value var env)
  (let ((vals (lookup-variable-values var env)))
    (if (null? vals)
        (error "Unbound variable" var)
        (first vals))))

(define (set-variable-value! var val env)
  (let ((vals (lookup-variable-values var env)))
    (if (null? vals)
        (error "Unbound variable -- SET!" var)
        (set-car! vals val))))

(define (define-variable! var val env)
  (let* ((frame (first-frame env))
         (toplevel-env (extend-environment (frame-variables frame) (frame-values frame) the-empty-environment))
         (vals (lookup-variable-values var toplevel-env)))
    (if (null? vals)
        (add-binding-to-frame! var val frame)
        (set-car! vals val))))

;; testing =======================================
(define env1 (setup-environment))
(check-equal? (lookup-variable-value 'car env1)
              (list 'primitive car))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-exn #rx"Unbound variable -- SET! x"
           (lambda () (set-variable-value! 'x 1 env1)))
(define-variable! 'x 5 env1)
(check-equal? (lookup-variable-value 'x env1)
              5)
(set-variable-value! 'x 1 env1)
(check-equal? (lookup-variable-value 'x env1)
              1)
</code></pre>
<h2 id="4_13"><a class="header" href="#4_13">4_13</a></h2>
<pre><code class="language-lisp">;; file: 4_13.rkt
;; 4_12

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(racket:require "../allcode/ch4-4.1.1-mceval.rkt")

;; scheme에서 define해서 정의한 변수를 지울 수 없음.
;;
;; 1-1. make-unbound! 함수를 만들어 env에서 지울 수 있도록 만들자.
;;
;; 1-2. first-frame에서만 지우면 되는가?
;;
;; - 현재 스코프(첫 프레임)내에서 선언 삭제가 됨으로, 직관적.
;; - 첫 번째 프레임만 뒤지면 되니 탐색이 빠르고 코드가 단순함.
;; - 상위 프레임에 중복된 이름은 살아있음.
;;
;; 앞선 define-variable!도 현재 스코프(첫 프레임)에서만 선언하고 있음.
;;
;; 초판 1985년: SICP
;; 초판 1991년: EOPL Essentials of Programming Languages by Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes.
;; 초판 1996년: PLP Programming Language Pragmatics by Michael L Scott - https://www.cs.rochester.edu/~scott/pragmatics/
;; 초판 2002년: TaPL Types and Programming Languages by Benjamin C. Pierce - https://www.cis.upenn.edu/~bcpierce/tapl/index.html
;;  etc. https://softwarefoundations.cis.upenn.edu/


(define (lookup-variable-vars-vals var env)
  ;; 함수 모양이 맘에 안들지만, 일단 기존 코드 모양의 수정을 최소화하겠다.
  ;; values도 있으나, 그냥 list로 감싸겠다. - https://docs.racket-lang.org/reference/values.html
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (list vars vals))   ; &lt;&lt;------------ 찾으면 (vars vals)를 반환한다.
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (list nil nil)          ; &lt;&lt;------------ 못찾으면 (nil nil)을 반환한다.
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (make-unbound! env var is-toplevel-only)
  (define (which-env env is-toplevel-only)
    (if (not is-toplevel-only)
        env
        (let* ((frame (first-frame env))
               (search-env (extend-environment (frame-variables frame) (frame-values frame) the-empty-environment)))
          search-env)))
  (let* ((frame (first-frame env))
         (search-env (which-env env is-toplevel-only))
         (vars-vals (lookup-variable-vars-vals var search-env))
         (vars (first vars-vals))
         (vals (second vars-vals)))
    (if (null? vals)
        nil
        (begin
          (let ((rst (rest vars)))
            (set-car! vars (first rst))
            (set-cdr! vars (rest rst)))
          (let ((rst (rest vals)))
            (set-car! vals (first rst))
            (set-cdr! vals (rest rst)))))))

#;(define env1 (setup-environment))

#;(let ((frame (first-frame env1)))
    frame)
;; testing =======================================
(define env1 (setup-environment))
(check-equal? (lookup-variable-value 'car env1)
              (list 'primitive car))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-exn #rx"Unbound variable -- SET! x"
           (lambda () (set-variable-value! 'x 1 env1)))
(define-variable! 'x 5 env1)
(check-equal? (lookup-variable-value 'x env1)
              5)
(set-variable-value! 'x 1 env1)
(check-equal? (lookup-variable-value 'x env1)
              1)
(make-unbound! env1 'x #t)
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))

(check-equal? env1 (setup-environment))
</code></pre>
<h2 id="4_14"><a class="header" href="#4_14">4_14</a></h2>
<pre><code class="language-lisp">;; file: 4_14.rkt

(#%require rackunit)
(#%require threading)
(#%require (prefix racket: racket))
(#%require (prefix r5rs: r5rs))

(racket:require "../allcode/ch4-4.1.1-mceval.rkt")
;;
;; 1. Eva Lu Ator은 map의 정의를 직접 입력해서 평가하는 방식.
;; 2. Louis Reasoner는 map을 primitive-procedures에 넣어 버리는 방식.
;; Eva Lu Ator는 잘 동작하는데, Louis Reasoner는 동작하지 않는 이유는?
;;
;; env는
;; 1에서의 map은 (procedure (proc items) ((if (null? items) '() ...) 형태로 저장
;; 2에서의 map은 (primitive #&lt;procedure:mcar&gt;) 형태로 저장.
;; 작성한 eval&amp;apply과정에서 사용하는 데이터가 r5rs에서의 과정과 사용하는 데이터가 맞지않음.

;; 1. Eva Lu Ator (aka, Evaluator) 방식
;;

(define env1 (setup-environment))
(check-equal? (eval '(define (map proc items)
                       (if (null? items)
                           '()
                           (cons (proc (car items))
                                 (map proc (cdr items)))))
                    env1)
              'ok)
(check-equal? (eval '(map car '((a 1) (b 2) (c 3))) env1)
              '(a b c))

;; 2. Louis Reasoner (akka, loose reasoner)
;;
(define env2 (setup-environment))
(define-variable! 'map (list 'primitive map) env2) ; 아니면 primitive-procedures를 직접 수정.

(check-exn
 racket:exn:fail?
 (lambda ()
   ;; (r5rs:apply map (list (list 'primitive car) '((a 1) (b 2) (c 3)))) 와 같음.
   ;; application: not a procedure;
   ;;  expected a procedure that can be applied to arguments
   ;;   given: (primitive #&lt;procedure:mcar&gt;)
   (eval '(map car '((a 1) (b 2) (c 3))) env2)))

</code></pre>
<h2 id="4_15"><a class="header" href="#4_15">4_15</a></h2>
<pre><code class="language-lisp">;; file: 4_15.rkt

;;
;; 정지 문제:
;; - Halting Problem: https://en.wikipedia.org/wiki/Halting_problem
;; - SCOOPING THE LOOP SNOOPER -  http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html
;;

;; 가정:
;; 함수 p와 오브젝트 a가 있을시, (p a)를 호출하면 값을 반환하거나, 에러를 뱉거나, 끊임없이 동작한다고 가정하자.
;;
;; 문제:
;; 함수 p와 입력값 a에 대해, (p a)시 멈추는지 아닌지 판별하는 halts?라는 함수를 작성하는게 불가능 하다.
;; 이를 증명해보아라.
;;
;; 증명:
;; 귀류법: 해결방법이 있다라는 가정에서 모순이 발생한다는 것을 보임으로써 증명한다.
;;
;; 만일 halts?라는게 있다면 다음코드를 작성할 수 있을 것이며,
;; 
;; (define (run-forever)
;;   (run-forever))
;; 
;; (define (try p)
;;   (if (halts? p p)
;;       (run-forever)
;;       'halted))
;;
;; 그런 다음, (try try)를 호출하면 결과가 어떻든(값을 반환하거나, 에러를 뱉거나, 끊임없이 동작),
;; halts?의 정의에 어긋남을 밝히면 된다.
;;
;; (halts? p a)는 (p a)시 멈춘다면 true반환할 것이다.
;; (try try)
;;  =&gt; (halts? try try) - 만약 참이라면 (try try)시 멈춘다는 말이다. 하지만,
;;   =&gt; 조건문을 만족시키면서 (run-forever)로 돌면서 (try try)는 멈추지 않고 끊임없이 동작할 것이다.
;;  =&gt;(halts? try try) - 만약 것짓이라면, (try try)시 멈추지 않는다는 말이다. 하지만,
;;   =&gt; 조건문을 만족시키지 못하면서 'halted를 반환하면서 (try try)는 멈추게 된다.:
;; 이 모순된 상황은 halts?의 정의와는 맞지않다.
</code></pre>
<h2 id="4_16"><a class="header" href="#4_16">4_16</a></h2>
<pre><code class="language-lisp">;; file: 4_16.rkt
;; 4_06 / 4_18 cont

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(#%require (prefix trace: racket/trace))

(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_lookup-variable-value origin/lookup-variable-value)
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))
(racket:require (racket:prefix-in ex4_06/ "4_06.rkt"))

(racket:provide
 lookup-variable-value
 scan-out-defines)
;;
;; 1. lookup-variable-value 함수를 고쳐서 변수의 값이 심볼 *unassigned* 면 오류를 내도록 한다.
;;

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             ;; - before
             ;; (car vals)
             ;;
             ;; - after
             (let ((found (car vals)))
               (if (eq? found '*unassigned*)
                   (error "Unssigned variable" var)
                   found)))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(override-lookup-variable-value! lookup-variable-value)


(define env1 (setup-environment))
(check-exn #rx"Unbound variable x"
           (lambda () (lookup-variable-value 'x env1)))
(check-equal? (eval '(define x '*unassigned*) env1)
              'ok)
(check-exn #rx"Unssigned variable x"
           (lambda () (lookup-variable-value 'x env1)))

;;
;; 2. procedure body를 받아(lambda로 시작하는) 앞에 본것처럼 내부에 define이 없도록 변환과정을 거쳐 반환하는 scan-out-defines를 작성해라.
;;
;; - before
;; (lambda &lt;vars&gt;
;;  (define u &lt;e1&gt;)
;;  (define v &lt;e2&gt;)
;;  &lt;e3&gt;)
;;
;; - after
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (set! u &lt;e1&gt;)
;;    (set! v &lt;e2&gt;)
;;    &lt;e3&gt;)))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (complement f)
  (lambda (x)
    (not (f x))))

(define (make-let bindings body)
  ;; (make-let '((a 1)) '((+ a 2)))
  ;; =&gt; (let ((a 1)) (+ a 2))
  (append (list 'let bindings) body))

(define (scan-out-defines body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((body-without-defs (filter (complement definition?) body))
               (vars (map definition-variable defs))
               (vals (map definition-value defs))
               (bindings (map (lambda (x) (list x ''*unassigned*)) vars))
               (assigns (map (lambda (x y) (list 'set! x y)) vars vals)))
          (list (make-let bindings
                          (append assigns body-without-defs)))))))


(check-equal? (scan-out-defines (lambda-body '(lambda (x)
                                                (define u 1)
                                                (define v 2)
                                                (+ u v x))))
              '((let ((u '*unassigned*)
                      (v '*unassigned*))
                  (set! u 1)
                  (set! v 2)
                  (+ u v x))))

;;
;; 3. scan-out-defines 을 인터프리터안에 넣는데,
;;    - make-procedure 쪽이 좋을까 procedure-body 쪽이 좋을까?
;;       make-procedure 쪽
;;    - 그리고 그 이유는?
;;       eval타임인가 apply타임인가 문제인데,
;;      인터프리터 구현체가 eval타임에서 구문을 확장하고 apply를 돌며 실제 scheme쪽 apply를 호출.
;;      eval타임에서 구문을 확장해 나갈때 같이 확장해 놓는게 좋다.

;; === make-procedure
;; (define (make-procedure parameters body env)
;;   (list 'procedure parameters body env))
;; 
;; (define (eval exp env)
;;   (cond (
;;          ...
;;          ((lambda? exp)
;;           (make-procedure (lambda-parameters exp) ; &lt;-----------------------
;;                           (lambda-body exp)
;;                           env))
;;          ...
;;          )))
;; 
;; === procedure-body
;; (define (procedure-body p) (caddr p)) ;; third
;; 
;; (define (apply procedure arguments)
;;    (cond ((primitive-procedure? procedure)
;;          (apply-primitive-procedure procedure arguments))
;;         ((compound-procedure? procedure)
;;          (eval-sequence
;;           (procedure-body procedure) ; &lt;-----------------------
;;           (extend-environment
;;            (procedure-parameters procedure)
;;            arguments
;;            (procedure-environment procedure))))
;;         (else
;;          (error
;;           "Unknown procedure type -- APPLY" procedure))))

;; 수정한다면,
(define env2 (setup-environment))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '+ (list 'primitive +) env3)

(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env2)
                          'ok)

            ;; hello body의 define이 lambda로 풀어진 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env2))
                          '(((lambda (u v)
                               (set! u 1)
                               (set! v 2)
                               (+ u v x))
                             '*unassigned*
                             '*unassigned*)))
            (check-equal? (eval '(hello 3) env2)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))

(around
 (begin
   (define (procedure-body p)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (scan-out-defines (third p))
     ;;
     ;; 추가하지 않았다면,
     (map (lambda (x)
            (if (ex4_06/let? x)
                (ex4_06/let-&gt;combination x)
                x))
          (scan-out-defines (third p))))
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! procedure-body))
 
 (test-case "procedure-body"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env3)
                          'ok)

            ;; hello body의 define이 lambda로 풀어지지 않은 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env3))
                          '((define u 1)
                            (define v 2)
                            (+ u v x)))
            
            ;; application평가시에 scan-out-defines이 일어남
            (check-equal? (eval '(hello 3) env3)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))


(override-lookup-variable-value! origin/lookup-variable-value)
</code></pre>
<h2 id="4_17"><a class="header" href="#4_17">4_17</a></h2>
<pre><code class="language-lisp">;; file: 4_17.rkt
;; 4_06 cont
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(#%require (prefix trace: racket/trace))
(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))
(racket:require (racket:prefix-in ex4_06/ "4_06.rkt"))
;; 본문에 나온 &lt;e3&gt;을 평가할때의 environment를 다이어그램으로 그려라
;;
;; 첫번째 방식
;; (lambda (x)
;;   (define u 1)    ; 실행 시, 현재 프레임에 u를 만들고 값 1 할당
;;   (define v 2)    ; 실행 시, 현재 프레임에 v를 만들고 값 2 할당
;;   (+ u v x))
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +------------------+
;;              | Frame F1         |   (procedure call frame)
;;              +------------------+
;;              | x = ARG          |
;;              | u = 1            |
;;              | v = 2            |
;;              +------------------+
;;                   |
;;       e3: (+ u v x)  ; lookup all in F1

;;
;; 두번째 방식(변환된 방식)
;; (lambda (x)
;;   (let ((u '*unassigned*)
;;         (v '*unassigned*))
;;     (set! u 1)
;;     (set! v 2)
;;     (+ u v x)))
;; 
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: let ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +----------------+
;;              | Frame F1       |   (procedure call frame)
;;              +----------------+
;;              | x = ARG        |
;;              +----------------+
;;                   |
;;                   v
;;              +------------------+
;;              | Frame F2         |   (let frame)
;;              +------------------+
;;              | u = *unassigned* |
;;              | v = *unassigned* |
;;              +------------------+
;;       set! u 1
;;       set! v 2
;;       e3: (+ u v x)  ; u,v in F2, x in F1
;;

;;
;; 변환된 프로그램에서 왜 추가 프레임(extra frame)이 생기는가?
;; =&gt; let이 lambda로 변환되면서 frame이 생성

;; 왜 이 차이가 동작에 영향을 주지 않는가?
;; =&gt; 값을 참조하는 시점에는 이미 초기화 되어있음.

;; 추가 프레임을 만들지 않고, 내부 정의에 대해 "동시(simultaneous)" 스코프 규칙을 인터프리터가 구현하도록 하는 방법을 설계하라.
;; simultaneous 발음
;; 미국식 ˌsaɪ.məlˈteɪ.niəs / 사이멀테이니어스
;; 영국식 ˌsɪm.əlˈteɪ.ni.əs / 시멀테이니어스
;;
;; simultaneous 방식( 두번째와 비슷하지만 추가 프레임 생성 안함.)
;; (lambda (x)
;;   (define u '*unassigned*)
;;   (define v '*unassigned*)
;;   (set! u (+ v 1))
;;   (set! v 2)
;;   (+ u v x))
;; 
;; Global Env
;;    |
;;    v
;; +----------------+
;; | proc           | --&gt; [params: (x) body: ...] Env=Global
;; +----------------+
;;                      \
;;                       v
;;              +------------------+
;;              | Frame F1         |   (procedure call frame)
;;              +------------------+
;;              | x = ARG          |
;;              | u = *unassigned* |
;;              | v = *unassigned* |
;;              +------------------+
;;                   |
;;       set! u 1
;;       set! v 2
;;       e3: (+ u v x)  ; lookup all in F1
;;

(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (complement f)
  (lambda (x)
    (not (f x))))

(define (scan-out-defines-simultaneous body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((vars (map definition-variable defs))
               (vals (map definition-value defs))
               (unassigns-defs (map (lambda (var) (list 'define var ''*unassigned*)) vars))
               (assigns (map (lambda (x y) (list 'set! x y)) vars vals))
               (body-without-defs (filter (complement definition?) body)))
          ;; 현재 프레임에 바인딩 추가만 하고 let은 안 씀
          (append
           unassigns-defs
           assigns
           body-without-defs)))))

(check-equal? (scan-out-defines-simultaneous (lambda-body '(lambda (x)
                                                             (define u (+ v 1))
                                                             (define v 2)
                                                             (+ u v x))))
              '((define u '*unassigned*)
                (define v '*unassigned*)
                (set! u (+ v 1))
                (set! v 2)
                (+ u v x)))

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)


(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines-simultaneous body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v 2)
                                   (+ u v x))
                                env2)
                          'ok)

            ;; hello body의 define이 lambda로 풀어진 상태로 저장되어 있다.
            (check-equal? (third (lookup-variable-value 'hello env2))
                          '((define u '*unassigned*)
                            (define v '*unassigned*)
                            (set! u 1)
                            (set! v 2)
                            (+ u v x)))
            (check-equal? (eval '(hello 3) env2)
                          6)
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))
</code></pre>
<h2 id="4_18"><a class="header" href="#4_18">4_18</a></h2>
<pre><code class="language-lisp">;; file: 4_18.rkt
;; 4_06 / 4_16 / 4_20 cont

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(#%require (prefix trace: racket/trace))

(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt"
                                  (_make-procedure origin/make-procedure)
                                  (_procedure-body origin/procedure-body)))
(racket:require (racket:prefix-in ex4_06/ "4_06.rkt"))
(racket:require (racket:prefix-in ex4_16/ "4_16.rkt"))

;; - before
;; (lambda &lt;vars&gt;
;;  (define u &lt;e1&gt;)
;;  (define v &lt;e2&gt;)
;;  &lt;e3&gt;)
;;
;; - 본문방식
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (set! u &lt;e1&gt;)
;;    (set! v &lt;e2&gt;)
;;    &lt;e3&gt;)))
;;
;; - 이번 문제 방식
;;   - 여기서 a와 b는 인터프리터가 새로 생성한 변수명으로, 사용자의 원래 프로그램에는 등장하지 않는다.
;; (lambda &lt;vars&gt;
;;  (let ((u '*unassigned*)
;;        (v '*unassigned*))
;;    (let ((a &lt;e1&gt;)
;;          (b &lt;e2&gt;))
;;      (set! u a)
;;      (set! v b))
;;    &lt;e3&gt;))
;;
;; 3.5.4의 solve는
;; (define (solve f y0 dt)
;;  (define y (integral (delay dy) y0 dt))
;;  (define dy (stream-map f y))
;;  y)
;;
;; - 본문방식이면
;; (let ((y '*unassigned*)
;;       (dy '*unassigned*))
;;   (set! y (integral (delay dy) y0 dt))
;;   (set! dy (stream-map f y))          ; &lt;---- dy에 제대로 된 값이 저장된다.
;;   (+ u v x)))
;;
;; - 이번 문제 방식에서는 이렇게 변환된다.
;; (let ((y '*unassigned*)
;;       (dy '*unassigned*))
;;   (let ((a (integral (delay dy) y0 dt))
;;         (b (stream-map f y)))         ; &lt;---- b에 (stream-map f '*unassigned*)라는 올바르지 않은 값이 저장되고, 4_16을 구현했으면 y를 가져다 쓰는 순간 에러.
;;     (set! y a)
;;     (set! dy b))                      ; &lt;---- 최종적으로 dy에 제대로 되지않은 b값이 저장된다.
;;   (+ u v x)))


(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate 
                       (cdr sequence))))
        (else  (filter predicate 
                       (cdr sequence)))))

(define (take n lst)
  (define (iter n lst acc)
    (cond
      ((or (&lt;= n 0) (null? lst))
       (reverse acc))
      (else
       (iter (- n 1) (cdr lst) (cons (car lst) acc)))))
  (iter n lst '()))


(define (complement f)
  (lambda (x)
    (not (f x))))

(define (make-let bindings body)
  ;; (make-let '((a 1)) '((+ a 2)))
  ;; =&gt; (let ((a 1)) (+ a 2))
  (append (list 'let bindings) body))

(define (scan-out-defines-4_18 body)
  (let ((defs (filter definition? body)))
    (if (null? defs)
        body
        (let* ((body-without-defs (filter (complement definition?) body))
               (vars (map definition-variable defs))
               (vals (map definition-value defs))
               (len (length vars))
               (var2 (take len '(a b c d e f g)))
               (bindings (map (lambda (x) (list x ''*unassigned*)) vars))
               (bindings2 (map (lambda (x y) (list x y)) var2 vals))
               (assigns (map (lambda (x y) (list 'set! x y)) vars var2)))
          (list (make-let bindings
                          (append (list (make-let bindings2
                                                  assigns))
                                  body-without-defs)))))))


(check-equal? (scan-out-defines-4_18 (lambda-body '(lambda (x)
                                                     (define u 1)
                                                     (define v (+ 2 u))
                                                     (+ u v x))))
              '((let ((u '*unassigned*)
                      (v '*unassigned*))
                  (let ((a 1)
                        (b (+ 2 u)))
                    (set! u a)
                    (set! v b))
                  (+ u v x))))



(define env2 (setup-environment))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '+ (list 'primitive +) env3)

(override-lookup-variable-value! ex4_16/lookup-variable-value)

(around
 (begin
   (define (make-procedure parameters body env)
     ;; 4_06에서 ((let? exp) (eval (let-&gt;combination exp) env)) 을
     ;; 추가 했다면.
     ;; (list 'procedure parameters (scan-out-defines-4_18 body) env)
     ;;
     ;; 추가하지 않았다면,
     (list 'procedure parameters
           (map (lambda (x)
                  (if (ex4_06/let? x)
                      (ex4_06/let-&gt;combination x)
                      x))
                (scan-out-defines-4_18 body))
           env))
   (override-make-procedure! make-procedure)
   (override-procedure-body! origin/procedure-body))
  
 
 (test-case "make-procedure"
            (check-equal? (eval '(define (hello x)
                                   (define u 1)
                                   (define v (+ 2 u))
                                   (+ u v x))
                                env2)
                          'ok)

            (check-exn #rx"Unssigned variable u"
                       (lambda ()
                         (eval '(hello 3) env2)))
            )
 (begin
   (override-make-procedure! origin/make-procedure)
   (override-procedure-body! origin/procedure-body)))
</code></pre>
<h2 id="4_19"><a class="header" href="#4_19">4_19</a></h2>
<pre><code class="language-lisp">;; file: 4_19.rkt


;; (let ((a 1))
;;   (define (f x)
;;     (define b (+ a x))
;;     (define a 5)
;;     (+ a b))
;;   (f 10))

;; Ben Bitdiddle 의견
;; 순차적 규칙(sequential rule) - c / python ...
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = 11 (+ a x)
;; a = 5
;; 
;; (+ a b) =&gt; 16

;; Alyssa P. Hacker 의견
;; 동시 범위(simultaneous scope) 규칙 - scheme
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = *unassigned*
;; a = *unassigned*
;; b = 에러발생 (+ *unassigned* x)

;; Eva Lu Ator 의견
;; Layzy Evaluation - haskell / OCaml ...
;; a = 1  (let ((a 1))
;; x = 10 (f 10)
;; b = lazy(+ a x)
;; a = 5
;; 
;; (+ a b) = 5 + lazy(+ a x)
;;         = 5 + (+ 5 10)
;;         = 20


;; 1. 세 가지 관점 중 어느 것(또는 어느 것도 아닌 것)을 지지하는가?
;; 살짝 정적 분석같은 기믹도 가미된 Alyssa P.
;;
;; 2. Eva Lu Ator 의견에 따라 동작하도록 구현할 수 있는가?
;; 정의부를 lambda식으로 감싸 실제 필요할때 평가도록 하면 될꺼같은데...


</code></pre>
<h2 id="4_20"><a class="header" href="#4_20">4_20</a></h2>
<pre><code class="language-lisp">;; file: 4_20.rkt
;; 4_17 / 4_18 / 4_21

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.1.1-mceval.rkt" (_eval origin/eval)))


;; | 구문       | 바인딩 생성 방식                  | 앞 변수 참조 | 상호/자기 참조 |
;; | -------- | ----------------------------------- | ------------ | -------------- |
;; | `let`    | 모든 값 먼저 계산 후 한 번에 바인딩 | ❌          | ❌            |
;; | `let*`   | 순차적으로 바인딩 생성              | ⭕          | ❌            |
;; | `letrec` | 이름만 먼저 바인딩 후 값 설정       | ⭕          | ⭕            |

;; letrec: let recursive

;;
;; a. letrec을 derived expression로 처리. 연습문제 4.18 처럼 변수는 let으로 생성, set!으로 설정하라.
;;
(#%require (only "4_06.rkt" let? let-&gt;combination))
(#%require (only "4_07.rkt" make-let ))

(define (letrec-&gt;let expr)
  (let* ((bindings (second expr))
         (body (rest (rest expr)))
         (vars (map first bindings))
         (new-bindings (map (lambda (x) (list x ''*unassigned*)) vars))
         (vals (map second bindings))
         (setter (map (lambda (x y) (list 'set! x y)) vars vals)))
    (make-let new-bindings (append setter body))))

(check-equal? (letrec-&gt;let
               '(letrec ((x 1))
                  (+ x 2)))
              '(let ((x '*unassigned*))
                 (set! x 1)
                 (+ x 2)))

(check-equal? (letrec-&gt;let
               '(letrec ((fact
                          (lambda (n)
                            (if (= n 1)
                                1
                                (* n (fact (- n 1)))))))
                  (fact 10)))
              '(let ((fact '*unassigned*))
                 (set! fact
                       (lambda (n)
                         (if (= n 1)
                             1
                             (* n (fact (- n 1))))))
                 (fact 10)))

(define (letrec? exp) (tagged-list? exp 'letrec))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((let? exp) (eval (let-&gt;combination exp) env))
        ((letrec? exp) (eval (letrec-&gt;let exp) env)) ;; &lt;&lt;--- 추가.
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(override-eval! eval)
(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(define-variable! '- (list 'primitive -) env2)
(define-variable! '* (list 'primitive *) env2)
(define-variable! '= (list 'primitive =) env2)

(check-equal? (eval '(letrec ((x 1))
                       (+ x 2))
                    env2)
              3)

(check-eq? (eval '(letrec ((fact
                            (lambda (n)
                              (if (= n 1)
                                  1
                                  (* n (fact (- n 1)))))))
                    (fact 10))
                 env2)
           3628800)

(check-eq? (letrec ((fact
                     (lambda (n)
                       (if (= n 1)
                           1
                           (* n (fact (- n 1)))))))
             (fact 10))
           3628800)
;; 
;; b. (f 5)를 평가하는 동안 &lt;rest of body of f&gt;가 평가되는 환경(environment)을 나타내는
;; letrec버전 let버전에 대한  environment diagram을 그려라.
;; (odd?/even?은 이미 정의되어 있어, 오류를 확인하기 위해 odd?/even?을 new-odd?/new-even?으로 변경.)

;; let 버전
(define expr-v-let
  '(define (f x)
     ;; (f 5)
     ;; f 호출 환경 (x = 5)
     ;; ┌─────────────────────────────┐
     ;; │ f-frame                     │
     ;; │ x → 5                       │
     ;; └─────────────────────────────┘
     ;; 
     ;; let-frame
     ;; ┌─────────────────────────────┐
     ;; │ new-even? → &lt;lambda&gt;        │ &lt;&lt; lambda를 정의시 new-odd?를 찾아보는데 정의가 되지않아 오류가 나타난다.
     ;; │ new-odd?                    |
     ;; └─────────────────────────────┘
     (let ((new-even?
            (lambda (n)
              (if (= n 0)
                  true
                  (new-odd? (- n 1))))) ; new-odd?: unbound identifier in: new-odd?
           (new-odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (new-even? (- n 1))))))
       "&lt;rest of body of f&gt;"
       (new-even? x))))
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env3)
(define-variable! '- (list 'primitive -) env3)
(define-variable! '* (list 'primitive *) env3)
(define-variable! '= (list 'primitive =) env3)
(check-equal? (eval expr-v-let
                    env3)
              'ok)
(check-exn #rx"Unbound variable new-odd?"
           (lambda ()
             (eval '(f 5) env3)))


;; letrec 버전
(define expr-v-letrec
  '(define (f x)
     ;; (f 5)
     ;; f 호출 환경 (x = 5)
     ;; ┌─────────────────────────────┐
     ;; │ f-frame                      │
     ;; │ x → 5                        │
     ;; └─────────────────────────────┘
     ;; 
     ;; letrec-frame
     ;; ┌─────────────────────────────┐
     ;; │ new-even? → &lt;unassigned&gt;    │
     ;; │ new-odd?  → &lt;unassigned&gt;    │
     ;; └─────────────────────────────┘
     ;; set! new-even? &lt;lambda&gt;
     ;; set! new-odd?  &lt;lambda&gt;
     (letrec ((new-even?
               (lambda (n)
                 (if (= n 0)
                     true
                     (new-odd? (- n 1)))))
              (new-odd?
               (lambda (n)
                 (if (= n 0)
                     false
                     (new-even? (- n 1))))))
       "&lt;rest of body of f&gt;"
       (new-even? x))))

(define env4 (setup-environment))
(define-variable! '+ (list 'primitive +) env4)
(define-variable! '- (list 'primitive -) env4)
(define-variable! '* (list 'primitive *) env4)
(define-variable! '= (list 'primitive =) env4)
(check-equal? (eval expr-v-letrec
                    env4)
              'ok)
(check-eq? (eval '(f 5) env4)
           false)


(override-eval! origin/eval)
</code></pre>
<h2 id="4_21"><a class="header" href="#4_21">4_21</a></h2>
<pre><code class="language-lisp">;; file: 4_21.rkt

(#%require rackunit)
(#%require (only racket λ))

;; Stoy 1977 for details on the λ-calculus,
;;Gabriel 1988 for an exposition of the  Y operator in Scheme

;; lambda calculus 람다 대수.
;; - https://en.wikipedia.org/wiki/Lambda_calculus
;; - [Lambda Calculus - Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript](https://www.youtube.com/watch?v=3VQ382QG-y4)
;; - 모든 기계적인 계산은 람다 대수로 표현할 수 있다
;; - turing completeness 만족.
;;   - 어떤 프로그래밍 언어나 추상 기계가 튜링 기계와 동일한 계산 능력을 가진다는 의미
;;
;; Application
;; f x       = (f x)
;; f x y     = ((f x) y) = (f x) y
;; f (x y)   = (f (x y))
;;
;; λ Lambda
;; λparameter.return
;; λx.a       = (λ (x) a)          | x =&gt; a
;; λx.a b     = (λ (x) (a x))      | x =&gt; (a x)
;; λx.λy.a    = (λ (x) (λ (y) a))  | x =&gt; y =&gt; a
;; (λx. a) b  = ((λ (x) a) b)      | (x =&gt; a)(b)
;; 
;; α-equivalence 동치. 변수 이름이 다른 두 람다 표현식이 구조상 같을때.
;; λx.x     와  λy.y
;; (f (x) x) 와 (f (y) y)
;; α-conversion  변환. 변수 이름 바꾸기(이름 충돌 방지).
;; λx.(λx.x)         =&gt; λx.(λy.y)
;; (f (x) (f (x) x)) =&gt; (f (x) (f (y) y)) 
;; β-reduction   축소. 함수 적용 후 변수 치환
;; ((λx.M) N)          =&gt; M
;; ((λ (x) (+ x 1)) 3) =&gt; (+ 3 1) =&gt; 4
;; η-conversion  변환. 불필요한 래핑 제거
;; (Η η eta /ˈiːtə, ˈeɪtə/ 이터 / 에이터)
;; λx.(fx)       =&gt; f
;; (λ (x) (f x)) =&gt; f
;;
;; Church encoding
;; https://en.wikipedia.org/wiki/Church_encoding
;;
;; TRUE  = λt. λf. t = (λ (t) (λ (f) t)) // 첫 번째 인자만 고르는 함수
;; FALSE = λt. λf. f = (λ (t) (λ (f) f)) // 두 번째 인자만 고르는 함수
;; ...
;;
;; Combinator: free variable이 없는 함수.
;; (λ (x) x) : 함수이면서, free variable이 없어 combinator.
;; (λ (x) a) : 함수이지만, free variable a가 있어 combinator가 아님.
;;
;; Fixed-point combinator (고정점 결합자)
;; - https://en.wikipedia.org/wiki/Fixed-point_combinator
;; - 함수의 재귀적 자기 참조를 가능하게 하는 함수
;; - 함수 f의 고정점 x는 f(x) = x가 성립하는 x입니다.
;;     (f x)     = x
;;     (f (f x)) = x
;; -  Y Combinator, Z Combinator 등 다양한 형태가 가능
;;
;; Y Combinator.
;; - λ-계산에서는 함수에 자기 자신을 직접 호출 할 수 없음.
;; - 하지만 함수를 인자를 받아 활용하면  재귀적인 동작이 가능함.
;; - 이 재귀적인 동작을 가능케하는 함수가 바로 Y Combinator.
;; - 단일 인자 함수에 대해 재귀를 가능하게 함
;;
;; Y = λf.(λx.f(x x))(λx.f(x x))
;;   = (λ (f)
;;       ((λ (x) (f (x x)))
;;        (λ (x) (f (x x)))))
;; (Y a) = (a (Y a))
;;       풀어쓰면 햇갈리니 두번째 (λ (x) (f (x x)))를 (λ (y) (f (y y))로 α-conversion
;;         = ((λ (f)
;;              ((λ (x) (f (x x)))
;;               (λ (y) (f (y y)))))
;;            a)
;; f에 a를 넣으면 (β-reduction)
;;         = ((λ (x) (a (x x)))
;;            (λ (y) (a (y y))))
;; x에 (λ (y) (a (y y)))를 넣으면 (β-reduction)
;;         = (a ( (λ (y) (a (y y)))
;;                (λ (y) (a (y y))) ) )
;; a를 다시 빼주면 ( α-conversion )
;;         = (a ((λ (f)
;;                 ((λ (y) (f (y y)))
;;                  (λ (y) (f (y y))))) a))
;;다시 (λ (y) (f (y y)))를 (λ (x) (f (x x)))로 변경시켜주고  α-conversion 
;;         = (a ((λ (f)
;;               ((λ (x) (f (x x)))
;;                (λ (x) (f (x x))))) a))
;; Y = (λ (f) ((λ (x) (f (x x))) (λ (x) (f (x x))))) 이므로
;;         = (a (Y a))
;;         = (Y a)
;; 즉 Y에 a를 넣으면 a가 재귀적으로 계속 호출됨.
;;
;; Z Combinator
;; Z = λf.(λx.f(λv. xxv))(λx.f(λv. xxv))
;;   = (λ (f)
;;      ((λ (x)
;;         (f (λ (v) ((x x) v))))
;;       (λ (x)
;;         (f (λ (v) ((x x) v))))))
;;
;; -ref: Lambda-Calculus and Combinators : An Introduction



;; letrec을 쓰지 않고도 재귀 프로시져를 만들 수 있음.

(define Y
  (λ (f)
    ((λ (x)
       (f (x x)))
     (λ (x)
       (f (x x))))))

(define Z
  (λ (f)
    ((λ (x)
       (f (λ (v) ((x x) v))))
     (λ (x)
       (f (λ (v) ((x x) v)))))))

(check-eq? ((Z
             (lambda (fact)
               (lambda (n)
                 (if (= n 0)
                     1
                     (* n (fact (- n 1)))))))
            10)
           3628800)

(check-eq? ((λ (n)
              ((λ (x)
                 (x x 0 n))
               (λ (iter acc y)
                 (if (= y 0)
                     acc
                     (iter iter (+ acc y) (- y 1))))))
            10)
           55)

;; 1-1. 표현식을 평가하여 factorial이 돌아가는지 확인.
(check-eq? ((lambda (n)
              ((lambda (fact)
                 (fact fact n))
               (lambda (ft k)
                 (if (= k 1)
                     1
                     (* k (ft ft (- k 1)))))))
            10)
           3628800)

;; 1-2. 피보나치 수를 구하는 함수 작성.

(check-eq? (let ()
             (define (fib n)
               (cond ((= n 0) 0)
                     ((= n 1) 1)
                     (else
                      (+ (fib (- n 1))
                         (fib (- n 2))))))
             (fib 10))
           55)

(check-eq? ((lambda (n)
              ((lambda (fibo)
                 (fibo fibo n))
               (lambda (fb n)
                 (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (else
                        (+ (fb fb (- n 1))
                           (fb fb (- n 2))))))))
            10)
           55)

(check-eq? ((Z
             (lambda (fibo)
               (lambda (n)
                 (cond ((= n 0) 0)
                       ((= n 1) 1)
                       (else
                        (+ (fibo (- n 1))
                           (fibo (- n 2))))))))
            10)
           55)

;; 2. 빈칸을 체워서 다음과 같은 함수와 동일한 함수 작성.
;; (define (f x)
;;   ((lambda (new-even? new-odd?)
;;      (new-even? new-even? new-odd? x))
;;    (lambda (ev? od? n)
;;      (if (= n 0) 
;;          true 
;;          (od? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))
;;    (lambda (ev? od? n)
;;      (if (= n 0) 
;;          false 
;;          (ev? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))))

(define (f x)
  (define (new-even? n)
    (if (= n 0)
        true
        (new-odd? (- n 1))))
  (define (new-odd? n)
    (if (= n 0)
        false
        (new-even? (- n 1))))
  (new-even? x))
(check-eq? (f 5) false)
(check-eq? (f 6) true)



(define (f2 x)
  ((lambda (new-even? new-odd?)
     (new-even? new-even? new-odd? x))
   (lambda (ev? od? n)
     (if (= n 0) 
         true 
         (od? ev? od? (- n 1))))
   (lambda (ev? od? n)
     (if (= n 0) 
         false 
         (ev? ev? od? (- n 1))))))

(check-eq? (f2 5) false)
(check-eq? (f2 6) true)
</code></pre>
<h2 id="4_22"><a class="header" href="#4_22">4_22</a></h2>
<pre><code class="language-lisp">;; file: 4_22.rkt
(#%require (prefix racket: racket))
(#%require rackunit)
(racket:require "4_06.rkt")
(racket:require (racket:rename-in "../allcode/ch4-4.1.7-analyzingmceval.rkt" (_analyze origin/analyze)))

(racket:provide
 analyze-let
 )
;; 4_06 참고. let을 처리 할 수 있도록 확장.

(define (analyze-let exp)
  (analyze (let-&gt;combination exp)))

(define (analyze exp)
  (cond ((self-evaluating? exp) 
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond-&gt;if exp)))
        ((let? exp) (analyze-let exp)) ;; &lt;----- 4_22 추가됨.
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))

(override-analyze! analyze)

(define env2 (setup-environment))
(define-variable! '+ (list 'primitive +) env2)
(check-equal? ((analyze '(let ((a 1) (b 2)) (+ a b))) env2)
              3)

(override-analyze! origin/analyze)
</code></pre>
<h2 id="4_23"><a class="header" href="#4_23">4_23</a></h2>
<pre><code class="language-lisp">;; file: 4_23.rkt
(#%require (prefix racket: racket))
(#%require (prefix trace: racket/trace))
(#%require rackunit)
(racket:require "4_06.rkt")
(racket:require (racket:rename-in "../allcode/ch4-4.1.7-analyzingmceval.rkt"
                                  (_analyze origin/analyze)
                                  (_analyze-sequence origin/analyze-sequence)))
;;
;; Q. analyze-sequence의 본문 버전과, Alyssa의 버전을 비교. expr가 2개인 경우, 1개인 경우 어떻게 돌아가는지 비교해라.
;;
;; ver. Original
(define (analyze-sequence-original exps)
  (define (sequentially proc1 proc2)
    (lambda (env)
      (proc1 env)
      (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))

;; ver. Alyssa P. Hacker
(define (analyze-sequence-alyssa exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (lambda (env)
      (execute-sequence procs env))))


;; 2개 버전, 1개 버전을 비교하라 했지만, 2개 보다 3개가 좀 더 알기 편할꺼임.
;;
;; 3개버전이라고 하면 procs가 (a1 a2 a3)가 되고
;;
;; ver. Original
;; procs의 리스트 순회를 미리 해버림 없음. lambda로 펼쳐져 있게됨.
;; (lambda (env)
;;   ((lambda (env)
;;      (a1 env)
;;      (a2 env))
;;    env)
;;  (a3 env))
;;
;; ver. Alyssa P. Hacker
;; execute-sequence를 통한 procs 리스트 순회를 하게됨.
;; (lambda (env)
;;   처음꺼 꺼내오고(execute-sequence)
;;   (a1 env)
;;   다음꺼 꺼내오고(execute-sequence)
;;   (a2 env)
;;   다음꺼 꺼내오고(execute-sequence)
;;   (a3 env)
;;   )
;;
;; 1개버전이라고 하면 procs가 (a1)가 되고
;;
;; ver. Original
;; 1개인 경우 그냥 원래것이 빠져나오게 됨.
;; a1
;;
;; ver. Alyssa P. Hacker
;; execute-sequence를 통한 procs 리스트 순회를 하게됨.
;; (lambda (env)
;;   처음꺼 꺼내오고(execute-sequence)
;;   (a1 env)
;;   )

</code></pre>
<h2 id="4_24"><a class="header" href="#4_24">4_24</a></h2>
<pre><code class="language-lisp">;; file: 4_24.rkt
(#%require profile)
(#%require (prefix racket: racket))
(racket:require (racket:prefix-in mceval: "../allcode/ch4-4.1.1-mceval.rkt"))
(racket:require (racket:prefix-in analyzing: "../allcode/ch4-4.1.7-analyzingmceval.rkt"))

;; 이전 버전의 evaluator와 이번 단락에서 소개한 버전(analyze)을 속도 측면에서 비교하기 위한 몇 가지 실험을 설계하고 수행하라.
;; 그 결과를 이용하여, 다양한 프로시저에 대해 분석 단계와 실행 단계 각각에 소요되는 시간의 비율을 추정하라.

;; profile-thunk
;; https://docs.racket-lang.org/profile/index.html#%28def._%28%28lib._profile%2Fmain..rkt%29._profile-thunk%29%29

;; time - https://docs.racket-lang.org/reference/time.html#%28form._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._time%29%29

;; current-inexact-monotonic-milliseconds - https://docs.racket-lang.org/reference/time.html#%28def._%28%28quote._~23~25kernel%29._current-inexact-monotonic-milliseconds%29%29
;; current-inexact-milliseconds
;; current-monotonic-nanoseconds -  https://docs.racket-lang.org/monotonic/index.html

(define expr
  
  '(define (fib n)
     (define (fib-iter a b count)
       (if (= count 0)
           b
           (fib-iter (+ a b) a (- count 1))))
     (fib-iter 1 0 n))

  )

(define env2 (mceval:setup-environment))
(mceval:define-variable! '+ (list 'primitive +) env2)
(mceval:define-variable! '- (list 'primitive -) env2)
(mceval:define-variable! '= (list 'primitive =) env2)
(mceval:eval expr env2)
(profile-thunk
 (lambda ()
   
   (mceval:eval '(fib 5000) env2)
   )
 #:repeat 99)

(define env3 (analyzing:setup-environment))
(analyzing:define-variable! '+ (list 'primitive +) env3)
(analyzing:define-variable! '- (list 'primitive -) env3)
(analyzing:define-variable! '= (list 'primitive =) env3)
(analyzing:eval expr env3) 
(profile-thunk
 (lambda ()
   (analyzing:eval '(fib 5000) env3)
   )
 #:repeat 99)
</code></pre>
<h2 id="4_25"><a class="header" href="#4_25">4_25</a></h2>
<pre><code class="language-lisp">{{#include ../../../source/solution_04/4_25.rkt:2:}}
</code></pre>
<h2 id="4_26"><a class="header" href="#4_26">4_26</a></h2>
<pre><code class="language-lisp">;; file: 4_26.rkt
;; 4_06

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require (prefix racket: racket))
;; lazy evaluation &lt;=&gt; eager evaluation


(define (unless condition usual-value exceptional-value)
  (if condition
      exceptional-value
      usual-value))

;; Ben Bitdidle
;;  - lazy evaluation의 중요성에 공감 못함. 그냥 eager evaluation환경에서 unless를 스페셜 폼으로 구현하면 된다.
;;
;; unless 를 (앞선 cond 혹은 let 처럼) derived expression 구현
;;
(define (unless-&gt;if expr)
  (let ((condition (second expr))
        (usual-value (third expr))
        (exceptional-value (fourth expr)))
    (list 'if condition
          exceptional-value
          usual-value)))

(check-equal?
 (unless-&gt;if '(unless (= 1 0)
                10
                20))
 '(if (= 1 0)
      20
      10))

;; Alyssa P. Hacker
;; - 그렇게 하면 함수를 인자나 반환값으로 사용하는 high-order procedure에서 사용 못한다.
;;
;; unless가 procedure로 사용되면 유용한 예.
;;

(check-equal? (map unless (list true false true) '(1 1 1) '(2 2 2))
              '(2 1 2))
</code></pre>
<h2 id="4_27"><a class="header" href="#4_27">4_27</a></h2>
<pre><code class="language-lisp">;; file: 4_27.rkt
(#%require rackunit)
(#%require threading)
(#%require (prefix racket: racket))
(racket:require "../allcode/ch4-4.2.2-leval.rkt")

;; lazy evaluator는 eval후 force it을 적용.
;; (driver-loop) 후 입력해도 됨.
;;
;; (define (actual-value exp env)
;;   (force-it (eval exp env)))
;;

(override-force-it! force-it-non-memoizing)
;; (override-force-it! force-it-memoizing)
(define env1 (setup-environment))
(~&gt; '(define count 0)
    (actual-value env1)
    (check-eq? 'ok))

(~&gt; '(define (id x)
       (set! count (+ count 1))
       x)
    (actual-value env1)
    (check-eq? 'ok))

(~&gt; '(define w (id (id 10)))
    (actual-value env1)
    (check-eq? 'ok))

(~&gt; 'count
    (actual-value env1)
    (check-eq? 1))

(~&gt; 'w
    (actual-value env1)
    (check-eq? 10))
#;(~&gt; 'w
    (actual-value env1)
    (check-eq? 10))
(~&gt; 'count
    (actual-value env1)
    (check-eq? 2))
</code></pre>
<h2 id="4_28"><a class="header" href="#4_28">4_28</a></h2>
<pre><code class="language-lisp">;; file: 4_28.rkt
(#%require rackunit)
(#%require threading)
(#%require (prefix racket: racket))
(racket:require "../allcode/ch4-4.2.2-leval.rkt")

;; Q. 예전에는 operator를 apply 에 넘겨주게 전에 그냥 eval했는데 왜 이젠 actual-value를 쓰는가?
;;
;; ch4-4.2.2-leval 에서는 apply시 operator에 actual-value적용
;; 
;; actual-value는 eval + force-it임.
;; 그럼 operator에 왜 추가적으로 force-it을 하는가. operator로 thunk가 올 수 있기 때문.

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         ;;  기존 leval코드는  operator에 actual-value적용.
         ;; (apply (actual-value (operator exp) env)
         ;;          (operands exp)
         ;;          env)

         (apply (eval (operator exp) env)
                (operands exp)
                env))
        (else
         (error "Unknown expression type -- EVAL" exp))))


(override-eval! eval)
(define env1 (setup-environment))

(~&gt; '(define (id x) x)
    (actual-value env1)
    (check-eq? 'ok))

(~&gt; '(define op (id +))
    (actual-value env1)
    (check-eq? 'ok))

(~&gt; 'op
    (lookup-variable-value env1)
    (thunk?)
    (check-true))

(check-exn #rx"Unknown procedure type"
           (lambda ()
             (~&gt; '(op 1 2)
                 (actual-value env1))))
</code></pre>
<h2 id="4_29"><a class="header" href="#4_29">4_29</a></h2>
<pre><code class="language-lisp">;; file: 4_29.rkt
(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require (prefix racket: racket))
(racket:require (racket:prefix-in lazy: "../allcode/ch4-4.2.2-leval.rkt"))

;;
;; count/id는 4_27에서 정의된것.
;;
;; non-memoizing버전과 memoizing 버전의 결과값을 비교해라.
;;

;; non-memoizing 버전에서는 (thunk exp env) 들만 있고, 매 force-it시 thunk에서 값을 계산을 한다.
'(define (force-it-non-memoizing obj)
   (if (thunk? obj)
       (actual-value (thunk-exp obj) (thunk-env obj))
       obj))

;; 반면 memoizing버전에서는 (evaluated-thunk result) 라는게 있어, (thunk exp env) 를 한번 계산하고 캐쉬비슷하게 저장해서 다시 쓴다.
'(define (force-it-memoizing obj)
   (cond ((thunk? obj)
          (let ((result (actual-value
                         (thunk-exp obj)
                         (thunk-env obj))))
            (set-car! obj 'evaluated-thunk)
            (set-car! (cdr obj) result)  ; replace exp with its value
            (set-cdr! (cdr obj) '())     ; forget unneeded env
            result))
         ((evaluated-thunk? obj)
          (thunk-value obj))
         (else obj)))

;; non-memoizing 버전
(lazy:override-force-it! lazy:force-it-non-memoizing)
(define env1 (lazy:setup-environment))
(~&gt; '(define count 0)
    (lazy:actual-value env1)
    (check-eq? 'ok))

(~&gt; '(define (id x)
       (set! count (+ count 1))
       x)
    (lazy:actual-value env1)
    (check-eq? 'ok))

(~&gt; '(define (square x)
       (* x x))
    (lazy:actual-value env1)
    (check-eq? 'ok))

;; non-memoizing에서는 (id 10)이 캐쉬되지 안아 square에서 2번 호출되어 count수도 두번 증가한다.
(~&gt; '(square (id 10))          
    (lazy:actual-value env1)
    (check-eq? 100))

(~&gt; 'count
    (lazy:actual-value env1)
    (check-eq? 2))


;; memoizing 버전
(lazy:override-force-it! lazy:force-it-memoizing)
(define env2 (lazy:setup-environment))
(~&gt; '(define count 0)
    (lazy:actual-value env2)
    (check-eq? 'ok))

(~&gt; '(define (id x)
       (set! count (+ count 1))
       x)
    (lazy:actual-value env2)
    (check-eq? 'ok))

(~&gt; '(define (square x)
       (* x x))
    (lazy:actual-value env2)
    (check-eq? 'ok))

;; memoizing에서는 (id 10)이 한번 호출되어 캐쉬되어 square에서 (* x x)라도 count수는 한번만 증가한다.
(~&gt; '(square (id 10))
    (lazy:actual-value env2)
    (check-eq? 100))

(~&gt; 'count
    (lazy:actual-value env2)
    (check-eq? 1))
</code></pre>
<h2 id="4_30"><a class="header" href="#4_30">4_30</a></h2>
<pre><code class="language-lisp">;; file: 4_30.rkt
;; 4_31

(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.2.2-leval.rkt"
                                  (_eval-sequence lazy:eval-sequence)))

;;  Cy D. Fect (aka sideeffect)는 사이드 이펙트가 생길까 염려.
;; 그래서 eval-sequence시 마지막을 제외하고 강제로 actual-value로 값을 얻어와야 한다고 주장함.
(define (eval-sequence-cy exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         ;; 기존
         ;; (eval (first-exp exps) env)
         ;;
         ;; 변경 eval을 actual-value로 변경
         (actual-value (first-exp exps) env)
         (eval-sequence-cy (rest-exps exps) env))))

;; 
;; a. for-each예를 들며, Ben Bitdiddle는 Cy가 틀렸다고 생각함. 원래 lazy:eval-sequence 이 맞다고 생각.
;; c. for-each예를 들며, Cy는 자신의 eval-sequence-cy도 잘 돌아간다고 주장.
(define expr-foreach '(define (for-each proc items)
                        (if (null? items)
                            'done
                            (begin (proc (car items))
                                   (for-each proc (cdr items))))))
(define expr-run-foreach '(for-each
                           (lambda (x) (newline) (display x))
                           (list 57 321 88)))

(test-case
 "a. Ben Bitdiddle의 주장 lazy:eval-sequence "
 
 (override-eval-sequence! lazy:eval-sequence)
 (define env1 (setup-environment))
 
 (~&gt; expr-foreach
     (actual-value env1)
     (check-equal? 'ok))

 (let ([output (racket:with-output-to-string (lambda () (actual-value expr-run-foreach env1)))])
   (check-equal? output "\n57\n321\n88")))

(test-case
 "c. Cy D. Fect 의 주장 eval-sequence-cy "
 (override-eval-sequence!  eval-sequence-cy)
 (define env1 (setup-environment))
 
 (~&gt; expr-foreach
     (actual-value env1)
     (check-equal? 'ok))

 (let ([output (racket:with-output-to-string (lambda () (actual-value expr-run-foreach env1)))])
   (check-equal? output "\n57\n321\n88")))

;;
;; b. 좀 더 복잡한 (p1 1) / (p2 1)의 실행 결과 비교.
(define expr-p1 '(define (p1 x)
                   (set! x (cons x '(2)))
                   x))

(define expr-p2 '(define (p2 x)
                   (define (p e)
                     e
                     x)
                   (p (set! x (cons x '(2))))))
(test-case
 "고치지 않으면? ( Ben Bitdiddle의 주장 lazy:eval-sequence )"
 (override-eval-sequence! lazy:eval-sequence)
 (define env1 (setup-environment))
 (~&gt; expr-p1
     (actual-value env1)
     (check-equal? 'ok))
 (~&gt; expr-p2
     (actual-value env1)
     (check-equal? 'ok))
 (~&gt; '(p1 1)
     (actual-value env1)
     (check-equal? '(1 2)))
 ;; x가 set!되기전에 값을 유지하고있어서, set!이 된 값이 아닌 1이 반환됨.
 (~&gt; '(p2 1)
     (actual-value env1)
     (check-equal? 1)))

(test-case
 "고치면? ( Cy D. Fect 의 주장 eval-sequence-cy )"
 (override-eval-sequence! eval-sequence-cy)
 (define env2 (setup-environment))
 (~&gt; expr-p1
     (actual-value env2)
     (check-equal? 'ok))
 (~&gt; expr-p2
     (actual-value env2)
     (check-equal? 'ok))
 (~&gt; '(p1 1)
     (actual-value env2)
     (check-equal? '(1 2)))
 (~&gt; '(p2 1)
     (actual-value env2)
     (check-equal? '(1 2))))

;; d. eval-sequcne를 어떻게 해야하나?
;;   1. Cy D. Fect (eval-sequcne-cy)
;;   2. 혹은  Ben Bitdiddle (lazy:eval-sequence)
;;   3. 아니면,  다른 방법?
;;
;; Cy D. Fect말도 사이드 이펙트를 피할 수 있지만, lazy함의 장점을 잃어버림.
;; Ben Bitdiddle의 lazy방식도 좋지만 (p2 1)와 같이 사이드 이팩트가 일어날 수 있음.
;; 다른 방법으로는, expr이 부수효과가 있으면 강제 평가하고 넘어가도록 짜면 피할 수 있음. 다만 부수효과 여부를 어떻게 판별할지가 관건.
</code></pre>
<h2 id="4_31"><a class="header" href="#4_31">4_31</a></h2>
<pre><code class="language-lisp">;; file: 4_31.rkt
;; 4_30

(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/helper/my-util.rkt")

(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.2.2-leval.rkt"
                                  (_eval-sequence lazy:eval-sequence)))

;; define 문법을 확장하여, 바로 평가할지, lazy-evalution인지, lazy evaluation + memoize인지 설정할 수 있도록 만들어라.

;; |---|--------------------------|
;; | f | 함수이름                 | 
;; | a | 바로 평가                | 
;; | b | lazy evaluation          | 
;; | c | 바로 평가                | 
;; | d | lazy evaluation + memoize| 
'(define (f a (b lazy) c (d lazy-memo))
   ...)

;; eval해서 eval-definition쪽은 그냥 symbol리스트를 저장하는거니 eval함수 수정은 아니고
;; (define (f a (b lazy) c (d lazy-memo)) true)
;; env=&gt; #0=(((f ... )
;;            (procedure (a (b lazy) c (d lazy-memo)) (true) #0#)
;;            ...
;;          ))
;; 4_30과 같이 apply쪽에보면 eval-sequence / list-of-delayed-args / procedure-parameters를 고쳐야 한다.
;; 그리고 force-it 하는 부분도, eager/ lazy / lazy-memo부분을 나누어야한다.

'(define (apply procedure arguments env)
   (cond ((primitive-procedure? procedure)
          (apply-primitive-procedure
           procedure
           (list-of-arg-values arguments env)))
         ((compound-procedure? procedure)
          (eval-sequence                              ; &lt;&lt;&lt;&lt; 이 부분: eval-sequence
           (procedure-body procedure)
           (extend-environment
            (procedure-parameters procedure)          ; &lt;&lt;&lt;&lt; 이 부분: procedure-parameters
            (list-of-delayed-args arguments env)      ; &lt;&lt;&lt;&lt; 이 부분: list-of-delayed-args
            (procedure-environment procedure))))
         (else
          (error
           "Unknown procedure type -- APPLY" procedure))))

(define (procedure-parameters procedure)
  ;; (procedure-parameters '(procedure (a (b lazy) c (d lazy-memo)) (true) 'blabla-env))
  ;; =&gt; (a b c d)
  (define (darg-&gt;var darg)
    (if (list? darg)
        (first darg)
        darg))
  (let ((define-args (second procedure)))
    (map darg-&gt;var define-args)))

(define (procedure-parameter-annotations procedure)
  ;; (procedure-parameter-annotations '(procedure (a (b lazy) c (d lazy-memo)) (true) 'blabla-env))
  ;; =&gt; (eager lazy eager lazy-memo)
  (define (darg-&gt;annot darg)
    (if (list? darg)
        (second darg)
        'eager))
  (let ((define-args (second procedure)))
    (map darg-&gt;annot define-args)))

(define (delay-memo-it exp env)
  (list 'thunk-memo exp env))

;; list-of-delayed-args는 annotation다룰 자리가 없으니 list-of-new-define-args로 대처
(define (list-of-new-define-args arguments annotations env)
  ;; (list-of-new-define-args '(1 2 3 4) '(eager lazy eager lazy-memo) 'blabla-env)
  ;;=&gt; (1 (thunk 2 blabla-env) 3 (thunk-memo 4 blabla-env))
  (define (box annot arg env)
    (cond ((eq? annot 'eager)
           (actual-value arg env))
          ((eq? annot 'lazy)
           (delay-it arg env))
          ((eq? annot 'lazy-memo)
           (delay-memo-it arg env))
          (else
           (error "annot != (eager|lazy|lazy-memo)" annot arg))))
  (define (iter acc args annots env)
    (if (null? args)
        (reverse acc)
        (let ((boxed (box (first annots) (first args) env)))
          (iter (cons boxed acc) (rest args) (rest annots) env))))
  (iter '() arguments annotations env))

(define (thunk-memo? obj)
  (tagged-list? obj 'thunk-memo))

(define (force-it-brand-new obj)
  (cond ((thunk? obj)
         (actual-value (thunk-exp obj) (thunk-env obj)))
        ((thunk-memo? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  ; replace exp with its value
           (set-cdr! (cdr obj) '())     ; forget unneeded env
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))

(define (apply-30 procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))
        ((compound-procedure? procedure)
         (eval-sequence                                                                        ; &lt;&lt;&lt;&lt;
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)                                                    ; &lt;&lt;&lt;&lt;
           (list-of-new-define-args arguments (procedure-parameter-annotations procedure) env) ; &lt;&lt;&lt;&lt;
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

(override-procedure-parameters! procedure-parameters)
(override-force-it! force-it-brand-new)
(override-apply! apply-30)

(define env1 (setup-environment))

(~&gt; '(define (id x)
       x)
    (actual-value env1)
    (check-equal? 'ok))
(~&gt; '(begin
       (define var-d 0)
       (define var-c 0)
       
       (define var-b 0)
       (define var-a 0)
       
       )
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(define (f a (b lazy) c (d lazy-memo))
       (set! var-a a)
       (set! var-b b)
       (set! var-c c)
       (set! var-d d)
       (+ a b c d))
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(f (id 1) (id 2) (id 3) (id 4))
    (actual-value env1)
    (check-equal? 10))

;; env1
;; #0=(((... var-a var-b var-c var-d ...)
;;      ...
;;      1
;;      (thunk 2 #0#)
;;      3
;;      (evaluated-thunk 4)
;;      ...))

(~&gt; '(f (id 1) (id 2) (id 3) (id 4))
    (actual-value env1)
    (check-equal? 10))

;; env1
;; #0=(((... var-a var-b var-c var-d ...)
;;      ...
;;      1
;;      (thunk (id 2) #0#)
;;      3
;;      (evaluated-thunk 4)
;;      ...))

(~&gt; '(define (g a (b lazy) c (d lazy-memo))
       (set! var-a a)
       (set! var-b b)
       (set! var-c c)
       (set! var-d d)
       true)
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(g (id 1) (id 2) (id 3) (id 4))
    (actual-value env1)
    (check-equal? true))

;; env1
;; #0=(((... var-a var-b var-c var-d ...)
;;       ...
;;       1
;;      (thunk (id 2) #0#)
;;      3
;;      (thunk-memo (id 4) #0#)
;;      ...))
</code></pre>
<h2 id="4_32"><a class="header" href="#4_32">4_32</a></h2>
<pre><code class="language-lisp">;; file: 4_32.rkt
(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/helper/my-util.rkt")

(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.2.2-leval.rkt"
                                  (_eval-sequence lazy:eval-sequence)))

;; 3장에서 다룬 **스트림**과 이 섹션에서 설명한 "더 게으른" **지연 리스트**의 차이점을 보여주는 몇 가지 예제를 제시해라.
;; 이 추가적인 laziness 어떻게 활용할 수 있는가?
;; 
;; (provide cons-stream)
;; (define-syntax cons-stream
;;   (syntax-rules ()
;;     [(_ A B) (r5rs:cons A (r5rs:delay B))]))
;;
;; |------------|------------------------|----------------------------------------|
;; | 스트림     | car의 즉시 평가.       | 순차적 접근과 무한 리스트 처리에 적합. |
;; | 지연 리스트| car와 cdr 모두를 지연. | 비순차적 접근에서 더 유연              |


(override-force-it! force-it-memoizing) ; memoizing없이는 solve를 푸는데 한참걸림.
(define env1 (setup-environment))

(~&gt; '(begin 
       (define (cons x y)
         (lambda (m)
           (m x y)))
       (define (car z)
         (z
          (lambda (p q) p)))
       (define (cdr z)
         (z
          (lambda (p q) q)))

       (define (list-ref items n)
         (if (= n 0)
             (car items)
             (list-ref (cdr items) (- n 1))))

       (define (map proc items)
         (if (null? items)
             '()
             (cons (proc (car items))
                   (map proc (cdr items)))))

       (define (scale-list items factor)
         (map (lambda (x) (* x factor))
              items))

       (define (add-lists list1 list2)
         (cond ((null? list1) list2)
               ((null? list2) list1)
               (else (cons (+ (car list1) 
                              (car list2))
                           (add-lists
                            (cdr list1) 
                            (cdr list2))))))

       (define ones (cons 1 ones))

       (define integers 
         (cons 1 (add-lists ones integers))))
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(list-ref integers 17)
    (actual-value env1)
    (check-equal? '18))

(~&gt; '(begin
       (define (integral integrand initial-value dt)
         (define int
           (cons initial-value
                 (add-lists (scale-list integrand dt) 
                            int)))
         int)

       (define (solve f y0 dt)
         (define y (integral dy y0 dt))
         (define dy (map f y))
         y))
    (actual-value env1)
    (check-equal? 'ok))

(define SMALL-RADIO 0.00001)
(~&gt; '(list-ref (solve (lambda (x) x) 1 0.001) 1000)
    (actual-value env1)
    (check-= 2.716924 SMALL-RADIO))


(~&gt; '(define (run-forever)
       (run-forever))
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(begin
       (cons (run-forever) 2)
       1)
    (actual-value env1)
    (check-equal? 1))

(~&gt; '(list-ref (cons (run-forever) (cons 'helloworld nil)) 1)
    (actual-value env1)
    (check-equal? 'helloworld))
</code></pre>
<h2 id="4_33"><a class="header" href="#4_33">4_33</a></h2>
<pre><code class="language-lisp">;; file: 4_33.rkt
(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/helper/my-util.rkt")

(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.2.2-leval.rkt"
                                  (_eval-sequence lazy:eval-sequence)))
;; leval에서 '(car '(a b c))를 처리할 수 없는데 처리할 수 있도록 고쳐라.

;;
;; before
;; car의 정의에 따라 풀면 ('(a b c) (lambda (p q) p)) 이런식이 되는데, 이러면 당연히 에러가 날 것이다.
;;
(define env1 (setup-environment))
(~&gt; '(begin
       (define (cons x y)
         (lambda (m)
           (m x y)))
       (define (car z)
         (z
          (lambda (p q) p)))
       (define (cdr z)
         (z
          (lambda (p q) q))))
    (actual-value env1)
    (check-equal? 'ok))
(check-exn
 #rx"Unknown procedure type -- APPLY \\(a b c\\)"
 (lambda ()
   (~&gt;'(car '(a b c))
      (actual-value env1))))

;;
;; after
;; '(a b c)를 lazy list로 풀면 (cons (quote a) (cons (quote b) (cons (quote c) nil))) 잘 동작할 것이다.
;;

(define (handle-quoted expr)
  (define (quoted-list lst)
    ;; (quoted-list '(a b c))
    ;;=&gt; (cons (quote a) (cons (quote b) (cons (quote c) ())))
    (define (iter acc xs)
      (if (null? xs)
          acc
          (iter (list 'cons (list 'quote (first xs)) acc) (rest xs))))
    (iter '() (reverse lst)))
  (define (quoted-cons pair)
    ;; (quoted-cons '(a . b)
    ;;=&gt; '(cons (quote a) (quote b)))
    (list 'cons
          (list 'quote (first pair))
          (list 'quote (rest pair))))
  (cond ((list? expr)
         (quoted-list expr))
        ((pair? expr)
         (quoted-cons expr))
        (else
         expr)))

(check-equal? (handle-quoted '(a . b))
              '(cons (quote a) (quote b)))
(check-equal? (handle-quoted '(a b c))
              '(cons (quote a) (cons (quote b) (cons (quote c) ()))))
(check-equal? (handle-quoted 'a)
              'a)

(define (eval-quoted expr env)
  (let ((q (handle-quoted expr)))
    (if (pair? q)
        (eval q env)
        q)))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp)
         (eval-quoted (text-of-quotation exp) env))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)             ; clause from book
         (apply (actual-value (operator exp) env)
                (operands exp)
                env))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(override-eval! eval)
(define env2 (setup-environment))
(~&gt; '(begin
       (define (cons x y)
         (lambda (m)
           (m x y)))
       (define (car z)
         (z
          (lambda (p q) p)))
       (define (cdr z)
         (z
          (lambda (p q) q))))
    (actual-value env2)
    (check-equal? 'ok))
(~&gt;'(car '(a b c))
   (actual-value env2)
   (check-equal? 'a))
</code></pre>
<h2 id="4_34"><a class="header" href="#4_34">4_34</a></h2>
<pre><code class="language-lisp">;; file: 4_34.rkt
(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/helper/my-util.rkt")

(#%require (prefix racket: racket))
(racket:require (racket:rename-in "../allcode/ch4-4.2.2-leval.rkt"
                                  (_eval-sequence lazy:eval-sequence)))

;; TODO driver loop를 수정하여 lazy pair / lazy list를 보기 좋게 출력해라.(무한 리스트는 어떻게 다룰 것인가?)
;; evaluator가 lazy pairs를 잘 인식하여 출력하도록, lazy pairs를 내부적으로 어떻게 다를 것인지에 대해 수정해야 할 지도 모른다.

(define env1 (setup-environment))
(~&gt; '(begin
       (define (cons x y)
         (lambda (m)
           (m x y)))
       (define (car z)
         (z
          (lambda (p q) p)))
       (define (cdr z)
         (z
          (lambda (p q) q))))
    (actual-value env1)
    (check-equal? 'ok))

(~&gt; '(cons nil nil)
    (actual-value env1))

#;(~&gt; '(cons 1 (cons 2 '()))
    (actual-value env1))
</code></pre>
<h2 id="4_35"><a class="header" href="#4_35">4_35</a></h2>
<pre><code class="language-lisp">;; file: 4_35.rkt
;; 4_36, 4_37

(#%require rackunit)
(#%require threading)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")

(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; 정해진 범위에서 정수 하나를 골라내는 프로시저 an-integer-between을 정의하라.

(define env2 (setup-environment))
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env2)
    (check-equal? 'ok))

(~&gt; '(begin
       (define (square x) (* x x))
       
       (define (smallest-divisor n)
         (find-divisor n 2))

       (define (find-divisor n test-divisor)
         (cond ((&gt; (square test-divisor) n) n)
               ((divides? test-divisor n) test-divisor)
               (else (find-divisor n (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))

       (define (prime? n)
         (= n (smallest-divisor n))))
    (run env2)
    (check-equal? 'ok))

(~&gt; '(define (prime-sum-pair list1 list2)
       (let ((a (an-element-of list1))
             (b (an-element-of list2)))
         (require (prime? (+ a b)))
         (list a b)))
    (run env2)
    (check-equal? 'ok))
    
(~&gt; '(define (an-element-of items)
       (require (not (null? items)))
       (amb (car items) 
            (an-element-of (cdr items))))
    (run env2)
    (check-equal? 'ok))

(~&gt; '(prime-sum-pair '(1 3 5 8) '(20 35 110))
    (runs env2)
    (check-equal? '((3 20)
                    (3 110)
                    (8 35))))
(~&gt; '(prime-sum-pair '(19 27 30) '(11 36 58))
    (run env2)
    (check-equal? '(30 11)))



;;
(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env3)
(define-variable! '&lt;= (list 'primitive &lt;=) env3)
(define-variable! 'inc (list 'primitive inc) env3)
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (an-integer-between from to)
       ;; 정해진 범위에서 정수 하나를 골라내는 프로시저.
       ;; (an-integer-between 1 10)
       ;;=&gt; amb (1 2 3 4 5 6 7 8 9 10)
       (require (&lt;= from to))
       (amb from
            (an-integer-between (inc from) to)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (a-pythagorean-triple-between low high)
       ;; i^2 + j^2 = k^2 인 세 정수의 쌍 (i, j , k)을 찾아네는 프로시져.
       (let ((i (an-integer-between low high)))
         (let ((j (an-integer-between i high)))
           (let ((k (an-integer-between j high)))
             (require (= (+ (* i i) (* j j)) (* k k)))
             (list i j k)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(a-pythagorean-triple-between 1 30)
    (runs env3)
    (check-equal? '((3 4 5)
                    (5 12 13)
                    (6 8 10)
                    (7 24 25)
                    (8 15 17)
                    (9 12 15)
                    (10 24 26)
                    (12 16 20)
                    (15 20 25)
                    (18 24 30)
                    (20 21 29))))
</code></pre>
<h2 id="4_36"><a class="header" href="#4_36">4_36</a></h2>
<pre><code class="language-lisp">;; file: 4_36.rkt
;; 4_35, 4_37 

(#%require rackunit)
(#%require threading)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")

(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; 앞에 정의한 a-pythagorean-triple-between 함수에서 단순히 an-integer-between을 an-integer-starting-from로 바꿔서는 안됨.
;; 안되는 이유는?
;; an-integer-starting-from의 중첩으로는 깊이 우선 탐색으로 i j k가 1 1 1, 1 1 2, 1 1 3 .... 되면서 i가 올라가지 않게됨.
;; require는 조건을 걸러내는 필터일 뿐이고, 탐색 순서 자체를 바꿔주지는 못함.
;;
;; 올바른 해결책은?
;; 깊이 우선 탐색이므로 integer-starting-from만으로는 안됨. an-integer-between을 섞어 제한을 줘야함.

(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env3)
(define-variable! '&lt;= (list 'primitive &lt;=) env3)
(define-variable! 'inc (list 'primitive inc) env3)
(define-variable! 'display (list 'primitive display) env3)
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (an-integer-starting-from n)
       ;; (an-integer-starting-from 1)
       ;;=&gt; amb (1 .....)
       (amb n
            (an-integer-starting-from (+ n 1))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (an-integer-between from to)
       ;; 정해진 범위에서 정수 하나를 골라내는 프로시저.
       ;; (an-integer-between 1 10)
       ;;=&gt; amb (1 2 3 4 5 6 7 8 9 10)
       (require (&lt;= from to))
       (amb from
            (an-integer-between (inc from) to)))
    (run env3)
    (check-equal? 'ok))


(~&gt; '(define (a-pythagorean-triple-from low)
       (let ((k (an-integer-starting-from low)))
         (let ((j (an-integer-between low k)))
           (let ((i (an-integer-between low j)))
             (require (= (+ (* i i) (* j j)) (* k k)))
             (list i j k)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(a-pythagorean-triple-from 1)
    (runs env3 10)
    (check-equal? '((3 4 5)
                    (6 8 10)
                    (5 12 13)
                    (9 12 15)
                    (8 15 17)
                    (12 16 20)
                    (15 20 25)
                    (7 24 25)
                    (10 24 26)
                    (20 21 29))))
</code></pre>
<h2 id="4_37"><a class="header" href="#4_37">4_37</a></h2>
<pre><code class="language-lisp">;; file: 4_37.rkt
;; 4_35, 4_36
(#%require rackunit)
(#%require threading)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; Ben Bitdiddle 는 4.35에서 나온 a-pythagorean-triple-between보다 자신의 것이 더 효율적이라고 주장하는데, 사실인가?
;; (힌트, 탐색해야할 가능성의 수 고려)

(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))



(define env3 (setup-environment))
(define-variable! '+ (list 'primitive +) env3)
(define-variable! '&lt;= (list 'primitive &lt;=) env3)
(define-variable! 'inc (list 'primitive inc) env3)
(define-variable! 'display (list 'primitive display) env3)
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (an-integer-starting-from n)
       ;; (an-integer-starting-from 1)
       ;;=&gt; amb (1 .....)
       (amb n
            (an-integer-starting-from (+ n 1))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (an-integer-between from to)
       ;; 정해진 범위에서 정수 하나를 골라내는 프로시저.
       ;; (an-integer-between 1 10)
       ;;=&gt; amb (1 2 3 4 5 6 7 8 9 10)
       (require (&lt;= from to))
       (amb from
            (an-integer-between (inc from) to)))
    (run env3)
    (check-equal? 'ok))

;; 4.35
'(define (a-pythagorean-triple-between low high)
   ;; i^2 + j^2 = k^2 인 세 정수의 쌍 (i, j , k)을 찾아네는 프로시져.
   ;; an-integer-between가 3개 O(n^3)
   (let ((i (an-integer-between low high)))
     (let ((j (an-integer-between i high)))
       (let ((k (an-integer-between j high)))
         (require (= (+ (* i i) (* j j)) (* k k)))
         (list i j k)))))

;; 4.37
(~&gt; '(define (a-pythagorean-triple-between-37 low high)
       ;; an-integer-between가 2개 O(n^2)
       (let ((i (an-integer-between low high))
             (hsq (* high high)))
         (let ((j (an-integer-between i high)))
           (let ((ksq (+ (* i i)
                         (* j j))))
             (require (&lt;= ksq hsq))
             (let ((k (sqrt ksq)))
               (require (integer? k))
               (list i j k))))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(a-pythagorean-triple-between-37 1 50)
    (runs env3 10)
    (check-equal? ' ((3 4 5)
                     (5 12 13)
                     (6 8 10)
                     (7 24 25)
                     (8 15 17)
                     (9 12 15)
                     (9 40 41)
                     (10 24 26)
                     (12 16 20)
                     (12 35 37))))
</code></pre>
<h2 id="4_38"><a class="header" href="#4_38">4_38</a></h2>
<pre><code class="language-lisp">;; file: 4_38.rkt
;; 4_38, 4_39, 4_40, 4_41

(#%require rackunit)
(#%require threading)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; multiple-dwelling에서 Smith와 Fletcher가 인접층에 살지 않는다는 require를 빼도록 수정해라. 얼마나 많은 솔루션이 있는가?

(define env3 (setup-environment))
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items) true)
             ((null? (cdr items)) true)
             ((member (car items) (cdr items)) false)
             (else (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (multiple-dwelling)
       (let ((baker (amb 1 2 3 4 5))
             (cooper (amb 1 2 3 4 5))
             (fletcher (amb 1 2 3 4 5))
             (miller (amb 1 2 3 4 5))
             (smith (amb 1 2 3 4 5)))
         (require
           (distinct? (list baker cooper fletcher miller smith)))
         (require (not (= baker 5)))
         (require (not (= cooper 1)))
         (require (not (= fletcher 5)))
         (require (not (= fletcher 1)))
         (require (&gt; miller cooper))
         ;; Smith와 Fletcher가 인접층에 살지 않는다는 require를 빼도록 수정해라.
         ;; (require
         ;;   (not (= (abs (- smith fletcher)) 1)))
         (require 
           (not (= (abs (- fletcher cooper)) 1)))
         (list (list 'baker baker)
               (list 'cooper cooper)
               (list 'fletcher fletcher)
               (list 'miller miller)
               (list 'smith smith))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(multiple-dwelling)
    (runs env3)
    (length)
    (check-equal? 5))
</code></pre>
<h2 id="4_39"><a class="header" href="#4_39">4_39</a></h2>
<pre><code class="language-lisp">;; file: 4_39.rkt
;; 4_38, 4_39, 4_40, 4_41
(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))


;; Q. multiple-dwelling에서 require의 순서가 답에 영향을 미치는가?
;; 아니다.
;;
;; Q. 시간에 영향을 미치는가?
;;
;; 어쨋든 require를 모두 통과해야 결과가 나옴.
;; require 순서를 조절하여 가지치기를 해두면 검사의 횟수를 줄이이면서 더 빠르게 결과를 얻을 수 있음.
;; 계산비용 자체는 distinct? 함수가 가장 크나,
;; 테스트 결과 (require (&gt; miller cooper)) 이 제약조건이 가지치기를 크게 함으로써 시간에 가장 크게 영향을 끼쳤음.
;;
;; Q. 순서가 중요하다면, 순서를 재배치하여 더 빠른 프로그램을 만들어라. 만약 순서가 중요하지 않다면, 그 이유를 설명하라.
;;


(define env3 (setup-environment))
(define-variable! 'display (list 'primitive display) env3)
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items)
              true)
             ((null? (cdr items))
              true)
             ((member (car items) (cdr items))
              false)
             (else
              (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(define expr-origin
  '(define (multiple-dwelling)
     (let ((baker (amb 1 2 3 4 5))
           (cooper (amb 1 2 3 4 5))
           (fletcher (amb 1 2 3 4 5))
           (miller (amb 1 2 3 4 5))
           (smith (amb 1 2 3 4 5)))
        
       (require (distinct? (list baker cooper fletcher miller smith)))
         
       (require (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (&gt; miller cooper))

       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))

       (list (list 'baker baker)
             (list 'cooper cooper)
             (list 'fletcher fletcher)
             (list 'miller miller)
             (list 'smith smith)))))

(define expr-2
  '(define (multiple-dwelling)
     (let ((baker (amb 1 2 3 4 5))
           (cooper (amb 1 2 3 4 5))
           (fletcher (amb 1 2 3 4 5))
           (miller (amb 1 2 3 4 5))
           (smith (amb 1 2 3 4 5)))

       (require (&gt; miller cooper))

       (require (not (= fletcher 1)))
       (require (not (= cooper 1)))

       (require (not (= (abs (- smith fletcher)) 1)))       
       (require (not (= (abs (- fletcher cooper)) 1)))

       (require (not (= fletcher 5)))
       (require (not (= baker 5)))
       (require (distinct? (list baker cooper fletcher miller smith)))

       (list (list 'baker baker)
             (list 'cooper cooper)
             (list 'fletcher fletcher)
             (list 'miller miller)
             (list 'smith smith)))))

(~&gt; expr-origin
    (run env3)
    (check-equal? 'ok))

(racket:time
 (racket:for ([i 10])
             (~&gt; '(multiple-dwelling)
                 (runs env3)
                 (length)
                 (check-equal? 1))))

(~&gt; expr-2
    (run env3)
    (check-equal? 'ok))

(racket:time
 (racket:for ([i 10])
             (~&gt; '(multiple-dwelling)
                 (runs env3)
                 (length)
                 (check-equal? 1))))

</code></pre>
<h2 id="4_40"><a class="header" href="#4_40">4_40</a></h2>
<pre><code class="language-lisp">;; file: 4_40.rkt
;; 4_38, 4_39, 4_40, 4_41

(#%require rackunit)
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; Q. distict가 있을때 없을때 경우의 수?
;; 있으면 1
;; 없으면 120
;;
;; Q. 모든 사람들을 층에 배정 후 백트래킹을 통해 이를 제거하는 방식은 매우 비효율적. 이전 제약 조건에 의해 이미 배제된 가능성만 생성하도록 하는, 훨씬 더 효율적인 비결정적 절차를 작성하고 이를 시연하라
;; (힌트: 이를 위해서는 let 표현식의 중첩이 필요하다.)
;;
;; distnct는 모든 사람들이 필요함.: (require (distinct? (list baker cooper fletcher miller smith)))
;; 대신, 사람별로 (require (not (= cooper fletcher))) / (require (not (= miller cooper))) ... 제한을 두게되면 좀 더 최적화가 됨.

(define env3 (setup-environment))
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items) true)
             ((null? (cdr items)) true)
             ((member (car items) (cdr items)) false)
             (else (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(define expr-origin
  '(define (multiple-dwelling)
     (let ((baker (amb 1 2 3 4 5))
           (cooper (amb 1 2 3 4 5))
           (fletcher (amb 1 2 3 4 5))
           (miller (amb 1 2 3 4 5))
           (smith (amb 1 2 3 4 5)))
        
       (require (distinct? (list baker cooper fletcher miller smith)))
         
       (require (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (&gt; miller cooper))

       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))

       (list (list 'baker baker)
             (list 'cooper cooper)
             (list 'fletcher fletcher)
             (list 'miller miller)
             (list 'smith smith)))))

(define expr-without-distinct
  '(define (multiple-dwelling)
     (let ((baker (amb 1 2 3 4 5))
           (cooper (amb 1 2 3 4 5))
           (fletcher (amb 1 2 3 4 5))
           (miller (amb 1 2 3 4 5))
           (smith (amb 1 2 3 4 5)))
        
       ;; (require (distinct? (list baker cooper fletcher miller smith)))
         
       (require (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (&gt; miller cooper))

       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))

       (list (list 'baker baker)
             (list 'cooper cooper)
             (list 'fletcher fletcher)
             (list 'miller miller)
             (list 'smith smith)))))

(define expr-split-let
  '(define (multiple-dwelling)
     (let ((fletcher (amb 1 2 3 4 5)))
       (require (not (= fletcher 1)))
       (require (not (= fletcher 5)))
       
       (let ((cooper (amb 1 2 3 4 5)))
         (require (not (= cooper 1)))
         (require (not (= (abs (- fletcher cooper)) 1)))
         
         (let ((miller (amb 1 2 3 4 5)))
           (require (&gt; miller cooper))
           
           (let ((smith (amb 1 2 3 4 5)))
             (require (not (= (abs (- smith fletcher)) 1)))
             
             (let ((baker (amb 1 2 3 4 5)))
               (require (not (= baker 5)))
               
               (require (distinct? (list baker cooper fletcher miller smith)))
               (list (list 'baker baker)
                     (list 'cooper cooper)
                     (list 'fletcher fletcher)
                     (list 'miller miller)
                     (list 'smith smith)))))))))

(define expr-split-distict
  '(define (multiple-dwelling)
     (let ((fletcher (amb 1 2 3 4 5)))
       (require (not (= fletcher 1)))
       (require (not (= fletcher 5)))
       
       (let ((cooper (amb 1 2 3 4 5)))
         (require (not (= cooper 1)))
         (require (not (= (abs (- fletcher cooper)) 1)))
         
         (require (not (= cooper fletcher)))     ; for distict?
         (let ((miller (amb 1 2 3 4 5)))
           (require (&gt; miller cooper))
           
           (require (not (= miller fletcher)))   ; for distict?
           (require (not (= miller cooper)))     ; for distict?
           (let ((smith (amb 1 2 3 4 5)))
             (require (not (= (abs (- smith fletcher)) 1)))
             
             (require (not (= smith fletcher)))  ; for distict?
             (require (not (= smith cooper)))    ; for distict?
             (require (not (= smith miller)))    ; for distict?
             (let ((baker (amb 1 2 3 4 5)))
               (require (not (= baker 5)))
               
               (require (not (= baker fletcher))) ; for distict?
               (require (not (= baker cooper)))   ; for distict?
               (require (not (= baker miller)))   ; for distict?
               (require (not (= baker smith)))    ; for distict?
               
               
               (list (list 'baker baker)
                     (list 'cooper cooper)
                     (list 'fletcher fletcher)
                     (list 'miller miller)
                     (list 'smith smith)))))))))

(~&gt; expr-origin
    (run env3)
    (check-equal? 'ok))
(~&gt; '(multiple-dwelling)
    (runs env3)
    (length)
    (check-equal? 1))


(~&gt; expr-without-distinct
    (run env3)
    (check-equal? 'ok))
(~&gt; '(multiple-dwelling)
    (runs env3)
    (length)
    (check-equal? 120))

(~&gt; expr-origin
    (run env3)
    (check-equal? 'ok))
(racket:time
 (racket:for ([i 10])
             (~&gt; '(multiple-dwelling)
                 (runs env3)
                 (length)
                 (check-equal? 1))))

(~&gt; expr-split-let
    (run env3)
    (check-equal? 'ok))


(racket:time
 (racket:for ([i 10])
             (~&gt; '(multiple-dwelling)
                 (runs env3)
                 (length)
                 (check-equal? 1))))

(~&gt; expr-split-distict
    (run env3)
    (check-equal? 'ok))


(racket:time
 (racket:for ([i 10])
             (~&gt; '(multiple-dwelling)
                 (runs env3)
                 (length)
                 (check-equal? 1))))

</code></pre>
<h2 id="4_41"><a class="header" href="#4_41">4_41</a></h2>
<pre><code class="language-lisp">;; file: 4_41.rkt
;; 4_38, 4_39, 4_40, 4_41
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))


;; Q. multiple-dwelling를 Scheme으로 풀어라.

(define env3 (setup-environment))
(define-variable! 'append (list 'primitive append) env3)

(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items)
              true)
             ((null? (cdr items))
              true)
             ((member (car items) (cdr items))
              false)
             (else
              (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(define expr-origin
  '(define (multiple-dwelling)
     (let ((baker (amb 1 2 3 4 5))
           (cooper (amb 1 2 3 4 5))
           (fletcher (amb 1 2 3 4 5))
           (miller (amb 1 2 3 4 5))
           (smith (amb 1 2 3 4 5)))
        
       (require (distinct? (list baker cooper fletcher miller smith)))
         
       (require (not (= baker 5)))
       (require (not (= cooper 1)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (require (&gt; miller cooper))

       (require (not (= (abs (- smith fletcher)) 1)))
       (require (not (= (abs (- fletcher cooper)) 1)))

       (list (list 'baker baker)
             (list 'cooper cooper)
             (list 'fletcher fletcher)
             (list 'miller miller)
             (list 'smith smith)))))

(~&gt; expr-origin
    (run env3)
    (check-equal? 'ok))
(racket:time
 (~&gt; '(multiple-dwelling)
     (runs env3)
     (check-equal? '(((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))))))

(define expr-x
  '(define (multiple-dwelling-scheme-for-each)
     ;; eval을 통과하기 위해 일단 do로는 안짬. scheme에는 do가 있고 continue가 없는데 continue가 있다면 더 간단할 것이다.
     ;; for-each로 짜기로 함.
     (let ((baker '(1 2 3 4 5))
           (cooper '(1 2 3 4 5))
           (fletcher '(1 2 3 4 5))
           (miller '(1 2 3 4 5))
           (smith '(1 2 3 4 5))
           (acc '()))
       (for-each (lambda (f)
                   (if (not (= f 1))
                       (if (not (= f 5))
                           (for-each (lambda (c)
                                       (if (not (= c 1))
                                           (if (not (= (abs (- f c)) 1))
                                               (for-each (lambda (m)
                                                           (if  (&gt; m c)
                                                                (for-each (lambda (s)
                                                                            (if (not (= (abs (- s f)) 1))
                                                                                (for-each (lambda (b)
                                                                                            (if (not (= b 5))
                                                                                                (let ((val (list b c f m s)))
                                                                                                  (if (distinct? val)
                                                                                                      (set! acc (append acc (list (list 'baker b)
                                                                                                                                  (list 'cooper c)
                                                                                                                                  (list 'fletcher f)
                                                                                                                                  (list 'miller m)
                                                                                                                                  (list 'smith s))))))))
                                                                                          baker)))
                                                                          smith)))
                                                         miller))))
                                     cooper))))
                 baker)
       acc)))

(~&gt; '(define (for-each proc items)
       ;; Exercise 4.30
       (if (null? items)
           'done
           (begin (proc (car items))
                  (for-each proc (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; expr-x
    (run env3)
    (check-equal? 'ok))

(racket:time
 (~&gt; '(multiple-dwelling-scheme-for-each)
     (runs env3)
     (check-equal? '(((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1)))))
 )
</code></pre>
<h2 id="4_42"><a class="header" href="#4_42">4_42</a></h2>
<pre><code class="language-lisp">;; file: 4_42.rkt
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; Q. "Liars" 퍼즐을 풀어라.
;; Phillips, Hubert. 1934. The Sphinx Problem Book. London: Faber and Faber.
;;
;; 각각 참/거짓을 하나씩 말 할 수 있음.
;;
;; Betty: Kitty == 2 // Betty == 3
;; Ethel: Ethel == 1 // Joan  == 2
;; Joan : Joan  == 3 // Ethel == 5
;; Kitty: Kitty == 2 // Mary  == 4
;; Mary : Mary  == 4 // Betty == 1

(define expr-liars
  '(define (liars-puzzle)
     (let ((betty (amb 1 2 3 4 5))
           (ethel (amb 1 2 3 4 5))
           (joan  (amb 1 2 3 4 5))
           (kitty (amb 1 2 3 4 5))
           (mary  (amb 1 2 3 4 5)))
       (require (lie-or-true (= kitty 2) (= betty 3)))
       (require (lie-or-true (= ethel 1) (= joan  2)))
       (require (lie-or-true (= joan  3) (= ethel 5)))
       (require (lie-or-true (= kitty 2) (= mary  4)))
       (require (lie-or-true (= mary  4) (= betty 1)))
       (require (distinct? (list betty ethel joan kitty mary)))
       (list (list 'betty betty)
             (list 'ethel ethel)
             (list 'joan  joan )
             (list 'kitty kitty)
             (list 'mary  mary )))))

(define env3 (setup-environment))
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items)
              true)
             ((null? (cdr items))
              true)
             ((member (car items) (cdr items))
              false)
             (else
              (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (lie-or-true x y)
       (not (eq? x y)))
    (run env3)
    (check-equal? 'ok))

(~&gt; expr-liars
    (run env3)
    (check-equal? 'ok))

(racket:time
 (~&gt; '(liars-puzzle)
     (runs env3)
     (check-equal? '(((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))))))
</code></pre>
<h2 id="4_43"><a class="header" href="#4_43">4_43</a></h2>
<pre><code class="language-lisp">;; file: 4_43.rkt
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; This is taken from a booklet called “Problematical Recreations,” published in the 1960s by Litton Industries, where it is attributed to the Kansas State Engineer.
;;
;; Mary Ann Moore의 아버지는 요트를 가지고 있으며1, 그의 네 친구인 Colonel Downing, Mr. Hall, Sir Barnacle Hood, Dr. Parker도 각각 요트를 가지고 있습니다.
;;
;; 이 다섯 사람 모두 각각 한 명의 딸이 있으며,
;; 각자는 자신의 요트 이름을 **다른 사람의 딸의 이름**으로 지었습니다.
;; 
;; Sir Barnacle Hood의 요트는 Gabrielle입니다.3
;; Mr. Moore는 Lorna를 소유하고 있습니다.4
;; Mr. Hall은 Rosalind를 소유하고 있습니다.6
;; Colonel Downing이 소유한 Melissa는5 Sir Barnacle Hood의 딸의 이름을 따서 지어졌습니다.2
;; Gabrielle의 아버지는 Dr. Parker의 딸의 이름을 딴 요트를 소유하고 있습니다.7 **
;; 
;; Lorna의 아버지는 누구입니까?
;;

;;
;; 프로그램을 효율적으로 실행되도록 작성해 보세요 (연습문제 4.40 참조).
;;
;; 4.40 Q. 모든 사람들을 층에 배정 후 백트래킹을 통해 이를 제거하는 방식은 매우 비효율적. 이전 제약 조건에 의해 이미 배제된 가능성만 생성하도록 하는, 훨씬 더 효율적인 비결정적 절차를 작성하고 이를 시연하라
;;
(define expr-find-father-v1
  '(begin
     (define (yacht-name owner)
       (cond ((eq? owner 'Sir-Barnacle-Hood) 'Gabrielle)
             ((eq? owner 'Mr-Moore)          'Lorna)
             ((eq? owner 'Mr-Hall)           'Rosalind)
             ((eq? owner 'Colonel-Downing)   'Melissa)
             ((eq? owner 'Dr-Parker)         'Mary-Ann-Moore)))
     (define (find-father-v1)
       ;; father  : Mr-Moore Colonel-Downing Mr-Hall Sir-Barnacle-Hood Dr-Parker
       ;; daughter: Mary-Ann-Moore Gabrielle Lorna Rosalind Melissa
  
       (let ((father-Mary-Ann-Moore 'Mr-Moore))
         ; Mary Ann Moore의 아버지는 요트를 가지고 있으며1. 이름으로써  Mr. Moore의 딸. 확정:(Mary-Ann-Moore Mr-Moore)
         
         (let ((father-Melissa 'Sir-Barnacle-Hood))
           ;  Melissa는 Sir Barnacle Hood의 딸의 이름을 따서 지어졌습니다.2             확정:(Melissa Sir-Barnacle-Hood)
           
           (let ((father-Gabrielle (amb 'Mr-Hall 'Colonel-Downing 'Dr-Parker))
                 (father-Lorna     (amb 'Mr-Hall 'Colonel-Downing 'Dr-Parker))
                 (father-Rosalind  (amb 'Mr-Hall 'Colonel-Downing 'Dr-Parker)))
             ;(require (not (eq? 'Sir-Barnacle-Hood father-Gabrielle))) ; Sir Barnacle Hood의 요트는 Gabrielle입니다.3  삭제가능 (Melissa Sir-Barnacle-Hood)
             ;(require (not (eq? 'Mr-Moore father-Lorna)))              ; Mr. Moore는 Lorna를 소유하고 있습니다.4       삭제가능 (Mary-Ann-Moore Mr-Moore)
             ;(require (not (eq? 'Colonel-Downing father-Melissa)))     ; Colonel Downing이 소유한 Melissa는5           삭제가능 (Melissa Sir-Barnacle-Hood)
             (require (not (eq? 'Mr-Hall father-Rosalind)))            ; Mr. Hall은 Rosalind를 소유하고 있습니다.6

             (let ((daughter-father-for-Dr-Parker (amb (cons 'Gabrielle father-Gabrielle)
                                                       (cons 'Lorna     father-Lorna)
                                                       (cons 'Rosalind  father-Rosalind))))
               ; Gabrielle의 아버지는 Dr. Parker의 딸의 이름을 딴 요트를 소유하고 있습니다.7 **
               ; - 아빠와 딸이 같이 붙어있는 제약조건으로 특이함.
               (require (eq? (cdr daughter-father-for-Dr-Parker) 'Dr-Parker))
               (require (eq? (yacht-name father-Gabrielle) (car daughter-father-for-Dr-Parker)))
               
               (require (distinct? (list father-Mary-Ann-Moore father-Gabrielle father-Lorna father-Rosalind father-Melissa)))
               (list (list 'Mary-Ann-Moore father-Mary-Ann-Moore)
                     (list 'Gabrielle      father-Gabrielle)
                     (list 'Lorna          father-Lorna)
                     (list 'Rosalind       father-Rosalind)
                     (list 'Melissa        father-Melissa)))))))
     )
  )

;;
;; 또한, Mary Ann의 성(last name)이 Moore라는 정보가 주어지지 않을 경우 해결책이 몇 개 있는지도 알아내세요.
;;
(define expr-find-father-v2
  '(begin
     (define (yacht-name owner)
       (cond ((eq? owner 'Sir-Barnacle-Hood) 'Gabrielle)
             ((eq? owner 'Mr-Moore)          'Lorna)
             ((eq? owner 'Mr-Hall)           'Rosalind)
             ((eq? owner 'Colonel-Downing)   'Melissa)
             ((eq? owner 'Dr-Parker)         'Mary-Ann-Moore)))
     (define (find-father-v2)
       ;; father  : Mr-Moore Colonel-Downing Mr-Hall Sir-Barnacle-Hood Dr-Parker
       ;; daughter: Mary-Ann-Moore Gabrielle Lorna Rosalind Melissa
  
       (let ((father-Melissa 'Sir-Barnacle-Hood))
         ;  Melissa는 Sir Barnacle Hood의 딸의 이름을 따서 지어졌습니다.2  확정:(Melissa Sir-Barnacle-Hood)
         
         (let ((father-Mary-Ann-Moore (amb 'Mr-Moore 'Colonel-Downing 'Mr-Hall 'Dr-Parker))
               (father-Gabrielle      (amb 'Mr-Moore 'Colonel-Downing 'Mr-Hall 'Dr-Parker))
               (father-Lorna          (amb 'Mr-Moore 'Colonel-Downing 'Mr-Hall 'Dr-Parker))
               (father-Rosalind       (amb 'Mr-Moore 'Colonel-Downing 'Mr-Hall 'Dr-Parker)))
           ; (require (not (eq? 'Sir-Barnacle-Hood father-Gabrielle))) ; Sir Barnacle Hood의 요트는 Gabrielle입니다.3 삭제가능 (Melissa Sir-Barnacle-Hood)
           (require (not (eq? 'Mr-Moore father-Lorna)))              ; Mr. Moore는 Lorna를 소유하고 있습니다.4
           ;(require (not (eq? 'Colonel-Downing father-Melissa)))     ; Colonel Downing이 소유한 Melissa는5           삭제가능 (Melissa Sir-Barnacle-Hood)
           (require (not (eq? 'Mr-Hall father-Rosalind)))            ; Mr. Hall은 Rosalind를 소유하고 있습니다.6

           (let ((daughter-father-for-Dr-Parker (amb (cons 'Mary-Ann-Moore father-Mary-Ann-Moore)
                                                     (cons 'Gabrielle father-Gabrielle)
                                                     (cons 'Lorna     father-Lorna)
                                                     (cons 'Rosalind  father-Rosalind))))
             ; Gabrielle의 아버지는 Dr. Parker의 딸의 이름을 딴 요트를 소유하고 있습니다.7 **
             ; - 아빠와 딸이 같이 붙어있는 제약조건으로 특이함.
             (require (eq? (cdr daughter-father-for-Dr-Parker) 'Dr-Parker))
             (require (eq? (yacht-name father-Gabrielle) (car daughter-father-for-Dr-Parker)))
               
             (require (distinct? (list father-Mary-Ann-Moore father-Gabrielle father-Lorna father-Rosalind father-Melissa)))
             (list (list 'Mary-Ann-Moore father-Mary-Ann-Moore)
                   (list 'Gabrielle      father-Gabrielle)
                   (list 'Lorna          father-Lorna)
                   (list 'Rosalind       father-Rosalind)
                   (list 'Melissa        father-Melissa)))))))
  )


(define env3 (setup-environment))
(define-variable! 'display (list 'primitive display) env3)
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(define (distinct? items)
       (cond ((null? items)
              true)
             ((null? (cdr items))
              true)
             ((member (car items) (cdr items))
              false)
             (else
              (distinct? (cdr items)))))
    (run env3)
    (check-equal? 'ok))

(~&gt; expr-find-father-v1
    (run env3)
    (check-equal? 'ok))


(~&gt; '(find-father-v1)
    (runs env3)
    (check-equal? '(((Mary-Ann-Moore Mr-Moore)
                     (Gabrielle Mr-Hall)
                     (Lorna Colonel-Downing)
                     (Rosalind Dr-Parker)
                     (Melissa Sir-Barnacle-Hood)))))


(~&gt; expr-find-father-v2
    (run env3)
    (check-equal? 'ok))


(~&gt; '(find-father-v2)
    (runs env3)
    (check-equal? '(((Mary-Ann-Moore Mr-Moore)
                     (Gabrielle Mr-Hall)
                     (Lorna Colonel-Downing)
                     (Rosalind Dr-Parker)
                     (Melissa Sir-Barnacle-Hood))
                    
                    ((Mary-Ann-Moore Mr-Hall)
                     (Gabrielle Mr-Moore)
                     (Lorna Dr-Parker)
                     (Rosalind Colonel-Downing)
                     (Melissa Sir-Barnacle-Hood)))))
</code></pre>
<h2 id="4_44"><a class="header" href="#4_44">4_44</a></h2>
<pre><code class="language-lisp">;; file: 4_44.rkt
;; 2_42 / 4_44

;; TODO Q. 8-queen 문제를 푸는 nondeterministic program을 작성해라.
</code></pre>
<h2 id="4_45"><a class="header" href="#4_45">4_45</a></h2>
<pre><code class="language-lisp">;; file: 4_45.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49

(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;;
;; Parsing natural language
;;
(define env3 (setup-environment))
(~&gt; '(define (require p)
       (if (not p)
           (amb)))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(begin
       (define nouns
         ;; noun: 명사
         '(noun student professor cat class))

       (define verbs
         ;; verb: 동사
         '(verb studies lectures eats sleeps))

       (define articles
         ;; article: 관사
         '(article the a))

       (define (parse-sentence)
         ;; sentence: 문장
         (list 'sentence
               (parse-noun-phrase)
               (parse-word verbs)))
       
       (define (parse-noun-phrase)
         ;; noun-phrase: 명사-구
         (list 'noun-phrase
               (parse-word articles)
               (parse-word nouns)))
       
       (define (parse-word word-list)
         (require (not (null? *unparsed*)))
         (require (memq (car *unparsed*) 
                        (cdr word-list)))
         (let ((found-word (car *unparsed*)))
           (set! *unparsed* (cdr *unparsed*))
           (list (car word-list) found-word)))
       
       (define *unparsed* '())
       
       (define (parse input)
         (set! *unparsed* input)
         (let ((sent (parse-sentence)))
           (require (null? *unparsed*))
           sent))
       )
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the cat eats))
    (run env3)
    (check-equal? '(sentence 
                    (noun-phrase (article the) (noun cat))
                    (verb eats))))
(~&gt; '(begin
       (define prepositions
         ;; preposition: 전치사 
         '(prep for to in by with))
       
       (define (parse-prepositional-phrase)
         ;; prepositional-phrase: 전치사-구
         (list 'prep-phrase
               (parse-word prepositions)
               (parse-noun-phrase)))
       
       (define (parse-sentence)
         (list 'sentence
               (parse-noun-phrase)
               (parse-verb-phrase)))

       (define (parse-verb-phrase)
         (define (maybe-extend verb-phrase)
           (amb 
            verb-phrase
            (maybe-extend 
             (list 'verb-phrase
                   verb-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-word verbs)))
       
       (define (parse-simple-noun-phrase)
         (list 'simple-noun-phrase
               (parse-word articles)
               (parse-word nouns)))
       
       (define (parse-noun-phrase)
         (define (maybe-extend noun-phrase)
           (amb 
            noun-phrase
            (maybe-extend 
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
         (maybe-extend (parse-simple-noun-phrase)))
       )
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the student with the cat 
                  sleeps in the class))
    (run env3)
    (check-equal? '(sentence
                    (noun-phrase
                     (simple-noun-phrase (article the) 
                                         (noun student))
                     (prep-phrase (prep with)
                                  (simple-noun-phrase
                                   (article the)
                                   (noun cat))))
                    (verb-phrase
                     (verb sleeps)
                     (prep-phrase (prep in)
                                  (simple-noun-phrase
                                   (article the)
                                   (noun class)))))))

(~&gt; '(parse '(the professor lectures to 
                  the student with the cat))
    (runs env3)
    (check-equal?
     '((sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb-phrase
          (verb lectures)
          (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student))))
         (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb lectures)
         (prep-phrase
          (prep to)
          (noun-phrase
           (simple-noun-phrase (article the) (noun student))
           (prep-phrase
            (prep with)
            (simple-noun-phrase (article the) (noun cat))))))))))

;; The professor lectures to the student in the class with the cat.를 5가지 방법으로 분석(parse)할 수 있음.
;; 의미를 설명해라.
;;
(~&gt; '(parse '(the professor lectures to the student in the class with the cat))
    (runs env3)
    (check-equal?
     '((sentence
        (simple-noun-phrase (article the) (noun professor))
        ;; 교수가 **고양이와 함께**, 교실에서 학생에게 강의한다. (교수가 고양이 동반)
        (verb-phrase
         (verb-phrase
          (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student))))
          (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
         (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
       (sentence
        ;; 교수가, **고양이가 있는 교실**에서, 학생에게 강의한다. (교실에 고양이가 있음, 교수/학생과 무관.)
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student))))
         (prep-phrase
          (prep in)
          (noun-phrase
           (simple-noun-phrase (article the) (noun class))
           (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
       (sentence
        (simple-noun-phrase (article the) (noun professor))
        ;; 교수가, **고양이와 함께 교실에 있는 학생에게**, 강의한다.
        (verb-phrase
         (verb-phrase
          (verb lectures)
          (prep-phrase
           (prep to)
           (noun-phrase
            (simple-noun-phrase (article the) (noun student))
            (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))))
         (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))
       (sentence
        ;; 교수가, 교실에 있는, **고양이와 함께 있는 학생**에게 강의한다.
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb lectures)
         (prep-phrase
          (prep to)
          (noun-phrase
           (noun-phrase
            (simple-noun-phrase (article the) (noun student))
            (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
           (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))
       (sentence
        ;; 교수가, **고양이가 있는 교실**에 있는, 학생에게 강의한다. (학생이 교실에 있고, 교실에 고양이가 있음.)
        (simple-noun-phrase (article the) (noun professor))
        (verb-phrase
         (verb lectures)
         (prep-phrase
          (prep to)
          (noun-phrase
           (simple-noun-phrase (article the) (noun student))
           (prep-phrase
            (prep in)
            (noun-phrase
             (simple-noun-phrase (article the) (noun class))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat))))))))))))



</code></pre>
<h2 id="4_46"><a class="header" href="#4_46">4_46</a></h2>
<pre><code class="language-lisp">;; file: 4_46.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49

;; 4.1(meval)과 4.2(leval)의 평가자는 피연산자(operand)가 평가되는 순서를 결정하지 않는다.
;; amb evaluator는 피연산자를 왼쪽에서 오른쪽으로 평가한다
;; Q. 피연산자를 다른 순서로 평가하면 파싱 프로그램이 동작하지 않는데, 그 이유는?
;;
;; parse가 *unparsed*를 사용하여 왼쪽에서 오른쪽으로 이동.
;; parse-sentense시 operand순서가 바뀌면 parse-noun-phrase보다 parse-word가 먼저 실행되어 구문 평가에 에러가 날것임.

'(define (parse input)
   (set! *unparsed* input)
   ...)

'(define (parse-word word-list)
   ...
   (set! *unparsed* (cdr *unparsed*))
   ...)

'(define (parse-sentence)
   ;; sentence: 문장
   (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
</code></pre>
<h2 id="4_47"><a class="header" href="#4_47">4_47</a></h2>
<pre><code class="language-lisp">;; file: 4_47.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49

;; Louis Reasoner: 동사구(verb phrase)가 단순히 동사(verb)이거나 동사구 뒤에 전치사구(prepositional phrase)가 따라오는 구조라고 주장.
;;
'(define (parse-verb-phrase)
   ;; 4_45: origin
   (define (maybe-extend verb-phrase)
     (amb 
      verb-phrase
      (maybe-extend 
       (list 'verb-phrase
             verb-phrase
             (parse-prepositional-phrase)))))
   (maybe-extend (parse-word verbs)))

'(define (parse-verb-phrase)
   ;; 4_47: Louis Reasoner
   (amb (parse-word verbs)
        (list 
         'verb-phrase
         (parse-verb-phrase)
         (parse-prepositional-phrase))))

;; Q. 이 방식이 제대로 동작하는가?
;;
;; 내부에서 호출하는 (parse-verb-phrase) 가 무한 루프를 일으킬 가능성.
;;
;; Q. amb 내부의 표현식 순서를 바꾸면 프로그램이 달리 동작하는가?
;;
;; 순서를 바꿔도 무한 루프 가능성은 사라지지 않음.
</code></pre>
<h2 id="4_48"><a class="header" href="#4_48">4_48</a></h2>
<pre><code class="language-lisp">;; file: 4_48.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))


;; 문법(grammar)을 더 복잡하게 확장시켜 보자.
;; 명사구와 동사구를 형용사(adjective)와 부사(adverb)를 포함하도록 한다거나, 중문(compound sentences)을 처리할 수 있도록 하거나.
;;
(define expr-base
  '(begin
     (define (require p)
       (if (not p)
           (amb)))

     (define nouns
       ;; noun: 명사
       '(noun student professor cat class))

     (define verbs
       ;; verb: 동사
       '(verb studies lectures eats sleeps))

     (define articles
       ;; article: 관사
       '(article the a))

     (define (parse-sentence)
       ;; sentence: 문장
       (list 'sentence
             (parse-noun-phrase)
             (parse-word verbs)))
       
     (define (parse-noun-phrase)
       ;; noun-phrase: 명사-구
       (list 'noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-word word-list)
       (require (not (null? *unparsed*)))
       (require (memq (car *unparsed*) 
                      (cdr word-list)))
       (let ((found-word (car *unparsed*)))
         (set! *unparsed* (cdr *unparsed*))
         (list (car word-list) found-word)))
       
     (define *unparsed* '())
       
     (define (parse input)
       (set! *unparsed* input)
       (let ((sent (parse-sentence)))
         (require (null? *unparsed*))
         sent))

     ;;===
     (define prepositions
       ;; preposition: 전치사 
       '(prep for to in by with))
       
     (define (parse-prepositional-phrase)
       ;; prepositional-phrase: 전치사-구
       (list 'prep-phrase
             (parse-word prepositions)
             (parse-noun-phrase)))
       
     (define (parse-sentence)
       (list 'sentence
             (parse-noun-phrase)
             (parse-verb-phrase)))

     (define (parse-verb-phrase)
       (define (maybe-extend verb-phrase)
         (amb 
          verb-phrase
          (maybe-extend 
           (list 'verb-phrase
                 verb-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-word verbs)))
       
     (define (parse-simple-noun-phrase)
       (list 'simple-noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-noun-phrase)
       (define (maybe-extend noun-phrase)
         (amb 
          noun-phrase
          (maybe-extend 
           (list 'noun-phrase
                 noun-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-simple-noun-phrase)))
     )
  )



(define env3 (setup-environment))
(define-variable! 'append (list 'primitive append) env3)
(~&gt; expr-base
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the cat eats))
    (runs env3)
    (check-equal?
     '((sentence (simple-noun-phrase (article the) (noun cat)) (verb eats)))))

(~&gt; '(begin
       (define adjectives
         ;; 형용사
         '(adj beautiful big quiet shiny warm cold fast slow powerful soft))

       (define (parse-complex-noun-phrase)
         ;; 관사 형용사 명사
         (list 'complex-noun-phrase
               (parse-word articles)
               (parse-word adjectives)
               (parse-word nouns)))

       (define (parse-noun-phrase)
         (define (maybe-extend noun-phrase)
           (amb 
            noun-phrase
            (maybe-extend 
             (list 'noun-phrase
                   noun-phrase
                   (parse-prepositional-phrase)))))
         ;; before
         ;;(maybe-extend (parse-simple-noun-phrase))
         ;;
         ;; after
         (amb (maybe-extend (parse-simple-noun-phrase))
              (maybe-extend (parse-complex-noun-phrase)))
         ))
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the beautiful cat eats))
    (runs env3)
    (check-equal? '((sentence
                     (complex-noun-phrase (article the) (adj beautiful) (noun cat))
                     (verb eats)))))

(~&gt; '(begin       
       (define adverbs
         ;; 부사
         '(adv quickly quietly loudly slowly carefully happily often rarely completely partly))

       (define (parse-adverb-list)
         (amb
          (list (parse-word adverbs))
          (cons (parse-word adverbs) (parse-adverb-list))))

       (define (parse-verb-phrase)
         (define (maybe-extend verb-phrase)
           (amb 
            verb-phrase
            (maybe-extend 
             (list 'verb-phrase
                   verb-phrase
                   (parse-prepositional-phrase)))))
         ;; before
         ;; (maybe-extend (parse-word verbs))
         ;;
         ;; after
         (amb (maybe-extend (parse-word verbs))
              (maybe-extend
               (list 'verb-phrase
                     (append (list 'adverb-list) (parse-adverb-list))
                     (parse-word verbs)))
              (maybe-extend
               (list 'verb-phrase
                     (parse-word verbs)
                     (append (list 'adverb-list) (parse-adverb-list))))
              ))
       )
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the beautiful cat eats quickly))
    (runs env3)    
    (check-equal?
     '((sentence
        (complex-noun-phrase (article the) (adj beautiful) (noun cat))
        (verb-phrase (verb eats) (adverb-list (adv quickly))))))
    )

(~&gt; '(begin
       
       (define coordinating-conjunctions
         ;; 등위 접속사
         '(coord-conj for and nor but or yet so))
               
       (define (parse-sentence)
         ;; before
         ;; (list 'sentence
         ;;       (parse-noun-phrase)
         ;;       (parse-verb-phrase))
         ;;
         ;; after
         (define (maybe-extend sentence)
           (amb 
            sentence
            (maybe-extend 
             (list 'compound-sentence
                   sentence
                   (parse-word coordinating-conjunctions)
                   (parse-sentence)))))
         (maybe-extend (list 'sentence
                             (parse-noun-phrase)
                             (parse-verb-phrase))))
       )
    (run env3)
    (check-equal? 'ok))


(~&gt; '(parse '(the cat eats and the cat eats))
    (runs env3)    
    (check-equal?
     '((compound-sentence
        (sentence (simple-noun-phrase (article the) (noun cat)) (verb eats))
        (coord-conj and)
        (sentence (simple-noun-phrase (article the) (noun cat)) (verb eats))))))
</code></pre>
<h2 id="4_49"><a class="header" href="#4_49">4_49</a></h2>
<pre><code class="language-lisp">;; file: 4_49.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49 / 4_50
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; Alyssa P. Hacker는 문장을 파싱하는 것보다 흥미로운 문장을 생성하는 데 더 관심이 있다.
;; 그녀는 parse-word 프로시저를 수정하여 "입력 문장"을 무시하고, 대신 항상 성공적으로 적절한 단어를 생성하도록 하면,
;; 기존에 파싱을 위해 작성된 프로그램을 문장 생성에 사용할 수 있다고 생각한다.
;; Alyssa의 아이디어를 구현하고, 생성된 처음 6개 정도의 문장을 보여라.


(define expr-base
  '(begin
     (define (require p)
       (if (not p)
           (amb)))

     (define nouns
       ;; noun: 명사
       '(noun student professor cat class))

     (define verbs
       ;; verb: 동사
       '(verb studies lectures eats sleeps))

     (define articles
       ;; article: 관사
       '(article the a))

     (define (parse-sentence)
       ;; sentence: 문장
       (list 'sentence
             (parse-noun-phrase)
             (parse-word verbs)))
       
     (define (parse-noun-phrase)
       ;; noun-phrase: 명사-구
       (list 'noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-word word-list)
       (require (not (null? *unparsed*)))
       (require (memq (car *unparsed*) 
                      (cdr word-list)))
       (let ((found-word (car *unparsed*)))
         (set! *unparsed* (cdr *unparsed*))
         (list (car word-list) found-word)))
       
     (define *unparsed* '())
       
     (define (parse input)
       (set! *unparsed* input)
       (let ((sent (parse-sentence)))
         (require (null? *unparsed*))
         sent))

     ;;===
     (define prepositions
       ;; preposition: 전치사 
       '(prep for to in by with))
       
     (define (parse-prepositional-phrase)
       ;; prepositional-phrase: 전치사-구
       (list 'prep-phrase
             (parse-word prepositions)
             (parse-noun-phrase)))
       
     (define (parse-sentence)
       (list 'sentence
             (parse-noun-phrase)
             (parse-verb-phrase)))

     (define (parse-verb-phrase)
       (define (maybe-extend verb-phrase)
         (amb 
          verb-phrase
          (maybe-extend 
           (list 'verb-phrase
                 verb-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-word verbs)))
       
     (define (parse-simple-noun-phrase)
       (list 'simple-noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-noun-phrase)
       (define (maybe-extend noun-phrase)
         (amb 
          noun-phrase
          (maybe-extend 
           (list 'noun-phrase
                 noun-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-simple-noun-phrase)))
     )
  )



(define env3 (setup-environment))
(define-variable! 'append (list 'primitive append) env3)
(define-variable! '&lt; (list 'primitive &lt;) env3)
(define-variable! 'error (list 'primitive error) env3)
(define-variable! 'random (list 'primitive random) env3)
(define-variable! 'length (list 'primitive length) env3)
(racket:random-seed 42)
(~&gt; expr-base
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the cat eats))
    (runs env3)
    (check-equal?
     '((sentence (simple-noun-phrase (article the) (noun cat)) (verb eats)))))


(~&gt; '(begin
       
       (define (nth lst n)
         (cond ((null? lst) (error "Index out of bounds"))
               ((&lt; n 0) (error "Index cannot be negative"))
               ((= n 0) (car lst))
               (else (nth (cdr lst) (- n 1)))))
       
       (define (parse-word word-list)
         (require (not (null? *unparsed*)))
         (require (memq (car *unparsed*) 
                        (cdr word-list)))
         (let ((found-word (car *unparsed*)))
           (set! *unparsed* (cdr *unparsed*))
           ;; before
           ;; (list (car word-list) found-word)

           ;; after
           (list (car word-list)
                 (nth (cdr word-list)
                      (random (length (cdr word-list)))))
           ))
       )
    (run env3))

(~&gt; '(parse '(the cat eats))
    (run env3)
    (check-equal? '(sentence (simple-noun-phrase (article the) (noun student)) (verb sleeps))))
</code></pre>
<h2 id="4_50"><a class="header" href="#4_50">4_50</a></h2>
<pre><code class="language-lisp">;; file: 4_50.rkt
;; 4_45 / 4_46 / 4_47 / 4_48 / 4_49 / 4_50
(#%require rackunit)
(#%require "../allcode/helper/my-util.rkt")
(#%require threading)
(#%require profile)
(#%require "../allcode/ch4-4.3.3-ambeval.rkt")
(#%require (prefix r5rs: r5rs))
(#%require (prefix racket: racket))

;; special form ramb를 만들자.
;; - amb : 인자 왼쪽에서 오른쪽으로 순서대로 고름.
;; - ramd: 순서를 random으로 고름.
;; 4.49에서 Alyssa의 문제를 푸는데 어떤 도움을 줄 수 있는가?

;; helper

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (remove item sequence)
  (filter (lambda (x) (not (eq? x item)))
          sequence))

;;
(define (ramb? exp)
  (tagged-list? exp 'ramb))

(define (analyze-ramb exp)
  (let ((cprocs (map analyze (rest exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ;; before: analyze-amb
            ;; ((car choices) env
            ;;                succeed
            ;;                (lambda ()
            ;;                  (try-next (cdr choices))))
            ;;
            ;; after: analyze-ramb
            (let* ((r-idx (random (length choices)))
                   (r-item (list-ref choices r-idx))
                   (next-items (remove r-item choices)))
              (r-item env
                      succeed
                      (lambda ()
                        (try-next next-items))))))
      (try-next cprocs))))

(define (analyze exp)
  (cond ((self-evaluating? exp) 
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond-&gt;if exp)))
        ((let? exp) (analyze (let-&gt;combination exp)))
        ((amb? exp) (analyze-amb exp))
        ((ramb? exp) (analyze-ramb exp))                ;**
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))

(override-analyze! analyze)

;;


(define expr-base
  '(begin
     (define (require p)
       (if (not p)
           (amb)))

     (define nouns
       ;; noun: 명사
       '(noun student professor cat class))

     (define verbs
       ;; verb: 동사
       '(verb studies lectures eats sleeps))

     (define articles
       ;; article: 관사
       '(article the a))

     (define (parse-sentence)
       ;; sentence: 문장
       (list 'sentence
             (parse-noun-phrase)
             (parse-word verbs)))
       
     (define (parse-noun-phrase)
       ;; noun-phrase: 명사-구
       (list 'noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-word word-list)
       (require (not (null? *unparsed*)))
       (require (memq (car *unparsed*) 
                      (cdr word-list)))
       (let ((found-word (car *unparsed*)))
         (set! *unparsed* (cdr *unparsed*))
         (list (car word-list) found-word)))
       
     (define *unparsed* '())
       
     (define (parse input)
       (set! *unparsed* input)
       (let ((sent (parse-sentence)))
         (require (null? *unparsed*))
         sent))

     ;;===
     (define prepositions
       ;; preposition: 전치사 
       '(prep for to in by with))
       
     (define (parse-prepositional-phrase)
       ;; prepositional-phrase: 전치사-구
       (list 'prep-phrase
             (parse-word prepositions)
             (parse-noun-phrase)))
       
     (define (parse-sentence)
       (list 'sentence
             (parse-noun-phrase)
             (parse-verb-phrase)))

     (define (parse-verb-phrase)
       (define (maybe-extend verb-phrase)
         (amb 
          verb-phrase
          (maybe-extend 
           (list 'verb-phrase
                 verb-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-word verbs)))
       
     (define (parse-simple-noun-phrase)
       (list 'simple-noun-phrase
             (parse-word articles)
             (parse-word nouns)))
       
     (define (parse-noun-phrase)
       (define (maybe-extend noun-phrase)
         (amb 
          noun-phrase
          (maybe-extend 
           (list 'noun-phrase
                 noun-phrase
                 (parse-prepositional-phrase)))))
       (maybe-extend (parse-simple-noun-phrase)))
     )
  )



(define env3 (setup-environment))
(define-variable! 'append (list 'primitive append) env3)
(define-variable! '&lt; (list 'primitive &lt;) env3)
(define-variable! 'error (list 'primitive error) env3)
(define-variable! 'random (list 'primitive random) env3)
(define-variable! 'length (list 'primitive length) env3)
(racket:random-seed 42)
(~&gt; expr-base
    (run env3)
    (check-equal? 'ok))

(~&gt; '(parse '(the cat eats))
    (runs env3)
    (check-equal?
     '((sentence (simple-noun-phrase (article the) (noun cat)) (verb eats)))))


(~&gt; '(begin
       (define (nth lst n)
         (cond ((null? lst) (error "Index out of bounds"))
               ((&lt; n 0) (error "Index cannot be negative"))
               ((= n 0) (car lst))
               (else (nth (cdr lst) (- n 1)))))
       (define (ramdom-select lst)
         (if (null? lst)
             '()
             (ramb (car lst)
                   (ramdom-select (cdr lst)))))     
       (define (parse-word word-list)
         
         (require (not (null? *unparsed*)))
         (require (memq (car *unparsed*) 
                        (cdr word-list)))
         (let ((found-word (car *unparsed*)))
           (set! *unparsed* (cdr *unparsed*))
           ;; before
           ;; (list (car word-list) found-word)
           ;;
           ;; before: 4.49
           ;; (list (car word-list)
           ;;       (nth (cdr word-list)
           ;;            (random (length (cdr word-list)))))
           ;;
           ;; after: 4.50
           (list (car word-list)
                 (ramdom-select (cdr word-list)))
           ))
       )
    (run env3))

(~&gt; '(parse '(the cat eats))
    (run env3)
    (check-equal? '(sentence (simple-noun-phrase (article the) (noun student)) (verb lectures))))
</code></pre>
<h2 id="4_51"><a class="header" href="#4_51">4_51</a></h2>
<pre><code class="language-lisp">;; file: 4_51.rkt
</code></pre>
<h2 id="4_52"><a class="header" href="#4_52">4_52</a></h2>
<pre><code class="language-lisp">;; file: 4_52.rkt
</code></pre>
<h2 id="4_53"><a class="header" href="#4_53">4_53</a></h2>
<pre><code class="language-lisp">;; file: 4_53.rkt
</code></pre>
<h2 id="4_54"><a class="header" href="#4_54">4_54</a></h2>
<pre><code class="language-lisp">;; file: 4_54.rkt
</code></pre>
<h2 id="4_55"><a class="header" href="#4_55">4_55</a></h2>
<pre><code class="language-lisp">;; file: 4_55.rkt
</code></pre>
<h2 id="4_56"><a class="header" href="#4_56">4_56</a></h2>
<pre><code class="language-lisp">;; file: 4_56.rkt
</code></pre>
<h2 id="4_57"><a class="header" href="#4_57">4_57</a></h2>
<pre><code class="language-lisp">;; file: 4_57.rkt
</code></pre>
<h2 id="4_58"><a class="header" href="#4_58">4_58</a></h2>
<pre><code class="language-lisp">;; file: 4_58.rkt
</code></pre>
<h2 id="4_59"><a class="header" href="#4_59">4_59</a></h2>
<pre><code class="language-lisp">;; file: 4_59.rkt
</code></pre>
<h2 id="4_60"><a class="header" href="#4_60">4_60</a></h2>
<pre><code class="language-lisp">;; file: 4_60.rkt
</code></pre>
<h2 id="4_61"><a class="header" href="#4_61">4_61</a></h2>
<pre><code class="language-lisp">;; file: 4_61.rkt
</code></pre>
<h2 id="4_62"><a class="header" href="#4_62">4_62</a></h2>
<pre><code class="language-lisp">;; file: 4_62.rkt
</code></pre>
<h2 id="4_63"><a class="header" href="#4_63">4_63</a></h2>
<pre><code class="language-lisp">;; file: 4_63.rkt
</code></pre>
<h2 id="4_64"><a class="header" href="#4_64">4_64</a></h2>
<pre><code class="language-lisp">;; file: 4_64.rkt
</code></pre>
<h2 id="4_65"><a class="header" href="#4_65">4_65</a></h2>
<pre><code class="language-lisp">;; file: 4_65.rkt
</code></pre>
<h2 id="4_66"><a class="header" href="#4_66">4_66</a></h2>
<pre><code class="language-lisp">;; file: 4_66.rkt
</code></pre>
<h2 id="4_67"><a class="header" href="#4_67">4_67</a></h2>
<pre><code class="language-lisp">;; file: 4_67.rkt
</code></pre>
<h2 id="4_68"><a class="header" href="#4_68">4_68</a></h2>
<pre><code class="language-lisp">;; file: 4_68.rkt
</code></pre>
<h2 id="4_69"><a class="header" href="#4_69">4_69</a></h2>
<pre><code class="language-lisp">;; file: 4_69.rkt
</code></pre>
<h2 id="4_70"><a class="header" href="#4_70">4_70</a></h2>
<pre><code class="language-lisp">;; file: 4_70.rkt
</code></pre>
<h2 id="4_71"><a class="header" href="#4_71">4_71</a></h2>
<pre><code class="language-lisp">;; file: 4_71.rkt
</code></pre>
<h2 id="4_72"><a class="header" href="#4_72">4_72</a></h2>
<pre><code class="language-lisp">;; file: 4_72.rkt
</code></pre>
<h2 id="4_73"><a class="header" href="#4_73">4_73</a></h2>
<pre><code class="language-lisp">;; file: 4_73.rkt
</code></pre>
<h2 id="4_74"><a class="header" href="#4_74">4_74</a></h2>
<pre><code class="language-lisp">;; file: 4_74.rkt
</code></pre>
<h2 id="4_75"><a class="header" href="#4_75">4_75</a></h2>
<pre><code class="language-lisp">;; file: 4_75.rkt
</code></pre>
<h2 id="4_76"><a class="header" href="#4_76">4_76</a></h2>
<pre><code class="language-lisp">;; file: 4_76.rkt
</code></pre>
<h2 id="4_77"><a class="header" href="#4_77">4_77</a></h2>
<pre><code class="language-lisp">;; file: 4_77.rkt
</code></pre>
<h2 id="4_78"><a class="header" href="#4_78">4_78</a></h2>
<pre><code class="language-lisp">;; file: 4_78.rkt
</code></pre>
<h2 id="4_79"><a class="header" href="#4_79">4_79</a></h2>
<pre><code class="language-lisp">;; file: 4_79.rkt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="연습문제-풀이-05"><a class="header" href="#연습문제-풀이-05">연습문제 풀이 05</a></h1>
<ul>
<li><a href="https://github.com/netpyoung/sicp-journey/tree/main/source/solution_05">https://github.com/netpyoung/sicp-journey/tree/main/source/solution_05</a></li>
</ul>
<h2 id="5_01"><a class="header" href="#5_01">5_01</a></h2>
<pre><code class="language-lisp">;; file: 5_01.rkt
</code></pre>
<h2 id="5_02"><a class="header" href="#5_02">5_02</a></h2>
<pre><code class="language-lisp">;; file: 5_02.rkt
</code></pre>
<h2 id="5_03"><a class="header" href="#5_03">5_03</a></h2>
<pre><code class="language-lisp">;; file: 5_03.rkt
</code></pre>
<h2 id="5_04"><a class="header" href="#5_04">5_04</a></h2>
<pre><code class="language-lisp">;; file: 5_04.rkt
</code></pre>
<h2 id="5_05"><a class="header" href="#5_05">5_05</a></h2>
<pre><code class="language-lisp">;; file: 5_05.rkt
</code></pre>
<h2 id="5_06"><a class="header" href="#5_06">5_06</a></h2>
<pre><code class="language-lisp">;; file: 5_06.rkt
</code></pre>
<h2 id="5_07"><a class="header" href="#5_07">5_07</a></h2>
<pre><code class="language-lisp">;; file: 5_07.rkt
</code></pre>
<h2 id="5_08"><a class="header" href="#5_08">5_08</a></h2>
<pre><code class="language-lisp">;; file: 5_08.rkt
</code></pre>
<h2 id="5_09"><a class="header" href="#5_09">5_09</a></h2>
<pre><code class="language-lisp">;; file: 5_09.rkt
</code></pre>
<h2 id="5_10"><a class="header" href="#5_10">5_10</a></h2>
<pre><code class="language-lisp">;; file: 5_10.rkt
</code></pre>
<h2 id="5_11"><a class="header" href="#5_11">5_11</a></h2>
<pre><code class="language-lisp">;; file: 5_11.rkt
</code></pre>
<h2 id="5_12"><a class="header" href="#5_12">5_12</a></h2>
<pre><code class="language-lisp">;; file: 5_12.rkt
</code></pre>
<h2 id="5_13"><a class="header" href="#5_13">5_13</a></h2>
<pre><code class="language-lisp">;; file: 5_13.rkt
</code></pre>
<h2 id="5_14"><a class="header" href="#5_14">5_14</a></h2>
<pre><code class="language-lisp">;; file: 5_14.rkt
</code></pre>
<h2 id="5_15"><a class="header" href="#5_15">5_15</a></h2>
<pre><code class="language-lisp">;; file: 5_15.rkt
</code></pre>
<h2 id="5_16"><a class="header" href="#5_16">5_16</a></h2>
<pre><code class="language-lisp">;; file: 5_16.rkt
</code></pre>
<h2 id="5_17"><a class="header" href="#5_17">5_17</a></h2>
<pre><code class="language-lisp">;; file: 5_17.rkt
</code></pre>
<h2 id="5_18"><a class="header" href="#5_18">5_18</a></h2>
<pre><code class="language-lisp">;; file: 5_18.rkt
</code></pre>
<h2 id="5_19"><a class="header" href="#5_19">5_19</a></h2>
<pre><code class="language-lisp">;; file: 5_19.rkt
</code></pre>
<h2 id="5_20"><a class="header" href="#5_20">5_20</a></h2>
<pre><code class="language-lisp">;; file: 5_20.rkt
</code></pre>
<h2 id="5_21"><a class="header" href="#5_21">5_21</a></h2>
<pre><code class="language-lisp">;; file: 5_21.rkt
</code></pre>
<h2 id="5_22"><a class="header" href="#5_22">5_22</a></h2>
<pre><code class="language-lisp">;; file: 5_22.rkt
</code></pre>
<h2 id="5_23"><a class="header" href="#5_23">5_23</a></h2>
<pre><code class="language-lisp">;; file: 5_23.rkt
</code></pre>
<h2 id="5_24"><a class="header" href="#5_24">5_24</a></h2>
<pre><code class="language-lisp">;; file: 5_24.rkt
</code></pre>
<h2 id="5_25"><a class="header" href="#5_25">5_25</a></h2>
<pre><code class="language-lisp">;; file: 5_25.rkt
</code></pre>
<h2 id="5_26"><a class="header" href="#5_26">5_26</a></h2>
<pre><code class="language-lisp">;; file: 5_26.rkt
</code></pre>
<h2 id="5_27"><a class="header" href="#5_27">5_27</a></h2>
<pre><code class="language-lisp">;; file: 5_27.rkt
</code></pre>
<h2 id="5_28"><a class="header" href="#5_28">5_28</a></h2>
<pre><code class="language-lisp">;; file: 5_28.rkt
</code></pre>
<h2 id="5_29"><a class="header" href="#5_29">5_29</a></h2>
<pre><code class="language-lisp">;; file: 5_29.rkt
</code></pre>
<h2 id="5_30"><a class="header" href="#5_30">5_30</a></h2>
<pre><code class="language-lisp">;; file: 5_30.rkt
</code></pre>
<h2 id="5_31"><a class="header" href="#5_31">5_31</a></h2>
<pre><code class="language-lisp">;; file: 5_31.rkt
</code></pre>
<h2 id="5_32"><a class="header" href="#5_32">5_32</a></h2>
<pre><code class="language-lisp">;; file: 5_32.rkt
</code></pre>
<h2 id="5_33"><a class="header" href="#5_33">5_33</a></h2>
<pre><code class="language-lisp">;; file: 5_33.rkt
</code></pre>
<h2 id="5_34"><a class="header" href="#5_34">5_34</a></h2>
<pre><code class="language-lisp">;; file: 5_34.rkt
</code></pre>
<h2 id="5_35"><a class="header" href="#5_35">5_35</a></h2>
<pre><code class="language-lisp">;; file: 5_35.rkt
</code></pre>
<h2 id="5_36"><a class="header" href="#5_36">5_36</a></h2>
<pre><code class="language-lisp">;; file: 5_36.rkt
</code></pre>
<h2 id="5_37"><a class="header" href="#5_37">5_37</a></h2>
<pre><code class="language-lisp">;; file: 5_37.rkt
</code></pre>
<h2 id="5_38"><a class="header" href="#5_38">5_38</a></h2>
<pre><code class="language-lisp">;; file: 5_38.rkt
</code></pre>
<h2 id="5_39"><a class="header" href="#5_39">5_39</a></h2>
<pre><code class="language-lisp">;; file: 5_39.rkt
</code></pre>
<h2 id="5_40"><a class="header" href="#5_40">5_40</a></h2>
<pre><code class="language-lisp">;; file: 5_40.rkt
</code></pre>
<h2 id="5_41"><a class="header" href="#5_41">5_41</a></h2>
<pre><code class="language-lisp">;; file: 5_41.rkt
</code></pre>
<h2 id="5_42"><a class="header" href="#5_42">5_42</a></h2>
<pre><code class="language-lisp">;; file: 5_42.rkt
</code></pre>
<h2 id="5_43"><a class="header" href="#5_43">5_43</a></h2>
<pre><code class="language-lisp">;; file: 5_43.rkt
</code></pre>
<h2 id="5_44"><a class="header" href="#5_44">5_44</a></h2>
<pre><code class="language-lisp">;; file: 5_44.rkt
</code></pre>
<h2 id="5_45"><a class="header" href="#5_45">5_45</a></h2>
<pre><code class="language-lisp">;; file: 5_45.rkt
</code></pre>
<h2 id="5_46"><a class="header" href="#5_46">5_46</a></h2>
<pre><code class="language-lisp">;; file: 5_46.rkt
</code></pre>
<h2 id="5_47"><a class="header" href="#5_47">5_47</a></h2>
<pre><code class="language-lisp">;; file: 5_47.rkt
</code></pre>
<h2 id="5_48"><a class="header" href="#5_48">5_48</a></h2>
<pre><code class="language-lisp">;; file: 5_48.rkt
</code></pre>
<h2 id="5_49"><a class="header" href="#5_49">5_49</a></h2>
<pre><code class="language-lisp">;; file: 5_49.rkt
</code></pre>
<h2 id="5_50"><a class="header" href="#5_50">5_50</a></h2>
<pre><code class="language-lisp">;; file: 5_50.rkt
</code></pre>
<h2 id="5_51"><a class="header" href="#5_51">5_51</a></h2>
<pre><code class="language-lisp">;; file: 5_51.rkt
</code></pre>
<h2 id="5_52"><a class="header" href="#5_52">5_52</a></h2>
<pre><code class="language-lisp">;; file: 5_52.rkt
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
